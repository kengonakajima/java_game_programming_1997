
第4章、Javaに慣れる

この章から、いよいよJavaプログラミングを始めます。例題を中心とし、例をいろい
ろ いじくっているうちに理解が進むようになっています。本書の例題はCD-ROMに記
録されて いますが、それらをコピーするのではなくて、ぜひ自分の手でエディタを
使って入力し、 Javaのコンパイラやアプレットビュアとと格闘してください。その
体験が骨となり、肉と なっていくはずです。



4.1 最低限の文法知識

     本書は、Java言語の解説書ではありません。いかに面白いゲームを作るか、と
     いう ことを追及しています。そして、本書で使用する言語が、たまたまJava言
     語であるだけです。
     ゲームを作るためには、Java言語の全体のうち、一部だけを理解すれば、 十分
     です。その必要な部分だけをしっかり理解できれば、どんなゲームでも作れま
     す。 この章では、その「必要な部分」について、解説します。
     ここで説明する文法事項は、後に実際にプログラムしていく時に、しばしば読
     みなおす ことがあると思います。後のほうでわからなくなっても、確実にこの
     章で説明している ことしか使わないので、ここをもういちど読めば理解できる
     はずです。 また、実例として挙がっているプログラムは、テキストエディタで
     打ちこんでコンパイル して実行することができるようになっていますので、ひ
     とつひとつ打ちこんで試してみて ください。その際に、いろいろ変更してどの
     ようになるのか実験してください。保存するファイル 名を、間違えないように
     注意してください。また、それぞれのアプレットを動かすための HTMLのファイ
     ルの例も掲載してあります。別のファイルとして作成してください。 もしエラ
     ーが出た場合は、本章の最後にあるエラーメッセージの説明が参考になるでし
     ょう。


       4.1.1 アプレットが動作するために必要なもの

          JDKがきちんとインストールされているなら、 ひとつ以上の「クラスファ
          イル」とひとつの「HTMLファイル」があれば、アプレットを動かす こと
          ができます。 「クラスファイル」を作るためには、Javaの「ソースファ
          イル」が必要です。 「クラスファイル」は、「ソースファイル」をコン
          パイルすると作成されます。あなたは、 「クラスファイル」の中身がど
          うなっているのかは知る必要がありません。
          したがって、あなたは、エディタを使って、「ソースファイル」と「HTML
          ファイル」を作る ことになります。
          「ソースファイル」の拡張子(ファイル名の末尾)は、.javaで、 「HTMLフ
          ァイル」の拡張子は、.htmlです。これらのファイルの代表的な例は次の
          ようなものです。


File name: first.java
----------------------------------------------------------------

import java.awt.*;
public class first extends java.applet.Applet
{
    public void paint(Graphics g )
	{
  		g.drawString("Yahoo java!",50,50);
	}
}
----------------------------------------------------------------



File name: test.html
----------------------------------------------------------------
<applet code=first.class width=200 height=200></applet>
----------------------------------------------------------------

#図4.1.1-1 <DONE>        動作結果(first.java)



          ファイルがごちゃごちゃになってしまわないように、これらのファイルを
          作る時には、 ディレクトリ(フォルダ)を新しく作っておいて、その中に
          保存するようにします。
          まずfirst.javaを入力して保存します。それを javac(Macintoshの場合は
          java compilerです) を使ってコンパイルします。間違いがあれば、コン
          パイラがエラーを出します。 エラーがない場合は、javacは何も画面に出
          しません。
          以上が成功すると、first.classというファイルができます。 test.html
          に書かれているfirst.classは、このクラスファイルを 読みこめ、という
          指令です。 最後にappletviewerを起動して、アプレットを実行させま
          す。Windows95や UNIXの場合は、MS-DOSプロンプトまたは端末エミュレー
          タの中で

          C:\java\myfolder\>appletviewer test.html

          のようにします。Macintoshの場合は、appletviewerのアイコンの上に あ
          なたが作成したHTMLファイルtest.htmlを重ねます。そうすると実行がは
          じまります。 画面には小さなウインドウが出現し、中に文字が出ます。


       4.1.2 Javaのプログラムとは

          Javaのプログラムは、.javaという名前のソースファイルで、その中に
          は、 「クラスの宣言」がひとつ以上書かれています。クラス宣言とは、
          classや public class で始まり、中括弧でくくられている部分です。ク
          ラス宣言の中にはいろいろなプログラム を書くことができますが、外に
          はimportとpackageの部分以外は書くことはできません。(importとpackage
		  については、本文では説明しません。巻末のリファレンスを参照してくだ
		  さい。)

#図4.1.2-1<NOT YET>        Javaのプログラムの構造


          ここで、プログラミングで日常的に使われる、「中、外」とか「ネスト」
          といった言葉の意味を解説します。
          「中」とか「外」というのは、主に、括弧記号"{"と"}" とでくくられて
          いる部分の中か外かという意味で使います。 例えば次のようなプログラ
          ムの場合、


File name:hoge.java
----------------------------------------------------------------
//どこでも、//を使って、註釈を付けることができます。
//このプログラムをエディタで入力するときは、行番号を入力する必要はありません。
 1:import java.awt.*;
 2:public class hoge extends java.applet.Applet
 3:{
 4:    int i=0;
 5:
 6:    public void paint( Graphics g )
 7:    {
 8:        g.drawLine( 30,30,60,100 );
 9:    }
10:}
11:class tamesi
12:{
13:    //内容はないけれど、これもクラス宣言。
14:}
----------------------------------------------------------------

File name: test.html
----------------------------------------------------------------
<applet code=hoge.class width=200 height=200></applet>
----------------------------------------------------------------

#図4.1.2-2 <DONE>         動作結果(hoge.java)



          int i=0;
          は、クラス宣言の中にあるわけです。
          import java.applet.Applet;
          はクラス宣言の外です。中括弧はいくつ 重なってもよいので、Cもクラス
          宣言の中です。またCはif文の中とも 言えます。(if文については、後ほ
          ど説明します) このように中括弧"{"がたくさんあると、どんどん「中」
          に入っていきます。 どれだけ「中」のほうであるか、ということを、
          「深さ」とも言います。
          int i=0;
          のところは深さ1で、
          g.drawLine( 30,30,60,100 )
          のところは深さ2と言えます。よく言うのは、「何段ネストしている」 と
          いう表現です。 g.drawLine( 30,30,60,100 )
          のところは、「2段ネストしている」というわけです。 プログラムの外見
          上も、 その行に書くプログラムがどれだけネストしているかどうかが一
          目見てわかる ように、タブ(Tab)キーを使って、ネストの深さの分だけ右
          にずらします。 プログラムをする時には、後で見やすいようにしておく
          ということが 非常に重要になってきます。それは、ある程度の大きさの
          プログラムを書く ようになると、すぐにわかることと思います。

#図4.1.2-3<NOT YET>        インデント


          以下のように汚いインデントにした場合は、後で困ることうけあいです。


File name: hoge.java
----------------------------------------------------------------
import java.awt.*;
class hoge extends java.applet.Applet {int
i=0;
public void paint( Graphics g
){g.drawLine( 30,30,60,100 );}}
class tamesi{}
----------------------------------------------------------------

          なお、このプログラムを実行するには、appletviewer で、test.htmlを指
          定してください。
          この例からもわかるように、 ひとつのソースファイルの中にいくつでも
          クラスを書くことができます。 それをコンパイルすると、 いくつものク
          ラスファイルができます。また、たくさんのクラスを一つの ファイルに
          書いていくと、どんどんファイルが大きくなっていってしまう ので、そ
          ういう場合は、いくつかの ファイルに分けて別々にコンパイルしてもか
          まいません。その場合は、 ひとつのクラスのソースをいくつものファイ
          ルに分けることはできません ので注意してください。また、いくつかに
          分けても、最も主要なクラスを コンパイルすれば、自動的に分けた他の
          ソースコードもコンパイルされる ようになっています。
          ソースファイルの中に何らかの間違いがあった場合、コンパイルは中断し
          ます。そして クラスファイルは作られません。以前にできたクラスファ
          イルは残っていますので、 注意が必要です。コンパイルが中断された場
          合は、コンパイラはエラーメッセージを 出力します。そのエラーメッセ
          ージの意味については、本章の最後に解説があります。


       4.1.3 プログラムの進行(メソッド)

          プログラムは、特に何も指定しないと、上から下へ実行されていきます。
          同じ行の 中では、左から右へ実行されます。これは日本語や英語などの
          進みかたと同じです。 もちろん、戻したり飛ばしたりするための命令も
          用意されているので、多彩な 実行をさせることができます。
          サンプルプログラムを見てください。



File name:shinkou.java
------------------------------------------------------------
 1:import java.applet.Applet;  
 2:import java.awt.*;
 3:public class shinkou extends Applet  //数字を表示する
 4:{
 5:   int i=0,r=0;;
 6:   public void init()
 7:   {
 8:       int k=2;
 9:       k = k + 2; r = tasu( k , i );
10:   }
11:   public void paint(Graphics g )
12:   {
13:       g.drawString( Integer.toString( r ) , 30,30);
14:   }
15:   int tasu( int a, int b )
16:   {
17:       return a + b;
18:   }
19:}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=sinkou.class width=200 height=300></applet>
------------------------------------------------------------

#図4.1.3-1<DONE>	  動作結果(shinkou.java)


          それぞれのクラス宣言の中では、一段ネストしていますが、ちょうど一段
          の ネストになっている行(5,6,7,10,11,12,14,15,16,18行)に
          public void init()
          public void paint( Graphics g )
          int tasu(int a , int b )
          の3行があります。
          プログラムの実行は、このような部分から始まります。 このプログラム
          の場合は、最初に
          public void init() から始まります。この行の次の行に中括弧が始まっ
          ていますが、 この中括弧が閉じるまでが一つのプログラムの実行の単位
          になっています。つまり
            6:public void init()
            7:{
            8:     int k=2;
            9:     k = k + 2; r = tasu( k , i );
           10:}

          が一つの単位です。この実行単位を「メソッド」と呼びます。 Javaのプ
          ログラム は、メソッド単位で動いているということです。
          ひとつのクラス宣言の中には、複数のメソッドを含めることができます。
          上の例では、public void init()というメソッドと、 public void
          paint(Graphics g )というメソッドと、 int tasu(int a, int b )という
          メソッドの３つが あるわけです。メソッドは何十個あってもOKです。い
          くつも メソッドがある場合は、どのメソッドがどのような順番で呼ばれ
          るかを自 分で決めていく必要があります。 一番最初に呼びだされるの
          は、public void init() というメソッド です。また、このプログラムで
          は、public void init() を実行している最中に、 9行、r=tasu(k,i);の
          ように書くことによって int tasu(int a,int b)メソッドを呼びだしてい
          ます。 プログラムの流れは、まずpublic void init() の最初の行から始
          まり、8行まで実行し、その途中で int tasu(int a , int b ) メソッド
          の最初の行(15行)に飛び、このメソッドを実行し終わったら、ふたたび
          public void init()の9行 に戻ってくる、という感じになっています。そ
          して10行まで実行すると、 public void init()の実行は終了します。
          メソッドの名前は、基本的に自分で 自由に決めることができますが、シ
          ステムによって名前が規定されている ものもあります。それはそれぞれ
          が登場してきたときに説明します。


       4.1.4 System.out.println()

          Javaでは、簡単に文字を画面に表示することができます。そのためには、
          System.out.println( 表示したいもの )というメソッドを使います。 本
          来は、文字を表示するということは文法の説明ではないのですが、 以降
          の文法の説明でSystem.out.println()は非常に役にたつ ので、ここで説
          明します。サンプルプログラムを入力してみてください。 


File name: printTest.java
------------------------------------------------------------
public class printTest extends java.applet.Applet
{
    public void init()
    {
        System.out.println("hello!");
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=prinTest.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.4-1<DONE>	  動作結果(printTest.java)

------------
$ 
$ appletviewer test.html
hello!

------------


          この例の場合は、表示したいものが文字列であるため、Javaの文法に従っ
          て「"」で囲っています。 実行させると、画面にどのような変化が ある
          でしょうか？まず新しいウィンドウが出現します。 それとは別のウイン
          ドウに、hello! という文字が表示されていると思います。 必ずどこかの
          ウインドウに表示されているはずですので、探してみてください。
          hello!と表示されているウインドウが、「標準出力」です。標準出力と
          は、 System.out.println()メソッドによって文字が出てくるウインドウ
          のことです。 それは機種によって違いますが、必ずあります。 以下、
          「標準出力に表示する」という場合、System.out.println を使って、文
          字を出すことを意味します。こうやって簡単に文字を出せる ので、デバ
          ッグが容易になっています。こうやって画面に文字を出すことを、
		  「標準出力へ、出力する。」というふうに表現します。

		 * Visual J++ をお使いの方へ

		  Visual J++ でアプレットを動作させても、どこにも"hello!"とは表示
          されません。Visual J++は、アプレットを実行させるためにInternet
		  Explorerを使用していて、InternetExplorerは標準出力を持たないから
          です。ただし、Internet Explorerのメニューの「表示」->「詳細」
		  の中に、「JAVAログ」の項目がありますので、そのチェックボックスに
		  印をつけることで、C:\WINDOWS\JAVA\JAVALOG.TXTという0バイトのサイズ
	      の中に、標準出力に出力されるはずだった内容を、保存させることができ
          ます。標準出力は、プログラミングの勉強にとっては非常に重要ですので、
		  何とかして標準出力を見る方法を以下に挙げます。

		  o C:\WINDOWS\JAVA\JAVALOG.TXT の内容を、実行させるたびにチェック
		  する。これはひどく繁雑なのでおすすめできません。

	      o Visual J++ 以外に、JDKもインストールして、Visual J++は高速な
		  コンパイラつきエディタとして使う。
		  この場合は、MS-DOSプロンプトをもうひとつ
		  開いておく必要があります。筆者は、Microsoft developer studioはなか
		  なか操作性がよいので、この方法はなかなかいいのではないかと思います。

		  o 本書の付録で紹介している、筆者作のConsoleクラス群を使う。この方法を
		  使うと、アプレットのプログラムに少しの変更を加えるだけで、Visual J++
		  の環境でも標準出力(のようなもの)が使えるようになります。これを可能
	 	  にするためには、多少設定をしてやる必要があるのと、CD-ROMからファイル
		  をコピーする必要があります。それについては、付録を参照してください。

		  プログラムは、以下のように変更するだけです。この章で出てくる全ての
		  例を、以下の例に従って変更すれば、Visual J++でも標準出力(のような
		  もの)を使って、プログラムのデバッグをすることができます。現在は、
		  例外が発生したときのメッセージが出力されませんが、Visual J++が
		  JDK1.1になると、  できるようになります。(付録を参照。)

		  元のプログラム:

File name: before.java
-------------------------------------------------
public class before extends java.applet.Applet
{
	public void init(){
		System.out.println("This is normal applet program.");
	}
}
-------------------------------------------------
		  変更後のプログラム：
File name: after.java
-------------------------------------------------
import ringo.*;		// まず、パッケージ 'ringo'をimportします。
public class after extends java.applet.Applet
{
	public void init(){
		// Systemを、Consoleに変えます。
		Console.out.println("This is normal applet program.");
	}
}
-------------------------------------------------
		プログラムをこのように変更すると、Console.out.println(...)とした時に
	 	画面に小さいウインドウが現れて、その中に内容が表示されます。ファイルに
		保存する機能も付けましたので、役にたつことと思います。活用してください。

#図4.1.4-2<DONE>		Consoleクラスを使った時の画面




       4.1.5 データ構造

          データ構造というのは、様々な情報を管理するやりかたのことです。
          情報がたくさんある場合、それを乱雑に置いておいたのでは、処理するこ
          とが できません。それを防ぐためには、情報を順序立てて整理したり分
          類したりする 必要があります。 例えば、普通に情報を表にして並べると
          いう方法がありますね。

#表4.1.5<DONE>        ドラクエみたいな敵のパラメータの表


               名前  体力   攻撃力
---------------------------------------
           スライム     4        2
           ゴースト    12        6
           がいこつ    34       22
           ドラゴン   104       72
---------------------------------------

          他にも、辞書では、多くの情報を、検索しやすいようにアルファベットの
          順で 並べてあります。もしもぐちゃぐちゃな順番で単語が並んでいた
          ら、使えない 辞書になってしまいます。
          コンピューター上のプログラムは、このデータ構造に基づいて、ある決ま
          った 処理をします。だからデータ構造はプログラミングにおいては非常
          に重要です。 データ構造が違うだけで、結果は同じなのに、実行速度が
          100倍違うなんて ことも起こります。プログラミングにおいては、データ
          構造のデザインが 半分以上を占める、と言ってよいかもしれません。
          では次に、データ構造を作る最小単位「変数」について。


       4.1.6 変数

          変数は、データの入れもの。

          プログラムとは、データを扱う方法を記述したものです。プログラムの
          中では、何らかの方法で、データを保存し、記述しなければなりません。
          その保存のやりかたを、「データ構造」と呼ぶのでした。 Javaでは、デ
          ータを扱うために、変数というものを使います。中学や 高校では、数学
          の授業で、xとかyとか、そういう文字を使って、変数を 表していました
          が、それと同じように、変数を使います。
          たとえば、人間の頭の中で、10と20を足す計算をするとしましょう。 そ
          の時は、少なくても、10と20というふたつの数字を頭のどこかに記憶 し
          ておく必要がありますね。実際にやってみてばわかると思いますが。 そ
          れと同じように、その計算をプログラムでやる時にも、どこかに覚えて
          おく必要があります。変数はそのためにも使えますし、さらに複雑な計算
          をするためには、どうしても必要になってきます。

          Javaで情報を記憶するには、記憶したい情報の種類に応じて、「型」を
          使いわけます。整数を入れるための変数、文字を入れるための変数、 と
          いうように。Javaでは、数値や、文字などの基本的な情報の単位を記憶し
          ておく ための変数として、「基本型」をいくつか用意しています。
          基本型には、整数型であるbyte、short、int、 long、文字型である
          char、浮動小数型であるfloat、 double、真偽値型であるbooleanがあり
          ます。 それぞれの値の範囲とかについての詳しいことは、言語仕様のリ
          ファレンス ページを見てください。

          ゲームプログラムをするときには、変数を使って、現在主人公はx座標が
          120、y座標が100の位置にいる、ということを管理するわけです。数値
          は、 点数や座標を扱う時に必要です。ゲームで出てくるほとんどの数値
          は、intを使えば 事が足りるということがわかりますね。従って、整数を
          扱う場合は、何も考えずにint を使って一向に構いません。実際筆者もゲ
          ームを作るときはそうしています。

          基本型を使ったプログラムの例を示します。


File name: kihon.java
------------------------------------------------------------
public class kihon extends java.applet.Applet
{
	public void init()
	{
		int i = 200,ia = 808;  // intは整数を入れる変数。
		System.out.println( i );  //表示します
		System.out.println( i + ia );// 足し算の結果を表示します

		short s = -8008;// intが32ビットに対して、shortは16ビット。
		System.out.println( s );

		long l = 9096060680808080808L;// longはこんな大きな数も入る
		System.out.println( l );

		byte y = (byte)808;// 限界を越えた値を入れるとどうなるのでしょう？
		System.out.println( y );

		char b = 'a';// char は1文字を入れる変数。このようにして使います。
		System.out.println( b );

		boolean t = false;// boolean型は、trueとfalseの2種類しか値がありません
		System.out.println( t );

		double d = 3.1415926;// doubleは実数を入れる変数。
		System.out.println( d );

		float f = (float)1.41421356;// floatは、doubleの精度が低いものです。
		System.out.println( f );
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=kihon.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.6-1 <DONE>   動作結果(kihon.java)

--------
$ 
$ appletviewer test.html
200
1008
-8008
9096060680808080808
40
a
false
3.14159
1.41421

--------

		  数値を直接プログラムに書く場合は、数値の後ろに、floatにしたい場合は
		  F,longにしたい場合はLを指定します。何も指定しない場合は、
		  整数ならintに、小数ならdoubleに指定したことになります。例で

		  long l = 9096060680808080808L;
		  としているところは、後ろにLという記号が必要です。
		  9096060680808080808という値はintの範囲を越えているからです。
		  
		  それから、
		  byte y = (byte)808;
		  や
		  float f = (float)1.41421356;
		  の行のように、型を変換することができます。それには、変換したい数値の
          左側に、(byte)とか(float)とか(char)というように、型を括弧でくくって
		  表現します。この例では、808と直接書いたものは自動的にintになるので、
		  byte型の変数であるyに代入するには、まずbyte型にしてやる必要がある
		  ため、変換しています。また1.41421356と直接プログラムに書いた場合は、
		  自動的にdoubleとして扱われるため、float型の変数fに代入するために、
		  (float)を使って、float型に変換しています。
          このように変数の型を変換することを、「キャストする」と言います。
		  「キャスト」は、次に説明する参照型でも使えます。

          基本型に加えて、「参照型」と呼ばれる変数があります。参照型は
          基本型 とちがって無数に種類があり、また自分でも作ることができま
          す。その中でもSunが 提供しているものは、クラスライブラリのマニュア
          ルに全部載っています。参照型の 名前は大文字で始まっているので、基
          本型と見分けがつきます。ここで学んでほしい 参照型は次のString型で
          す。String型は、文字列を 記憶しておくための型です。例を示します。


File name: str.java
------------------------------------------------------------
public class str extends java.applet.Applet
{
    public void init()
	{
		String hoge="I am a";	//こうやって文字列を入れる
		String hoge2 = hoge + "boy";    //足し算すると、つながります。
		System.out.println(hoge2+".");	// どんどんつなげる。
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=str.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.6-2 <DONE>    動作結果(str.java)

---------		  
$
$ appletviewer test.html
I am aboy.
$ 
---------		  

          プログラム中で文字列を扱うときは「"」で囲むことと、足し算ができる
          ことが、 大きな特徴です。いろいろ試してみてください。
		 


       4.1.7 配列変数

		Javaでは、同じ型の変数を並べて管理することができます。それには次の
          ようにします。 まずは、基本型の配列の例です。プログラムの中の説明
		  を見てください。


File name: hairetu1.java
------------------------------------------------------------
public class hairetu1 extends java.applet.Applet
{
    public void init()
    {
    	// 基本型の場合
		
		// とりあえず10個分の領域を確保します。
		int ia[] = new int[10]; 
		//最初に値を入れておくことができます。
		int ib[] = { 111, 2, 3, 4, 5, 6, 7, 8, 999 };
		// [] の中の数字を、「添字(そえじ)」と言います。
		System.out.println( ib[0] );    
		System.out.println( ib[8] );

		// 以下のように、2次元(表、行列)にもできます。
		char  ic[][] = new char[100][200]; 
		short id[][] = {
			{ 606, 707, 808, 909 } ,  // 2次元の初期化はこのようにします。
			{ 123, 234, 345, 456 } ,  // 2次元以上、いくらでもできます。
			{ 0, 1, 2, 3 }
		};
		System.out.println( id[2][2] );
		
		// 次の行は実行させるとエラー。そんな番号の要素はない。
		System.out.println( id[5][6] );    //コメントアウト

		// booleanは、2種類の値しかない。
		boolean ba[] = { true , false , true , true };  
		// 配列のサイズを得るには次のようにします。
		System.out.println( ba.length );   
   }
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=hairetu1.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.7-1<DONE>        動作結果(hairetu1.java)

----------
$
$ appletviewer test.html
111
999
2
java.lang.ArrayIndexOutOfBoundsException: 5
        at hairetu1.init(hairetu1.java:25)
        at sun.applet.AppletPanel.run(AppletPanel.java:251)
        at java.lang.Thread.run(Thread.java)
----------		
		System.out.println( id[5][6] );   の行をコメントアウトして、
		実行させてみてください。


#図4.1.7-2<NOT YET>         配列ibの状況(hairetu1.java)

#図4.1.7-3<NOT YET> 		  配列icの構造(hairetu1.java)
		  

          ここでnewというキーワードの使いかたに注意してください。new は、
          「メモリー上に、データを管理するための場所を確保するよー」という意
          味です。 配列も変数なので、最初に宣言する必要があります。宣言の時
          には、どれだけの要素を持つ 配列にするのかを、「要素数」で指定しま
          す。使う時には、「何番目の要素か」を、0から 始まる値で指定します。
          参照型の配列を使うときには、最初は少し戸惑うことがあるかもしれませ
          ん。まずは例を 見てください。


File name: hairetu2.java
------------------------------------------------------------
public class hairetu2 extends java.applet.Applet
{
    public void init()
    {

		//文字列は特別に、次のようにして初期化できます。
		String sb[] = { "this" , "is" , "a" , "test.\n" };
		// 文字列の足し算は基本。
		System.out.println( sb[0] + sb[1] + sb[2] + sb[3] );
		// 文字列の配列。
		String sa[] = new String[4];    
		// nullと表示されます。内容がない、という意味です。
		System.out.println( sa[2] );    
		sa[2] = "Music";// こうやって内容を入れて、
		System.out.println( sa[2] );    // 表示すると....
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=hairetu2.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.7-4 <DONE>         実行結果(hairetu2.java)

------------
$ 
$ appletviewer test.html
thisisatest.

null
Music

------------


       4.1.8 スコープ

          「スコープ」とは、変数の見える(使える)範囲のことです。
			まずは次の例を見てください。


File name:scope.java
------------------------------------------------------------
import java.awt.*;
public class scope extends java.applet.Applet
{
	int i = 20;
	public void init()
	{
    	int j = 20;
    	System.out.println("A:" + i );
	}
	public boolean keyDown(Event e , int c )
	{
     	System.out.println("B:" + i );
     	System.out.println("C:" + j );  // これはコンパイルできない。
		return true;
	}
}

------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=scope.class width=200 height=200></applet>
------------------------------------------------------------

     	System.out.println("C:" + j );  この行をコメントにしてコンパイルして
		実行すると次のような出力を得ます。

#図4.1.8-1 <DONE>        動作結果(scope.java)


--------
$ 
$ appletviewer test.html
A:20
B:20
B:20
B:20
$
--------

          変数は、クラスのフィールド変数と、メソッドの中のローカル変数に分け
          ることができます。 クラスのフィールド変数(この例では20が代入されて
          いるiです)はすべて、 それぞれのメソッドの外(中括弧の外)に書かれて
          います。この変数は、どのメソッドからも 見えます。(すべてのメソッド
          の中で使えるということです。) ところが、それぞれのメソッドの中で宣
          言されているローカル変数 は、他のメソッドの中では使えません。その
          証拠に、上のプログラムをそのままコンパイルすると、 keyDownメソッド
          の中でjを使っているところがコンパイルでき ません。同じように、init
          メソッドの中では、keyDownメソッドの 中で使うことができたeとcは使
          うことができません。
          このように、変数の名前を、それぞれのメソッドの中でしか使えないよう
          にすることによって、 それぞれのメソッドの独立性を高めることがで
          き、名前の衝突も防ぐことができるようになります。
          フィールド変数とローカル変数の名前が同じ場合は、注意が必要です。次
          の例を実行してみて ください。プログラムを見ただけで結果がわかりま
          すか？


File name: scope2.java
------------------------------------------------------------
public class scope2 extends java.applet.Applet
{
	int i = 20;
	public void init()
	{
     	System.out.println( i );
    	int i = 30;
    	System.out.println( i );
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=scope2.class width=200 height=200></applet>
------------------------------------------------------------
#図4.1.8-2 <DONE>	実行結果(scope2.java)

---------
$
$ appletviewer test.html
20
30
$ 
---------

          最初の表示では、まだローカル変数iを宣言していないので、フィールド
          変数が 見えているのですが、2回目の表示では、ローカル変数の宣言の後
          なので、ローカル変数の 内容が見えているのです。ところが、ローカル
          変数を宣言した後はフィールド変数が使えなく なるのでは困ることもあ
          ります。キーワードthisを使えば、ローカル変数を宣言 した後でも、フ
          ィールド変数を使うことができます。先ほどのサンプルプログラムのinit
          メソッドを、次のように変更して実行してみてください。

------------------------------------------------------------
public void init()
{
	System.out.println( i );
    int i = 30;
    System.out.println( i );
    System.out.println( this.i );
}
------------------------------------------------------------

#図4.1.8-3 <DONE>    実行結果(scope2.java(2))


----------
$
$ appletviewer test.html
20
30
20
$ 
----------

          thisというのは、「自分自身」という意味で、自分のフィールド変数だ
          よ、ということを 指定しているのです。


       4.1.9 演算子

          数値ならば、普段使うような四則演算が自由にできます。演算子とは、四
          則演算他の 計算をさせるための記号のことです。次のサンプルを見て、
          大体の感じをつかんでください。


File name: keisan.java
------------------------------------------------------------
public class keisan extends java.applet.Applet
{
	public void init()
	{
		// 後で使う予定の変数は、使う前に宣言しなければなりません。
		// 宣言は、型名 名前[,名前,...];とすることでできます。
		// 宣言していない変数を使おうとすると、コンパイル時にエラーが出ます。
		int ia = 100;
		int ib = 808;
		int ic = -20000;
		int id = 1;
		double da = 100.0; // 代入には、'='を使う。
		double db = 3.0 ;

		System.out.println( ia + ib );  // 足し算
		System.out.println( ia - ib );  // 引き算
		System.out.println( ia * ib );  // かけ算
		System.out.println( ia / ib );  // 割り算(整数)
		System.out.println( da / db );  // 割り算(小数点)
		System.out.println( ib % ia );  // 割り算の余り
		System.out.println( ( ia * ib) + ic );  // 括弧も使える。
		//括弧が多くなっても、数学のような中括弧は使わない。
		System.out.println( ( ( (id+1) *(id+1) + 1) * (id+1)) + 1);

		// 等しいかどうかを判定する。これは代入とは違い、'=='を使う。
		System.out.println(  ia == 100 );
		// 異なっているかどうかを判定する。
		System.out.println(  ia != ib );
		// 大小関係を比較する。
		System.out.println( ia > 808 );
		// 単に否定する。
		System.out.println( !false );

		// 次の行のようにすると、コンパイルできません。なぜでしょうか？
		//int ii = ( 100 > 200);  
		// 右辺がboolean型で、左辺がint型なので、代入できないのです。
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=keisan.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.9-1<DONE>          動作結果(keisan.java)

--------
$   
$ appletviewer test.html
908
-708
80800
0
33.3333
8
60800
11
true
true
false
true
$
--------


          演算子で注意が必要なのは、代入演算子です。数学では、"="という記号
          は、 「両辺が等しい」という意味ですが、Javaでは、"="は、「右辺のも
          のを左辺の変数に 代入する」という意味になりますので、次のようなプ
          ログラムが可能になります。(超重要！)

          a = a + 3;

          この行が実行される時には、まず右辺の計算をしてからその値を左辺に代
          入しますから、 もし変数aの値が最初10だったとしたら、この行を実行し
          終わったあとは aの値は13になっています。「両辺が等しい」かどうかを
          判定するため には、"=="を使います。注意してください。 また、四則演
          算以外に、==,!=,>が出てきましたが これらの演算子は、計算した結果
          int型ではなくboolean 型になります。そのため、表示された文字列は数
          値ではなくtrueまたは falseになっています。 ここで出てきていないも
          のもありますので、巻末のリファレンスも見てください。 演算子の優先
          順位についても記述があります。


      4.1.10 プログラムの流れを制御する(フロー制御)
	  
          いくつか前の節で、「特に指定しなければプログラムは上から下へ実行さ
          れていく」と説明 しました。ここでは、「特に指定する」方法を説明し
          ます。プログラムは物事を繰りかえして 処理したりすることが多いた
          め、上から下へと実行されていくだけでなく、戻ったり飛ばしたり いろ
          いろに流れを制御するためのやりかたがあります。全種類を網羅する説明
          はリファレンス に任せて、ここでは、whileとifとbreak を説明します。
          次のサンプルプログラムを見てください。


File name: flow.java
------------------------------------------------------------
public class flow extends java.applet.Applet
{
	public void init()
	{
		int i = 0;
		while(true ){
			i ++;					// iに1を加える ....(A)
			if( i > 10 ){
				break;  			// iが10より大きくなったら抜ける。
  			}
			System.out.println( i );	// ... (B)
		}
		System.out.println("End!");		// ... (C)
	}
}

------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=flow.class width=200 height=200></applet>
------------------------------------------------------------
#図4.1.10-1<DONE>        動作結果(flow.java)

----------
$   
$ appletviewer test.html
1
2
3
4
5
6
7
8
9
10
End!
$ 
----------

#図4.1.10-2<NOT YET>          このプログラムのフローチャート


          ここでのキーワードは、whileと、ifと、break です。 while( 条件 )
           内容 }と書くことによって、「条件」が成りたって いる間(つまりtrue
          の間)、「内容」を実行し続けるというように プログラムは動作します。
          この例の場合は、while(true)というようにtrue を直接記入しているの
          で、(A)から(B)が永遠に実行されます。(B)が終わると、 また(A)に戻り
          ます。さらに正確に言うと、(A)の前の行に戻ります。このように、 繰り
          かえし同じ処理をさせることを、「ループ(輪)」と言います。while は、
          代表的なループ命令です。他にもいろいろなループ命令がありますが、そ
          れらについて は、リファレンスを参照してください。 ではifはどのよう
          な働きをするのでしょうか？if(英語) を訳すと「もしも」ですが、Java
          においても同じ意味です。

          if(条件){
                  内容A
          } else {
                  内容B
          }

          と書くと、「もしも、条件がtrueならば、内容Aを、そうでないならば 内
          容Bを実行せよ」ということになります。else以下の部分は省略する こと
          ができます。

          if(条件){
                  内容
          }

          このようにできるわけです。
          最後に、breakについてですが、これは、「ループから出る」 という意味
          です。この場合は、(C)へ飛びます。 以上の3つの命令が組みあわさるこ
          とで、「1から10までの数字を表示する」という ことを実現しています。

          (発展)
          巻末のリファレンスのループ命令に、forがあります。これを使うと、 同
          じことがもっと簡単に実現できます。やってみてください。


      4.1.11 条件(boolean)

          前の節で、「流れを制御する」ということについて説明しましたが、そこ
          で重要なのが、 「条件によって」というところです。Javaでは、条件と
          は、true(真)と false(偽)の2種類で表します。「どちらでもない」とい
          う状況は 存在しません。whileも、ifも、trueか falseか、ということに
          よって処理を分岐させるのです。
          条件は、次の演算子を使って計算することができます。(大学の論理学の
          授業で 習った方も多いかもしれませんね！)これらの演算子は、「論理演
          算子」と呼ばれて います。この演算子の振るまいの表を「真偽値表」と
          言い、それは巻末の リファレンスにあります。

#表4.1.11 <DONE>        論理演算子とその読みかたの表

------------------------------------------------
           記法       名前   読みかた(日本語)

             &&     論理積   アンド(かつ)
             ||     論理和   オア(または)
              !       否定   ノット(〜でない)
------------------------------------------------


          サンプルプログラムを見て、そして改造し、どのような動作を するの
          か、確認してみてください。


File name: bool.java
------------------------------------------------------------
public class bool extends java.applet.Applet
{
	public void init()
	{
		System.out.println( true && true );
		System.out.println( true && false );
		System.out.println( true || false );
		System.out.println( false || false );

		boolean b = true;
		System.out.println(!b );
		System.out.println( true && (false || true) );
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=bool.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.11 <DONE>        動作結果(bool.java)

----------
$ appletviewer test.html
true
false
true
false
false
true
$ 
----------


      4.1.12 ビット演算

          ビットとは、コンピューターにおいて最も基本的な情報の単位です。0か1
          かという、デジタル処理の基本 です。このビットを扱う演算が、ビット
          演算です。ビット演算を理解するには、コンピュータの中で数値が どの
          ように扱われているかを知らなければなりません。
          int型の場合、Javaでは、基本型の節でも触れていたように、32ビットの
          幅があります。 int型の変数を一つ記憶しておくためには、32個のビット
          が必要だ、ということです。 int型の変数は、メモリ上に次のように格納
          されています。

#図4.1.12-1 <NOT YET>      8個の箱のセットが4個まとまって32個


          それぞれの箱がビットです。全部0なら、32個まとめたint型としての値も
          0、というように 約束してあるわけです。
          数値をこのように見る場合、2進数が便利です。2進数は、足して2になっ
          たら左の桁が1繰り上がります。 次の表を見てください。

#表4.1.12-1<DONE>	10進数と2進数の対応

--------------------------------------------------------
           10進数     2進数(32bit)

           0          0000 0000 0000 0000 0000 0000 0000 0000
           1          0000 0000 0000 0000 0000 0000 0000 0001
           2          0000 0000 0000 0000 0000 0000 0000 0010
           3          0000 0000 0000 0000 0000 0000 0000 0011
           4          0000 0000 0000 0000 0000 0000 0000 0100
           ...        ...
           256        0000 0000 0000 0000 0000 0001 0000 0000
           65535      0000 0000 0000 0000 1111 1111 1111 1111
           ...        ...
           2147483647 0111 1111 1111 1111 1111 1111 1111 1111
           -21474836481000 0000 0000 0000 0000 0000 0000 0000
           ...        ...
           -3         1111 1111 1111 1111 1111 1111 1111 1101
           -2         1111 1111 1111 1111 1111 1111 1111 1110
           -1         1111 1111 1111 1111 1111 1111 1111 1111
--------------------------------------------------------

          int型の場合、最上位ビット以外が1の数、つまり2147483647に1を 足す
          と、2147483648になるはずが、-2147483648になると、「約束」が決めら
          れています。 この約束を守って数値を表現することを「2の補数表現」と
          いうのですが、 このことによって、負の数を簡単に扱えます。表の-1に1
          を足してみてください。 あふれてくる左端の33ビット目を無視すれば、
          きれいにすべて0になり、表の一番上の 0と一致することがわかると思い
          ます。

          ビット演算には次のような演算子があります。(論理演算ではないので、
          「または」 とか「かつ」というようには読みません。)

#表4.1.12-2 <DONE>  ビット演算の表

--------------------------------------
           記号  名前             読みかた

           &     積               アンド
           |     和               オア
           >>    右シフト         右シフト
           >>>   符号なし右シフト 右シフト  
           <<    左シフト         左シフト
--------------------------------------

          "&"と"|"の計算の方法は、それぞれの数値の各ビットを、1なら真(true
          )、 0なら偽(false)と見なして、別々に論理演算するだけです。また、シ
          フト計算は、 それぞれのビットを実際にずらすだけです。その時に、右
          シフトの場合は左端に、左端にもともと あったビットと同じビットが挿
          入されます。例えば右に1ビットシフトすれば

          0100 1101(10進数で141) -> 0010 0110(10進数で70)

          1110 0011(10進数で-29) -> 1111 0001(10進数で-15)

	      このようになります。ちょうど、数値でいうと、どちらの場合も、
		  2で割ったようになっています。このことから、">>"演算子は、割り算と
		  しても使いうことができることがわかります。しかし、符号なし右シフト
	  	  ">>>"の場合は、
	  	  
		  1110 0011(10進数で-29) -> 0111 0001(10進数で113)
	
		  となります。割り算には使えません。この演算子は、数値を数値として
		  ではなく、ビット列として扱いたいような場合にしか使いません。

          右シフトには、符号つきと符号なしの2種類がありますが、
	      左シフトの場合は、右端には常に0が挿入されます。 次のサンプルプログ
          ラムは、ビット演算の様々な例です。右シフトや左シフトは、割り算やか
          け算の効果があることがわかると思います。 


File name: bit.java
------------------------------------------------------------
import java.awt.*;
public class bit extends java.applet.Applet
{
	public void init()
	{

		System.out.println( 1024 | 500 );
		System.out.println( 1024 & 500 );
		System.out.println( (-1) & 500 );
		System.out.println( 430 << 4 );
		System.out.println(  100 >> 1 );
		System.out.println(  -200 >> 1 );
		System.out.println(  -200 >>> 1 ); // これは何でしょう？
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=bit.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.12-2 <DONE>  実行結果(bit.java)

---------
$
$ appletviewer test.html
1524
0
500
6880
50
-100
2147483548
$ 
---------


      4.1.13 自分で新しい参照型(クラス)を作る


          プログラムを進めていくには、自分でデータ構造をデザインすることが必
          要になってきます。 ここでは、自分だけのクラスを作ります。
		  新しくクラスを作るには、一から自分で作る方法と、他のクラスに少し
		  手を加えて変えたものを作る方法の2つがあります。

		  * 一から自分で作る
		  
          クラスには、情報を格納しておくための「メンバー変数」と、その情報を
          処理するための 「メソッド」が含まれます。一から作るのですから、
		  それらの名前も全部自分でつけてやる必要があります。
		  一から新しいクラスを作るには、以下の手順を踏みます。
		
		  1) 定義の最初の行と、ブロックを書きます。
          class 名前
	 	  {
			これから書く部分
		  }

		  2) 初期化の時に必要な処理があれば、コンストラクタ(名前と同じ名前の
		  メソッド)を定義します。このメソッドは、クラスがnewされる時に
	      自動的に呼びだされ、引数も自由に取れます。

		  3) 新しく作るクラスに含まれる変数やメソッドを定義します。


		  例として、一匹分の敵キャラクターをあらわすクラスを作ってみましょう。
		  次に示すプログラムは、一匹の敵キャラクターですが、アプレットではない
  	 	  ので、コンパイルはできますがこれ自体では動作しません。
		

File name: enemyClass.java
------------------------------------------------------------
class enemyClass 
{
	int x,y;
	int dx,dy;
	int xsiz,ysiz;
	int score;
	int hp;

	// コンストラクタ
	enemyClass(int x , int y ,int xsiz , int ysiz ,int hp,int score){
		// とにかく初期化をする
		this.x = x;            
		this.y = y;
		this.xsiz = xsiz;
		this.ysiz = ysiz;
		this.dx = 0;
		this.dy = 0;
		this.hp = hp;
	}

	// クラスのメソッド
	public void moveOnce()
	{
		x += dx;
		y += dy;
	}

}
------------------------------------------------------------
		
		ここでは、シューティングゲームに出てくる敵を想定しています。敵には、
	    位置(x,y)や、移動量ベクトル(dx,dy)や、体力(hp)といった
		さまざまな情報が関連していますから、それぞれを記憶しておくために、
		クラス内の変数として宣言します。enemyClass(...)は
		このクラスのコンストラクタで、最初に初期値を代入します。
		メソッドmoveOnce()は、このキャラクタが移動する時に呼びだされます。

		* 他のクラスを手直しして新しいクラスを作る
		
		enemyClassクラスは、それだけではほとんど使いものになりません。
		やはり敵であるからには、主人公に対して攻撃してきたり、そういうことを
		させたいものです。どの敵も、enemyClassに含まれているような
		情報を持っていることは確実ですから、全ての敵に共通な部分を
		enemyClassで持ち、共通でない部分をenemyClassに加えるようにすれば、
		プログラムはぐっとすっきりします。次に、enemyClassに新しい特徴をつけ
		加えて、新しいクラスを作る例を示します。



File name: missile.java
------------------------------------------------------------
import java.awt.*;

class missile extends enemyClass    // このextendsが重要。
{
	missile(int x , int y)
	{
		super( x,y,10,30, 5,10 );
		dx = 0;
		dy = 5;
	}
	public void drawThis(Graphics g)
	{
		g.fillRect( x,y,xsiz,ysiz );
	}
}
------------------------------------------------------------

		missileクラスは、enemyClassをextends(拡張)することによって、より
		具体的な機能を果たすようになっているのです。この場合のenemyClassを
		「スーパークラス」、missileクラスを「サブクラス」と呼びます。
		「ミサイル」は、「敵」よりも具体的なので、より具体的にするような
		情報を、missile.javaに書けばよいことになります。共通な部分は
		enemyClassに「くくり出されている」と言うこともあります。
		dx,dyやscoreといった変数や、moveOnceといったメソッドは、
		すでにenemyClassで定義されている(くくりだされている)ので、
		missile.javaの中で新しく定義してやる必要はありません。しかし
		新しく定義することもできます。その場合は、enemyClassで定義されている
		ものと置きかえられます。
		  また、他にも敵がいるのであれば、その敵ごとにenemyClassをextendsして、
		共通でない部分だけを新しくプログラムすればよいのです。

		(参考)いつもAppletをextendsしていますね。これは、すべてのアプレットに
		共通な部分をぬきだしたAppletというクラスがSunによって提供されていて、
		それと共通でない変数やメソッドを新しく定義することによって、それぞれの
		アプレットの機能を実現するようになっているのです。
		
		では最後に、マウスを押すごとに進むミサイル(ただの四角い箱ですが)を
		実現したアプレットのプログラムを示します。


File name: missilemove.java
------------------------------------------------------------
import java.awt.*;

public class missilemove extends java.applet.Applet
{
	missile mis = new missile( 50,50);

	public boolean mouseDown( Event e , int x , int y ){
		mis.moveOnce();
		repaint();
		return true;
	}
	public void paint(Graphics g ){
		mis.drawThis( g );
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=missilemove.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.13-1 <DONE>	動作結果(missilemove.java)


		(注意)
          クラスの配列を作るときは、注意しましょう。
		  基本型の配列は、 int ia[] = new int[20];とするだけで配列の領域が
	 	  確保されますが、クラスの場合は、
		  まずMyClass mc[] = new MyClass[10];のように、10個の要素
          を持つ 配列を作っただけではメモリ上に領域は確保されません。
		  コンストラクタも呼ばれません。ですから、
          使う前に、次のようにする必要があります。実際には次
          のようにします。


File name: hairetu3.java
------------------------------------------------------------
public class hairetu3 extends java.applet.Applet
{
	public void init()
	{
		MyClass mca[] = new MyClass[3];
		mca[0] = new MyClass(); // 1つづつコンストラクタを呼ぶ
		mca[1] = new MyClass();
		mca[2] = new MyClass();
		// forループ命令を使うのもよい考えです。以下は上と同じ意味です。
		for(int i = 0 ; i < 3 ; i++ ){
			mca[i] = new MyClass();
		}
	}
}
class MyClass     // 中身がないけど、クラス。
{
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=hairetu3.class width=200 height=200></applet>
------------------------------------------------------------
		この例は、特に出力はありません。



      4.1.14 アプレットの一生


          アプレットが起動されてから、どのような順番でそれぞれのメソッドが
          呼びだされるのかは、決まっています。アプレットがロードされてから、
          それぞれのメソッド がどのように呼びだされるのかを、次のサンプルプ
          ログラムを実行して、確認してください。 その際に、メニューバーから
          Reloadを選択したり、ウインドウを画面外に出してみたり、いろいろ 実
          験してみてください。もし可能ならば、JDKのappletviewerではなく、
          Netscapeなどのブラウザーでも実行してみてください。ブラウザー上で実
          行する場合は、 Backなどの他のページに移動する時に注目してみてくだ
          さい。(注意！ブラウザーでは、 標準出力は、Show Java Consoleなどの
          メニューから特別に選ばないと表示されません。) 


File name: life.java
------------------------------------------------------------
import java.awt.*;
public class life extends java.applet.Applet
{
	public void init()
	{
    	System.out.println("init");
	}
	public void start()
	{
    	System.out.println("start");
	}
	public void paint(Graphics g )
	{
    	System.out.println("paint");
	}
	public void stop()
	{
    	System.out.println("stop");
	}
	public void destroy()
	{
    	System.out.println("destroy");
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=life.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.14 <DONE>	実行結果(life.java)

---------
$ appletviewer test.html    <- 起動
init
start     
paint
stop            <-ここでメニューからReloadを選択
destroy
init
start
paint
stop			<-ここでメニューからCloseを選択
destroy
$ 
---------
          実行結果は、どのようになりましたか？まずinitが呼ばれ、次にstart
          で、それからpaintやその他のメソッドの順ですね。ブラウザーでページ
          を 移ると、stopが呼ばれたはずです。また、appletviewerでReloadした
          時は、 destroyメソッドが呼びだされます。
          ゲームのプログラムにおいては、initメソッドまたはstart メソッドの中
          で、最初に必要な画像を読みこむなどの処理をするようにします。 ま
          た、ページを移ったときのために、stopメソッドの中では、ゲームの 実
          行を止めるような処理を書いておきます。


      4.1.15 スレッド
	
		これまでのサンプルプログラムは、すべて、マウスを押した時や、
		キーボードを押した時に反応して、何かの処理をするという風になってい
		ます。しかし、それでは、プレイヤーが何も操作しなくても動くキャラクター
		を実現できません。
		スレッドを使うと、何かの出来事(イベント)に反応するばかりでなく、放って
		おいても動くプログラムを作ることができます。その典型的な例を次に
		示します。


File name: thread.java
--------------------------------------------------
import java.awt.*;

public class thread extends java.applet.Applet implements Runnable   
{
	Thread th;				// Thread型の変数を宣言

	public void init()
	{
		th = new Thread( this);	// スレッドをスタートする
		th.start();
	}
	public void paint(Graphics g)
	{
		// 数字を文字に変換するには、Integerクラスを使います。
		g.drawString( Integer.toString( i ) , 100 , 100 );
	}

	public boolean mouseDown( Event e , int x , int y )
	{
		// ....... マウスを押した時の処理も普通に書いておける。
		return true;
	}

	int i=0;
	public void run() // このメソッドが必要。
	{
		while(true){       // ずっと続ける場合は、ループさせる必要があります。
			i++;
			try{			// この3行が重要です。
				Thread.sleep(100 );
			}catch( InterruptedException e) {}
			repaint();
		}
	}
}
--------------------------------------------------

File name: test.html
--------------------------------------------------
<applet code=thread.class width=200 height=200></applet>
--------------------------------------------------

#図4.1.15-1 <DONE> 	動作結果(thread.java)


		このようにすれば、ボタンを押したりマウスを動かしたりしなくても、
		数字が連続的に表示されているのがわかります。もちろん、マウスを
		押した時の処理は、いつもと同じように書いておけばOKです。スレッドを使う
		ために必要なプログラムは、

		1) アプレットクラスの宣言時に、 implements Runnable 
		を末尾につけたします。

		2) アプレットのフィールド変数に、 Thread型の変数を宣言します。この例で
		は、変数thがそれです。
	
		3) 初期化メソッド public void init() の中で、例で示しているように
		Thread型の変数を初期化してstart() メソッドを呼びだします。

		4) public void run() メソッドを定義します。その中で継続的な処理をしたい
		場合は、while()などを使ってループを作ります。
		
		5) 繰りかえしの速度を指定するために、

		try{
			Thread.sleep( ミリ秒(long) );
		}catch( InterruptedException e ){}
		
		の3行を加えます。「ミリ秒」に指定した時間、Thread.sleep()は止まって
		います。例では100を指定しているので、0.1秒ごとにループが一回転すること
		になります。ゲームでは、内容によりますが、だいたい50から80を指定する
		とよいでしょう。try{ や、 catch( InterruptedException e){} については、
		次の節で扱います。

		6) 継続的に行ないたい処理を、public void run()メソッドの中の
		ループに書けば、その処理は、イベントなしでも動き続けます。
		
		敵を動かす処理などは、スレッドを使って処理したい代表的な事柄ですね。


		スレッドに関しては、以上のことが理解できていれば、ゲームを作ることがで
		きるのですが、もっと知りたいという人もいるでしょうから、もうすこし踏み
		こんで解説します。とりあえず進みたい、という人は、飛ばしてしまって
		結構です。
		
		Javaはマルチスレッドのシステムです。マルチスレッドとは、文字通り
		スレッドがたくさんある、という意味です。Javaでは、先ほどのThread
		オブジェクトを複数作ることで、多くのスレッドが同時に動き続ける、という
		ことを実現することができます。次の例では、複数のスレッド(10個)
		が同時に動作し、別々に数をカウントしていきます。


File name: multi.java 
------------------------------------------------------------
import java.awt.*;

class counter implements Runnable
{
	Thread t;
	int val=0;
	long milisec;
	counter(int i)
	{
		t = new Thread( this );
		t.start();
		milisec = i;
	}
	public void run()
	{
		while(true)
		{
			val++;
			try{
				Thread.sleep( milisec );
			}catch( InterruptedException e ){}
		}
	}
	public int getVal(){ 
		return val;
	}
}
public class multi extends java.applet.Applet
{
	counter ca[] = new counter[10];

	public void init()
	{
		for(int i=0;i<10;i++){
			ca[i] = new counter(i*100+100);
		}
	}
	public void paint(Graphics g)
	{
		for( int i=0;i < 10 ;i++ ){
			g.drawString( "counter " + i + ":" + ca[i].getVal() ,
						 20 , 20 + i*20  );
		}
		try{      
			Thread.sleep(50);    // ここで50ミリ秒待つ。
		}catch( InterruptedException e ){}

		repaint();  // 描画が終わったらもういちど描画するための手抜きコード。
					// これで、連続的に描画されることになります。
			
	}
	public boolean mouseDown( Event e , int x , int y)
	{
		repaint();
		return true;
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=multi.class width=200 height=300></applet>
------------------------------------------------------------

#図4.1.15-2 <DONE>	実行結果(multi.java)

	
	新しいスレッドは、Runnableインターフェースをimplementsしていて、
	public void run()メソッドを実装しているようなクラスを、
	Threadクラスのコンストラクタの引数にして呼びだすだけで作ること
	ができます。そうして得られたThreadクラスのインスタンスに対して
	start()メソッドを呼びだせば、そのスレッドの実行が始まります。
	この例では、前の例(thread.java)とは異なり、アプレット自身は
	Runnableをimplementsしていません。そのかわりに、counterというクラ
	スがRunnableをImplementsしてpublic void run()を定義しています。
	アプレットは、init()メソッドの中でcounterクラスを初期化して、
	paint()の中でそれぞれの値を読みだしているだけです。
	
	counterクラスのコンストラクタを呼びだすと、まずスレッドが初期化されて
	実行が始まります。そして、それぞれのスレッドは、Thread.sleep(long)
	が呼びだされると、他のスレッドに交代します。スレッドは同時に実行さ
	れると言っても、実際にはCPUは一つしかないのですから、非常に細切れ
	に時間を区切って、交代で実行しているのです。(第1章、3節を参照)
	
#図4.1.15-3 <NOT YET>	10個のスレッドが順番に実行される


	Javaでは、スレッドの交代の順番をいろいろ変えたり、グループ別に管理したり、
	いろいろ凝ったことができるようになっています。この例では、スレッドによって
	Thread.sleep(long)に与えている待ち時間が異なるので、実際には図よりもやや
	こしい順番で実行されています。

	スレッドが順ぐりに実行されていくことは理解できたと思いますが、順番を回す
	という点に関して注意することが必要です。それは、
	Thread.sleep(long)やThread.yield()など、スレッドの実行を他に
	譲るような命令を使ってやらない限り、他のスレッドは実行する順番が回って
	こないということです。試しに、multi.javaのcounterクラスにある
	Thread.sleep(milisec)を含む3行を削除してみてください。画面には何も表示
	されません。appletviewerの操作もできないようになります。
	しかし、数字が進んでいかないだけならわかりますが、なぜ、appletviewer
	の操作もできないようになってしまうのでしょうか？
	
	* appletviewerのメカニズム

	実は、appletviewerは、javaのひとつのクラスです。コマンドラインから
	appletviwer test.html
	と入力することは、
	java sun.applet.AppletViewer test.html
	と入力することと同じなのです。sun.applet.AppletViewerというクラス
	は、JDK1.0.2の場合は、JDKのディレクトリの中の classes/sun/applet/に、
	JDK1.1の場合は、JDKのディレクトリの中の lib/classes.zipという圧縮ファイル
	の中に埋めこまれています。

	sun.applet.AppletViewerの中では、まず、test.htmlの中に書かれている
	クラスを読みこんでウインドウを出します。そして、
	マウスの状況を調べたり、キーボードの状況を調べたりするループを実行する
	一つのスレッドが起動されます。そして、そのスレッドの中から、イベントの発生
	に応じて、あなたの作ったクラスで定義されているinitや、start,keyDown,
	paint,その他のメソッドが呼びだされるのです。appletviewerの操作メニュー
	なども、このスレッドで処理されます。つまり、あなたが意識していない
	間に、スレッドが一つ、作成されていたことになります。
	ところが、あなたの定義している、例えばmouseDownというメソッドの中に、
	
	while(true){
		// 何もしない
	}
		
	というような、他のスレッドに実行の順番を回さないようなプログラムが書かれ
	ていれば、どうなるでしょうか？ そう、今まであったappletviewerのための
	スレッドが、順番を待ったままになってしまうのです。そして、メニューなどの
	描画も行われないようになってしまうのです。
	ですから、mouseDownや、paintや、その他全ての場所において、長い間終わらない
	処理を、Thread.sleep(long)なしで実行するのは、やめましょう。
	例えば、ある大きな画像を処理するために、長い時間がかかりそうであれば、
	時々Thread.sleepしてやるほうがよいでしょう。

	Javaのマルチスレッド機能は、Javaが非常に便利である大きな理由になってい
	ます。
	ユーザが快適に使えるアプリケーションを、簡単に作ることができるのです。
	ゲーム・プログラミングでは、それほどたくさんのスレッドが必要なわけではあり
	ませんが、スレッドの知識は、きっと将来のプログラミングにおいて役にたつ
	でしょう。
		


      4.1.16 例外処理

	プログラムの実行中に、異常な状態が発生することがあります。異常な状態
	の代表選手は、次の例で示すようなものです。まず実行してみてください。


File name: exception.java
------------------------------------------------------------
public class exception extends java.applet.Applet
{

	int array[] = new int[5];    // 10個の要素を持つ配列

	public void init()
	{
		for(int i=0;i<10;i++){
			System.out.println("loop");
			array[i] = 500;
		}
		System.out.println("end.");
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=exception.class width=200 height=200></applet>
------------------------------------------------------------

#図4.1.16-1 <DONE>	動作結果(exception.java)


	実行させると、標準出力に、次のようなメッセージが出たはずです。

------------------
loop
loop
loop
loop
loop
loop
java.lang.ArrayIndexOutOfBoundsException: 5
        at exception.init(exception.java:12)
        at sun.applet.AppletPanel.run(AppletPanel.java:251)
        at java.lang.Thread.run(Thread.java)
------------------

	これは、「配列の100番目の要素をアクセスしようとしたが、それは範囲外
	だぞ。」という意味です。int型の配列arrayは、 5個の要素を持っていて、
	その番号は0から始まるので、4番目までしかないからです。これは明らかに
	プログラムにとっては例外的で、これ以上実行を続けるには致命的な状態
	なので、スレッドはここで止まってしまいます。"end."という文字列は表示
	されなかったはずです。(appletviewerのスレッドは止まらないので、appletviewer
	の操作はできますね。スレッドについては、前節の後半を参照)
	このような状況を、「例外」と呼びます。英語では、
	"exception"と言います。この例の例外の名前は、Javaでは、
	ArrayIndexOutOfBoundsException
	と呼びます。直訳すると 「配列番号範囲外例外」といった感じです。

	プログラムのミスや、その他の原因で、このような状況が起こることは、
	よくあることです。Javaでは、この問題に安全に取りくむことができます。
	上のプログラムは、次のように改造すれば、例外によって止まることを回避
	できます。


File name: trycatch.java
------------------------------------------------------------
public class trycatch extends java.applet.Applet
{

	int array[] = new int[5];    // 10個の要素を持つ配列

	public void init()
	{
		for(int i=0;i<10;i++){
			System.out.println("loop");
			try{        		// try節始まり
				array[i] = 500;
				System.out.println("it is ok");
			}catch( ArrayIndexOutOfBoundsException e ){  // catch節始まり
				System.out.println( "exception");
			}
		}
		System.out.println("end.");
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=trycatch.java width=200 height=200></applet>
------------------------------------------------------------

#図4.1.16-2 <DONE>	実行結果(trycatch.java)

--------------
loop
it is ok
loop
it is ok
loop
it is ok
loop
it is ok
loop
it is ok
loop
exception
loop
exception
loop
exception
loop
exception
loop
exception
end.
--------------

		異常な状態が発生するかもしれない場所を、

		try{
			異常な状態を発生するかもしれないコード
		} catch( 発生するかもしれない例外  その名前 ){
		}
		というようにして囲めば、例外が発生した時点で、catch節の中に飛びます。
		そして、try節 の中の残りの部分は飛ばされます。この例では
		"it is ok"を表示する部分が飛ばされていますね。そして、catch節の
		実行が終われば、何事もなかったかのように実行が続きます。
		まず目にするtry〜catchの使いかたは、スレッドの所で出てきた

		try{
			Thread.sleep(100);
		}catch( InterruptedException e ){}

		といった使いかただろうと思います。とりあえずはこの使いかただけで
		十分ですが、try 〜 catch を積極的に使っていくと、プログラムの構造を
		かなりシンプルにすることができます。そのあたりのコツは、
		以降のプログラム例を参考にして学んでいってください。



	  4.1.17 JDK1.1以降のイベント処理
	
	  この節は、始めは飛ばしてしまって構いません。ひととおりアプレットの
	  プログラムができるようになってから、読んでみてください。


	    JDK1.1になって、これまで扱ってきたようなmouseDown,keyDownといった
	  イベント処理が、かなり変更されました。旧来のプログラムも動作するように、	
	  mouseDownやkeyDownのようなメソッドも残されていますが、できるだけ、
	  新しい方のやりかたをするように、と指示されています。本書では、

	  o まだJDK1.1が利用できないユーザも多い
	  o JDK1.1ではどちらのコードも動く
	  o プログラムが多少複雑になる
	  o WWW上に存在するアプレットの多くが、いまだに旧式のプログラムである。

	  以上の4つの理由により、旧来の方法で説明していますが、
	  新しい方のプログラムに書きかえる方法
	  をここで解説しておきます。ひととおり「旧式の」プログラムが理解できたら、
	  自分が作ったプログラムを新しい方法を使うように変更してみてください。
	  そのシステムの違いがよく理解できることと思います。

	  まず最初に、同じ動作をする二つのアプレットの例を並べて示します。
	  このプログラムは、JDK1.1では、両方とも正しく動作します。meventNew.java
	  の方は、JDK1.0.2では、コンパイルも実行もできません。


File name: meventOld.java
---------------------------------------------------------	
import java.awt.*;

public class meventOld extends java.applet.Applet
{
    public boolean mouseDown( Event e , int x , int y)
    {
        getGraphics().drawOval( x,y,20,20 );
        return true;
    }
    public boolean mouseUp( Event e , int x , int y )
    {
        getGraphics().drawRect( x,y,20,20);
        return true;
    }
}
---------------------------------------------------------	

File name: test.html
---------------------------------------------------------	
<applet code=meventOld.class width=200 height=200></applet>
---------------------------------------------------------	


File name: meventNew.java
---------------------------------------------------------	
import java.awt.*;
import java.awt.event.*;        // (*1)

// (*2)
public class meventNew extends java.applet.Applet implements MouseListener 
{
    public void init()
    {
        addMouseListener( this );  // (*3)
    }
    public void mouseClicked( MouseEvent ev ){  // (*4)
    }
    public void mouseEntered( MouseEvent ev ){  // (*4)
    }
    public void mouseExited( MouseEvent ev ){   // (*4)
    }
    public void mousePressed( MouseEvent ev ){  // (*4)
        getGraphics().drawOval( ev.getX(), ev.getY() ,20,20 ); // (*5)
    }
    public void mouseReleased( MouseEvent ev ){  // (*4)
        getGraphics().drawRect( ev.getX(), ev.getY() ,20,20); // (*5)
    }
}
---------------------------------------------------------	

File name: test.html
---------------------------------------------------------	
<applet code=meventNew.class width=200 height=200></applet>
---------------------------------------------------------	

#図 4.1.17-1 <DONE>  	動作結果(mevent.java)


	  「旧式の」アプレットのプログラムを「新式の」ものに変更する手順を以下に
	  示します。
	
	  1) java.awt.event.* をimportする。 ( *1)
	  2) 必要なイベントに応じたインターフェースをimplementsする。(*2)
	  3) init()メソッドの中で、イベントに応じて、 addMouseListener( this)や
	  addKeyListener(this)を行なう。 (*3)
	  4) そのインターフェースで宣言されているすべてのメソッドを定義する。 (*4)
	  5) それぞれのメソッドの中に処理内容を書く。(*5)

	  以上の手順を踏めば、変更することができます。マウスイベントにもキーボード
  	  イベントにも反応したい、という時には、  

	  1) 同じ
      2) implements KeyListener,MouseListener のように並べる。
	  3) addMouseListener( this );
         addKeyListener( this );
	     という風に複数並べる。
	  4) MouseListenerインターフェースで宣言されている mouse....に加えて、
	     keyPressed , keyReleased,....といった KeyListenerで宣言されている
    	 メソッドをすべて定義します。
	  5) 同じ。


	  のようになります。1.1以降のやりかたでは、不必要なメソッドも定義しなければ
	  ならないので、プログラムが冗長になってしまうということです。しかし、
	  大規模なプログラムを作る場合は、逆に、プログラムは非常に簡略化されます。
	  MouseListenerやKeyListenerの他にも、さまざまな
	  インターフェースが用意されています。JDK1.0.2以前の方法で使って
	  いたイベントと、新しいイベントは、名前も変わっていますから、その対応を
	  調べる必要があります。この例では mouseUpは mouseReleasedに、
	  mouseDownは mousePressedに、変更されています。
	  JDK1.1のHTMLドキュメント(1997年2月現在は英語版しか
	  ありません)に記されている、イベントの対応表を、本書の末尾に付録として
	  掲載しますので、役立ててください。



      4.1.18 まとめ

      Javaの基本事項を、例を示しながら解説しました。ここで示し
      ていないキーワードなどに ついては、巻末のリファレンスを見ながら、
      いろいろプログラムをいじって調査・実験してみてください。 たくさん調査す
      ればするほど、あなたのプログラミングセンスは磨かれていくことでしょ
      う。 以降の節では、基本的な内容は理解しているものとして話を進めま
      すので、わからないことが 出てきたら、必ず戻って確認してください。


  4.2 ゲームプログラムの構造

     ゲームのプログラムは、だいたいどんなゲームでも、骨の部分は似たりよった
     りのもの になります。そこで、本書では、その骨の部分(ソフト開発の時によ
     く使われる用語で、 ずばり「スケルトン」と言います。)をまず提示し、それ
     に対して変更を加えていく という方法を取ります。
     このスケルトンには、ところどころに、「変更可能個所」があります。 この部
     分はみなさんに色々変更してもらい たい場所です。ここの数値を変えたり、前
     節で学んだような文法に従ったプログラムを 新しく加えたりして、いろいろ実
     験してみてください。勉強が進めば、スケルトンの 網かけでないところを変更
     していくことも面白いでしょう。

      Memo: Visual J++等の統合開発環境でも、このようなスケルトンを作成して
      くれますね。そして 「ここプログラムを書いてください」というようになっ
      ています。それと 考えかたは基本的に同じでです。VJ++のは一般的なアプレ
      ット用のものですが、 ここに掲載しているのは、よりゲームに特化したよう
      な構造になっています。


     * ゲームのスケルトンプログラム

File name: game.java
------------------------------------------------------------
import java.awt.*;
import java.awt.image.*;
import java.util.*;
import java.applet.*;

public class game extends java.applet.Applet implements Runnable
{
	Thread thread;
	Image double_buffer;
	Graphics dg;

	int cron=0;
	int width,height; // 単位はピクセル
	int interval = 500 ; // ミリ秒

	public void init()
	{
		width = size().width;
		height = size().height;
		thread = new Thread(this);
		double_buffer = createImage( width , height );
		dg = double_buffer.getGraphics();
		thread.start();
		//変更可能個所
	}

	public void paint( Graphics g )
	{
		g.drawImage( double_buffer , 0 , 0 , null );
	}
	public void update( Graphics g )
	{
		paint( g );
	}
	public void run()
	{
		while( true )
		{
			cron++;

			try{
				Thread.sleep( interval );
			} catch( InterruptedException e ){}

			doIt();
			repaint();
		}
	}
	void doIt()
	{
		// 変更可能個所
		// ここにプログラムを加えていってみましょう。
		dg.drawString( Integer.toString( cron ) , 50 ,cron*10  );
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=game.class width=400 height=400></applet>
------------------------------------------------------------

     まずこのプログラムを、エディタで入力してみましょう。付録のCD-ROMに この
     プログラムも収録されていますが、ここはひとつ、エディタに慣れる ために
     も、手で打ちこんでみてください。ネストする時には、Tabキーを 使うことを
     忘れずに! 打ちこみ終わったら、コンパイルしましょう。コンパイルのやりか
     たは、 それぞれの機種別のところを参照してください。javacまたは、
     JavaCompiler を使います。コンパイルする時にエラーが出たら、それはきっと
     打ち まちがいなので、エラーメッセージを見て、直しましょう。(エラーメッ
     セージ の説明は、この章の「エラーメッセージ」のところを参照してくださ
     い。
     そしていよいよ実行です。実行には、appletviewerを使います。実行の前に
     は、 test.htmlを作っておくことを忘れずに。 test.htmlの内容が間違ってい
     なければ、実行する時には、エラーは出ません。 うまく動きましたか？正しく
     動けば、画面にウィンドウがひとつ現れて、 数字が一つづつ増えていく表示が
     されるはずです。

#図4.2-1<DONE>     動作結果(game.java)


     * 実行させた後の止めかた

     実行している時、ウインドウの左上の方に、Appletと書かれたメニューがあり
     ますから、その中からQuitを選べば止めることができます。

#図4.2-2 <DONE>     メニューからquitを選ぶ


     UNIXやWindowsのDOS窓から使っているときには、appletviewerを起動した ウイ
     ンドウでコントロールキーを押しながらCキーを押せば止まります。

#図4.2-3 <DONE>     Ctrl-Cで止める

     次の節で、このスケルトンプログラムの内容を理解するために必要な事柄を解
     説します。


  4.3 表示の基礎

     ゲームを作っていくのなら、表示は非常に重要な要素なので、コンピューター
     の画面 がどのように構成されているのかについて、基礎的な知識が必要です。
     またこの知識は、使用言語とか機種とかOSとかに関わらず通用する知識です。


       4.3.1 ドット

          コンピューターの画面は、すべて小さなドットの集まりで構成されていま
          す。 それぞれのドットは、番号(座標)で識別することができます。
          数学では、グラフはXは右方向が正、Yは上方向が正でしたが、コンピュー
          ター の画面では、Xは同じでYだけ下方向が正となっています。
          例えば画像処理の プログラムの中では、画面の情報を1ドットづつ見てい
          くことになりますが、 その際には、最も上の段の左端から右端へ調べ、
          次にその一段下の左端から 右端へ、さらにその下の段の.....という順番
          になります。 この順で調べることを、"TopDownLeftRight"と呼びます。
          以降この単語を 使います。グラフィックスメモリにも、この順番で画像
          の情報が格納されている のです。

#図4.3.1-1<NOT YET>          TDLRの図と番号の振りかた


          では、実際に画面に、TopDownLeftRightでドットを打つプログラムを 実
          行させてみましょう。なお、Sunが提供しているJDKの機能には、 「点を
          打つ」という機能がないため、点から同じ点まで、線を引くという こと
          によって点を打っています。なぜdrawPointがないのかは、 残念ながらわ
          かりません。 


File name: tdlr.java
------------------------------------------------------------
import java.awt.*;

public class tdlr extends java.applet.Applet implements Runnable
{
    Thread t;
    public void init(){
        t = new Thread( this );
        t.start();
    }
    public void update(Graphics g ){
        paint(g );
    }
    public void run()
    {
        for(int i=0;i<size().width;i++){
            for(int j=0;j<size().height;j++){
                getGraphics().fillRect( j , i  , 1,1);
                try{
                    Thread.sleep(10);
                }catch( InterruptedException e ){}
                repaint();
            }
        }
    }
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=tdlr.class width=600 height=400></applet>
------------------------------------------------------------

#図4.3.1-2<DONE>       動いている最中のtdlr.class (tdlr.java)

          上から順々に点を打っていくのが見えますね。
          画面に点を打つことができさえすれば、どんな画像も表示することができ
          る はずですね。しかし、多くのマシンでは、そんなことをしていたので
          は 時間がかかってしようがないですから、

          g.fillRect(0,0,size().width,size().height);
	
		  のようにして、領域を一発で塗りつぶす方法も用意されています。


       4.3.2 アニメーション

          ゲームの画面は常に動いているので、一種のアニメーションだと言えま
          す。本書では、 アニメーションという表現を、動く画面という意味で使
          います。
          Javaでアニメーションさせるには、次のようにプログラムします。この例
          では、 黒い四角を動かしてみます。


File name: anime.java
------------------------------------------------------------
import java.awt.*;
public class anime extends java.applet.Applet implements Runnable
{
	Thread t;
	int x = 0;
	public void init()
	{
		t = new Thread(this);
		t.start();
	}
	public void paint( Graphics g ){
		g.fillRect( x , 50,200,200);
	}
	public void run()
	{
		while(true){
			x++;
			try{
				Thread.sleep(100 );
			}catch( InterruptedException e ) {}
			repaint();
		}
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=anime.class width=300 height=300></applet>
------------------------------------------------------------

#図4.3.2-1 <DONE>          動作結果(anime.java)

          tdlr.javaでも出てきましたが、Thread、Thread.sleep、
           implements Runnable、run の4つは、 マルチスレッド機能を使うため
          に必要です。この機能はアニメーションを実現するためには
          必須の機能なのですが、とりあえずここではそういう機能がある という
          ことにしておきます。詳しい説明はコラムを参照してください。 try、
          catch、InterruptedException この3つと、Thread.sleep(数字)を使うこ
          とによって、アプレット の動作する速度を決めることができます。100と
          いう数字を変更することによって、 スピードを調節します。この数字の
          単位はミリ秒で、0.1秒ごとに1ドットづつ移動 していくわけです。sleep
          の意味は、「100ミリ秒だけ、止まってろ」 という意味です。100ミリ秒
          だけ止まって、またrepaintして、を 繰りかえすのです。

          try{
                  Thread.sleep(数値);
          }catch( InterruptedException e ) {}

          という表現はよく使いますので、覚えておいてください。それから、 こ
          こでtryとcatchは、Thread.sleep の実行中に何らかのエラーや例外状態
          が生じたときに対応する処理を書くとき の文法です。当分これ以外の使
          いかたはしないので、ここでは説明を省略します。 また、この数値の調
          整によってゲームの進むスピードを調節することができます が、難しい
          のは、このアプレットを動かすマシンの性能は、すべてがあなたの マシ
          ンと同じではないということです。例えばSGIのindyというマシンで 動か
          したときには、10ミリ秒に設定しても(1秒に100回動く)十分動作します
          が、 Pentiumより前のCPUを積んでいるPC/AT互換機だと、200ミリ秒でも
          苦しいくらい です。調整するには、ゲームの内容も考えて、だいたいど
          のマシンでも動く ような適度な設定にしてください。


       4.3.3 ちらつき防止

          ゲームでは、キャラクターを動かすわけですが、そのときに、ブラウン管
          の 走査の都合上避けて通ることのできない問題が生じます。それがちら
          つき です。前の四角を動かす例でも、動きながらちらちらしていたはず
          です。 ちらつきは、目を疲れさせる原因になるし、正しくキャラクター
          を認識できない 原因にもなります。
          これを解決するには、二つの対策を講じなければなりません。まず、Java
          のApplet において自動的に働く機能の、repaintが呼びだされた時に ア
          プレット全体を灰色で塗りつぶしてしまう機能を殺すことです。次に、実
          際には 画面に表示されない仮想画面を用意して、描画はすべてそれに対
          して行うように するということです。まずは最初の対策を施したサンプ
          ルプログラムを見てください。


File name: NoUpdate.java
------------------------------------------------------------
import java.awt.*;
public class NoUpdate extends java.applet.Applet implements Runnable
{
	Thread t;
	int x = 0;
	public void init()
	{
		t = new Thread( this );
		t.start();
	}
	public void paint( Graphics g )
	{
		g.fillRect( x , 50,200,200);
	}
	public void update( Graphics g )
	{
		// 何も手を加えないと、ここに消去するプログラムが含まれるのです。
		paint( g );
	}
	public void run()
	{
		while(true){
			x++;
			try{
				Thread.sleep(100 );
			}catch( InterruptedException e ) {}
			repaint();
		}
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=NoUpdate.class width=300 height=300></applet>
------------------------------------------------------------

#図4.3.3-1 <DONE>	実行結果(NoUpdate.java)


          実行結果はどうでしたか？消す機能が殺されているので、黒い四角が 伸
          びていくようになりましたね。しかし、これでは、四角を「動かしてい
          る」とは とても言えません。ですから、次に、きれいに動いているよう
		  に見えるようにするための とっておきの技を使います。
          今度は変更部分が多いので注意して読んでください。


File name: OffScr.java
------------------------------------------------------------
import java.awt.*;
public class OffScr extends java.applet.Applet implements Runnable
{
	Thread t;
	int x = 0;
	Image ofscr; // 仮想画面(オフスクリーン、ダブルバッファともいう)
	Graphics ofscr_g;       // 仮想画面を操作するためのGraphics

	public void init()
	{
		t = new Thread( this );
		t.start();
		// 次の行により、仮想画面は、真っ白または真っ黒に初期化されます。
		// 使う前に、必要な色で塗りつぶしてやる必要があります。
		ofscr = createImage( 300,300);  
		ofscr_g = ofscr.getGraphics();
	}
	public void paint( Graphics g )
	{
		ofscr_g.setColor( Color.white);
		ofscr_g.fillRect( 0 , 0 , 300, 300 );   // 全画面を消す。
		ofscr_g.setColor( Color.black );
		ofscr_g.fillRect( x,50,200,200);        // 目的の四角を描画する。
		g.drawImage( ofscr , 0 , 0 , null );
	}
	public void update( Graphics g )
	{
		paint( g );
	}
	public void run()
	{
		while(true){
			x++;
			try{
				Thread.sleep(100 );
			}catch( InterruptedException e ) {}
			repaint();
		}
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=OffScr.class width=300 height=300></applet>
------------------------------------------------------------

#図4.3.3-2 <DONE>          動作結果(OffScr.java)

          initメソッドの中で、まず仮想画面を作ります。そして、全ての 描画
          は、仮想画面に対して行ないます。様々な描画を行なうために、
          getGraphics を使って、Graphicsクラスへの参照を取りだします。以降の
          描画は、 このofscr_gに対して行なうわけです。仮想画面を使わない場
          合、 ブラウン管の描画のタイミング上、消去作業の途中や四角を書いて
          いる途中に ブラウン管が次の走査を始めてしまうことになり、ちらつく
          わけですが、仮想画面を 使うとそれらのタイミングの問題を回避できる
          というわけです。

#図4.3.3-3 <NOT YET>        ブラウン管描画タイミング


          (注意)非常にハマりやすいポイントとして、getGraphicsメソッド を使っ
          てImageクラスの変数からGraphicsを取ること ができるのは、この例で示
          したようにcreateImageした時だけだという ことです。getImageや、
          memoryImageSourceを使って 作りだした画像からは、getGraphicsできま
          せん。実際、API マニュアルには、createImageは、「ダブルバッファリ
          ングのために 使う」というように書かれています。特別に提供されてい
          る機能のようです。 オフスクリーンを使えば、表示を非常に滑らかにす
          ることができるので、 ゲームを作るにはほぼ必須のテクニックと言えま
          す。 以上でスケルトンプログラムの内容はすべて網羅しました。骨がで
          きたので、あとは、 様々な肉をつけていくことになります。肉とは、キ
          ャラクターを移動させたり、 画像を表示したり、音を出したりすること
          を意味しています。


4.4 画面に画像を出すプログラム

     ゲームの中で絵を扱うためには、その絵の情報をどこかから取ってこなくては
     なりません。 そのためには、getImageを使います。次のサンプルは、画像を取
     りだして、 表示します。画像フォーマットは、GIFとJPEGが現在のところ
	標準で使えます。


File name: getimage.java
------------------------------------------------------------
import java.awt.*;
public class getimage extends java.applet.Applet
{
	Image img;
	public void init()
	{
		img = getImage( getDocumentBase() , "kawai.jpg" );
	}
	public void paint(Graphics g )
	{
		g.drawImage( img , 30,30, null );
	}

}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=getimage.class width=300 height=300></applet>
------------------------------------------------------------

#図4.4-1 <DONE>  動作結果(GETIMAGE.JAVA)表示される場合と、されない場合がある


     この例の場合、あなたのディスクの中の、クラスファイルGETIAMGE.CLASS が置
     かれている所と同じディレクトリにあるはずの、KAWAI.JPGという画像 ファイル
     を取りだそうとしています。(このファイルは、付録のCD-ROMに入っています
     ので、コピーしてお使いください)インターネットを通して誰かがこのアプレッ
     トを ダウンロードした時も、同じディレクトリに置かれているファイルがイン
     ターネットを 通して読みこまれます。
     APPLETVIEWERを起動しても画像が出てこない場合と、出てくる場合とがありま
     す。 出てこなかった場合も、APPLETVIEWERのメニューの、RESTARTを 選択する
     と表示されます.この原因については、次の節で説明します。

     画像は、次の図のようなプロセスを経て、表示されます。

#図4.4-2 <NOT YET>    ロード指示、ロード開始、メモリ展開、描画の順


     画像表示で初心者がよくハマるポイントを挙げてみましょう。

        o getImageしても、実際にはロードは始まらない。
        o 初めてdrawImageした時にロードが開始される。
        o 元が圧縮ファイルなので、ロードが完了してから、メモリへの展開に時間
          がかかる。

     この例の場合は、アプレットのクラスファイルがappletviewerに読みこまれた
     直後で、 まだ画像ファイルのロードは終わっていない状態の時に、一回目の
     paint メソッドが呼びだされることが問題です。システムの都合で一回目の
     drawImageが、画像のロードとメモリ展開が終わってから実行された場合は 描
     画され、たまたまロードやメモリ展開が終わっていなかった場合は描画されな
     いのです。 (途中までメモリに展開されている場合は、画像の上から一部分が
     描画されます。) restartすると、画像データが、展開された形でappletviewer
     内のメモリキャッシュに残って いるため、必ず描画されるのです。しかし、こ
     のままでは何かと不便です。プログラムが 自分の管理の元で画像をロードした
     りしたいものです。それを実現するためのクラスが Sunによって提供されてい
     ます。

     * MediaTrackerクラス

     MediaTrackerクラスは、画像や音声を、意図的なタイミングでロードするため
     の クラスです。次のようにして使います。第1章で出てきた、「デマンドロー
     ディング」を実現 するには、MediaTrackerクラスを使います。


File name: mt.java
------------------------------------------------------------
import java.awt.*;
public class mt extends java.applet.Applet
{
	MediaTracker m;      // まずMediaTrackerクラスのインスタンスを作る
	Image img;

	public void init()
	{
		img = getImage( getDocumentBase() , "kawai.jpg"); // ここは同じ
		m = new MediaTracker(this);
		m.addImage( img, 0); // MediaTrackerの仕事リストに加える。
		try{
			m.waitForID(0);      // ロードが終わるまで待つ。(強制ロード)
		}catch( InterruptedException e ){}
	}
	public void paint(Graphics g){
		g.drawImage( img , 0 , 0 , this );
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=mt.class width=300 height=300></applet>
------------------------------------------------------------

#図4.4-3 <DONE>     動作結果(mt.java)

     ある画像のローディングを操作するには、MediaTrackerクラスのインスタンス
     のメソッドである addImage( Image , ID )を使います。IDというのは、
     MediaTracker クラスの仕事のうち、何番の仕事だよ、と指定してあげるので
     す。そうすることによって、 waitForID( ID)を使って番号を指定してロードさ
     せることが可能になるのです。 IDは、同じ番号をいくつでも振ることができる
     ので、いくつかの画像ファイルをグループ 分けして管理することもできます。
     ゲームの場合は、MediaTrackerを使って、 ゲームに必要なキャラクターの画像
     が揃うまで、"Now Loading..."などと表示しておくようにする のがよいでしょ
     う。次がその例です。(この例は、画像ファイルをあなたのディスクから直接
     ロードする場合は、速すぎて見えないかもしれません。)


File name: loading.java
------------------------------------------------------------
import java.awt.*;
public class loading extends java.applet.Applet implements Runnable
{
	MediaTracker m;
	Image img[] = new Image[10];
	Thread t;
	boolean loaded = false;
	public void init()
	{
		t = new Thread( this );
		m = new MediaTracker(this);
		for(int i = 0 ; i < 10 ; i++ ){
			String name = "image" + i + ".gif"; //ファイル名を作る
			img[i] = getImage( getDocumentBase() , name );
			m.addImage( img[i] , i );
		}
	}
	public void paint( Graphics g )
	{
		if( loaded ){
			// もうロードが終わってるので、ここに内容を書く。
		} else {
			// まだロードが終わっていない。
			g.drawString("Now loading...",100,100);
		}

	}
	public void run()
	{
		while(true){
			try{ Thread.sleep(500);}catch( InterruptedException e ){}
			if( loaded == false ){ 
				try{
					m.waitForAll(); 
				}catch( InterruptedException e ){}
			}
		}
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=loading.class width=300 height=300></applet>
------------------------------------------------------------

#図4.4-4 <DONE>     動作結果(loading.java)

     この例でThreadを使っているのは、repaintを使って表示をする ためです。
     repaintを定期的に呼びだしてやるには、Threadを 使わなければなりません。



4.5 図形を描画する

     前の節で、画像を描画する方法とロードする方法について学びました。今度
     は、アプレットの中に 線を引いたり、塗りつぶした図形を描いたりします。こ
     の方法で描画すると、画面は地味なものに なりやすいのですが、画像を表示す
     るよりも高速なので、使いかたによっては、よい効果を生みだし ます。次の例
     では、画面の中を、さまざまな 図形が動きまわります。前に触れた、ちらつき
     防止のテクニックは使っていないので、 ちらつきます。自分で改造して、仮想
     画面を使うようにしてみてください。 また、この例は、いくつものものを同時
     に動かすサンプルにもなっています。 乱数の使いかたにも触れています。ポイ
     ントがたくさんあるので、ゆっくり読んでください。 


File name: move.java
------------------------------------------------------------
import java.awt.*;
import java.util.*;

public class move extends java.applet.Applet implements Runnable
{
	Thread t;
	int x[] = new int[6];
	int y[] = new int[6];
	int vx[] = new int[6];
	int vy[] = new int[6];
	Random ran;

	public void init()
	{
		ran = new Random();
		t = new Thread( this );
		t.start();

		//アプレットの真ん中の座標を求める
		Dimension d = size();

		for(int i  = 0 ; i < 6 ; i++){
			x[i] = d.width / 2;
			y[i] = d.height / 2;
			vx[i] = ran.nextInt() % 4;
			vy[i] = ran.nextInt() % 4;
		}


	}
	public void paint( Graphics g )
	{
		g.drawRect( x[0] , y[0] , 40,40);
		g.fillRect( x[1] , y[1] , 20,20);
		g.drawLine( x[2], y[2] , x[3],y[3] );
		g.drawOval( x[4],y[4] , 20,30);
		g.drawString( "Moveing" , x[5],y[5] );
	}
	public void run()
	{
		while( true ){
			try{ Thread.sleep( 70);}catch( InterruptedException e ){ }
			for(int i = 0 ; i < 6; i++){
				x[i] = x[i] + vx[i];
				y[i] = y[i] + vy[i];
				// 端ではねかえる処理
				if(x[i] <0 || x[i]>size().width) vx[i]= -vx[i];
				if(y[i] <0 || y[i]>size().height) vy[i]= -vy[i];
			}
			repaint();
		}
	}

}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=move.class width=300 height=300></applet>
------------------------------------------------------------

#図4.5-1 <DONE>     動作結果(move.java)

     Threadを使っているのは、「定期的に」repaintメソッドを 呼び出すためだけ
     なので、この例のテーマの一つである、「同時にいくつものものを動かす」 と
     は関係ありません。
     「同時に」動いているように見えますが、実際には同時ではなく、「一瞬のう
     ちに」 実は別々に動かしているのです。人間にとって、「同時」と感じるに十
     分なのです。

#図4.5-2 <NOT YET>     いくつものものを連続的に繰り返し動かす


     それでは、プログラムを見てみましょう。
     まず、動く点が20個あるのですから、それらの点の座標の情報をすべて管理し
     なければなり ません。ところが、そのために変数を20個も用意していると大変
     です。(20種類について、 別の変数名で同じようなコードをたくさん書かなけ
     ればなりません。)ですから、ここは 番号で同じ種類のデータを管理できる
     「配列変数」を使います。 このデータ構造にしておけば、全ての点に、規則正
     しく並んだ位置の情報を入れる といったことが簡単にできます。 サンプルプ
     ログラムでは、アプレットのサイズを得て、ちょうどアプレットの真ん中にな
     る ように最初の点の位置を決めています。
     その部分は次のようになっています。

------------------------------------------------------------
     Dimension d = size();
     for(int i  = 0 ; i < 20 ; i++){
		 x[i] = d.width / 2;
		 y[i] = d.height / 2;
     }
------------------------------------------------------------

     size()メソッドは、Componentクラスで定義されているメソッド で、アプレッ
     トその他のサイズを得ることができます。その返り値は、 Dimensionクラスで
     す。このクラスの中にあるwidth変数で 幅を、height変数で高さを得ていま
     す。
     init()メソッドの中では、最初の位置を決める他に、移動の方向も 決めていま
     す。どれだけ移動するかを、vx,vyという 配列変数に格納しています。この
     「移動量」は、一回移動する度に何ドット進むか、 という情報です。(高校で
     物理を習ったことがある人は、このvxは、「速度ベクトル」 のことであるとい
     うことが、すぐにわかることと思います。)それぞれが同じ動き をしてもつま
     らないので、ここでは、ランダムな方向に散るように、vx とvyに、乱数を入れ
     ています。

     Random ran;
     ran = new Random();

     この2行で、まず乱数を生成するためのクラスを作ります。その上で

     ran.nextInt();

     を実行すると、新しい乱数が一つづつ作られていきます。これで出てくる乱数
     は、int 型の値の限界いっぱいの幅があるので、それを-3から+3までになるよ
     うに、割り算の余りを求める 演算子'%'を使って調整します。

     vx[i] = ran.nextInt() % 4
     vy[i] = ran.nextInt() % 4

     4で割った余りは、負の数も含めると-3から3になります。この4をいろいろに変
     えて、実行して みてください。
     さて、次に、paintメソッドの中を見てみましょう。この中では、x、 yの値を
     使って、実際に描画しています。 描画するメソッドはたくさんの種類がありま
     す。ここで使っているのは5種類ですが、 他のものについては、リファレンス
     を見てください。


4.6 好きな色を作る

     これまでの例では、灰色に黒い線といった、単調な 色を使ってきましたが、こ
     こでは自分で色を作りだすことを勉強します。色関係の ことは、Colorクラス
     を使います。 次のサンプルプログラムは、マウスを動かすと、ランダムな色の
     四角をどんどん 描いていきます。


File name: color.java
------------------------------------------------------------
import java.awt.*;
import java.util.*;

public class color extends java.applet.Applet
{

	Image offscr;
	Graphics og;
	int xi=0;

	public void init()
	{
		offscr = createImage( size().width  , size().height );
		og = offscr.getGraphics();

	}
	public void paint(Graphics g){

		g.drawImage( offscr , 0 , 0 , null );
	}

	public void update(Graphics g){
		paint(g);
	}

	public boolean mouseMove( Event e , int x , int y){
		xi++;
		int r = new Random(x).nextInt();
		Color c = new Color( r&255,(r>>>8)&255,(r>>>16)&255);
		og.setColor( c );
		og.fillRect( ( xi % 32)*16 , (xi / 32)*16 , 16 , 16);
		repaint();
		return true;
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=color.class width=200 height=200>k</applet>
------------------------------------------------------------

#図4.6-1 <DONE>     動作結果(color.java)

     このサンプルプログラムのポイントは、setColorと、new Color( c ) のところ
     です。
     Javaでは、Graphicsクラスを使って、g.drawLine(...)のように すれば描画す
     ることができます(前節参照)が、それぞれの描画をする前に、g.setColor とし
     て、これから描画する際の色を指定できるのです。ちょうど、筆に色をつけて
     から 書くという感じです。サンプルプログラムの中では、fillRectで描画する
     前に、 setColorで色を指定していますね。

     RGB

     一般的に画面に表示する色は、Red(赤)とGreen(緑)とBlue(青)に分けることが
     できます。この3色 を、「光の3原色」と言います。この3色を組みあわせるこ
     とで、どんな色でも作ることができます。 それぞれの色は、0から255までの
     256段階に設定することができます。プログラム中の new Color(....)としてい
     るところでも、引数を3つ指定して、それぞれの成分を 設定しています。 一般
     的に書けば、 new Color( 赤成分 ,緑成分,青成分) で色が得られる、というこ
     とです。

#図4.6-2 <NOT YET>	 256段階づつの成分になっている


	 256色しか表示できないシステムでは、 256色以上の色を使
     うことはできないので、何らかの方法で色が減らされます。


4.7 音を出す

     Javaでは、音を出すことも非常に簡単です。それに、機種にもよりますが、音
     を自動的に 重ねあわせたり、繰りかえしたりが自由にできるのです。インター
     ネット上でバンドを 演奏する、といったことも可能になるのではないでしょう
     か？次の例は、AudioClip を使って音を出します。ウインドウの中でマウスを
     クリックすると音が出ます。キーボード を押すと、音が中断します。それらが
     行なわれている間、つねに音楽が鳴っています。 ワークステーションなどで
     は、音が鳴らないものもあります。 音が鳴らない場合は、管理者の人に相談し
     てみてください。


File name: sound.java
------------------------------------------------------------
import java.applet.*;
import java.awt.*;

public class sound extends Applet
{
	AudioClip a , music;

	public void init()
	{
		a = getAudioClip( getDocumentBase() , "hi.au");
		music = getAudioClip( getDocumentBase() , "spacemusic.au");
		music.loop();   // 繰りかえして鳴らしはじめる
	}
	public boolean mouseDown( Event e , int x , int y )
	{
		a.play();       // 鳴らす。
		return true;
	}
	public boolean keyDown( Event e , int c )
	{
		a.stop();       // 止める。
		return true;
	}
}
------------------------------------------------------------


File name: test.html
------------------------------------------------------------
<applet code=sound.class width=300 height=300></applet>
------------------------------------------------------------

#図4.7-1 <DONE>     動作結果(sound.java)

     Javaで扱うことができる音声のファイルは、.auという拡張子がついている フ
     ァイルです。この形式のファイルは、音質はあまりよくありませんが、広く使
     われている ものです。この例で使うファイルは、CD-ROMに収められています。
	 画像をロードするのとほとんど同じやりかたで、ロードできますね。



4.8 HTMLに書かれている設定を取りだす

     (注意)この機能は、Netscapeのバージョン3.0では、全く働かないので、注 意
     が必要です。試すには、JDKに附属しているappletviewerか、他のブラウザを
     使う必要があります。

     アプレットは、WWWページ上に置かれることが前提になっているため、 それぞ
     れのアプレットが含まるHTMLファイルの中に、アプレットに対する設定を 書く
     ことができるようになっています。HTMLファイルに書かれている設定を アプレ
     ットのプログラムの方で利用するには、getParameterメソッドを使います。


File name:param.java
------------------------------------------------------------
import java.awt.*;
public class param extends java.applet.Applet
{
	int x,y;
	String text;

	public void init()
	{
		String s , t;

		s = getParameter( "yoko");  // name=yokoに反応する
		t = getParameter( "tate");  // name=tate
		x = Integer.parseInt( s );
		y = Integer.parseInt( t );

		text = getParameter( "text");
	}
	public void paint(Graphics g ){
		g.drawString( text , x,y );
	}
}

------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=param.class width=300 height=300>
<param name=yoko value=100>
<param name=tate value=200>
<param name=text value=What?>
</applet>
------------------------------------------------------------

#図4.8-1 <DONE>     動作結果(param.java)

     HTMLファイルには、<applet>タグと</applet>タグ の間に、設定する項目の名
     前と、その値を、次のような形 で列挙します。(例の通り)

     <param name=yoko value=100>

     HTMLファイルにこのように書かれていれば、あとは、getParamメソッドに よっ
     て、書かれている文字列を Stringクラスの形でプログラム内に読みこむことが
     できるので、 あとは、適当にその値を使えばよいのです。 ここで使ってい
     る、String クラスを数値に変換するInteger.parseIntメソッドの書きかた
     は、記憶に値します。



4.9 マウスの入力

     「音を出す」の節でも少し扱いましたが、マウスの入力をするには、
     mouseDown、 mouseDrag、mouseEnter、 mouseExit、mouseMove、mouseUp を使
     います。それぞれのメソッドは、マウスが次の表のような動作をしたときに 自
     動的に呼ばれます。このことを、「イベント(出来事)が発生する」と言いま
     す。プログラム は、それぞれのイベントに反応する部分だけを書けばよいこと
     になります。 それぞれのメソッドの引数は、mouseDown(Event evt , int x ,
     int y ) となっています。evtには、起こったイベントの種類が入ります。ま
     た、 xとyには、そのイベントが起こった位置が入ります。 このアプレットを
     動かして、いろいろな場所でクリックして、 イベントの発生状況を調べてみて
     ください。(アプレットの端や外も試してみてください。) また、それぞれのメ
     ソッドは、返り値がboolean型に指定されていますので、 return trueなどとし
     て適当に返り値を返しておくことが必要です。


#表4.9  <DONE>	マウスアクションの表

-----------------------------------------------------------------
      メソッドの名前         タイミング                  x,yの意味

      mouseDown     マウスのボタンが押されたと  ボタンが押された座標
                    き

      mouseDrag     マウスがのボタンが押された  移動した先の座標
                    まま移動したとき
                    マウスカーソルが、アプレッ
      mouseEnter    トのウインドウの中に入った  初めて中に入った位置の座標
                    とき
                                                ウインドウの外に出た直後の
      mouseExit     マウスカーソルが、アプレッ  座標(だから負になることもあ
                    トのウインドウから出たとき
                                                る)

      mouseMove     マウスカーソルが1ドットで   動いた先の座標
                    も動いたとき

      mouseUp       マウスのボタンが離されたと  ボタンが離された位置の座標
                    き
-----------------------------------------------------------------


File name: mouse.java
------------------------------------------------------------
import java.awt.*;

public class mouse extends java.applet.Applet
{
	Image offscreen;
	Graphics og;

	public void init()
	{
		offscreen = createImage( size().width , size().height);
		og = offscreen.getGraphics();
		// オフスクリーンを塗りつぶす
		og.setColor( Color.white );
		og.fillRect( 0 , 0 , size().width , size().height);
	}
	public void paint( Graphics g ){
		g.drawImage( offscreen , 0 , 0  , null );
	}
	public void update( Graphics g ){
		paint( g );
	}

	public boolean mouseDown(Event e , int x , int y){
		System.out.println( "Mouse down! X:" + x + " Y:" + y );
		return true;
	}
	public boolean mouseUp( Event e , int x , int y ){
		System.out.println( "Mouse up X:" + x + " Y:" + y );
		return true;
	}
	public boolean mouseDrag( Event e , int x , int y){
		System.out.println( "Mouse drag X:" + x + " Y:" + y );
		return true;
	}
	public boolean mouseMove( Event e , int x , int y){
		System.out.println( "Mouse move X:" + x + " Y:" + y );
		og.setColor( Color.black );
		og.fillRect( x ,  y , 10,10);
		repaint();
		return true;
	}
	public boolean mouseEnter( Event e , int x , int y){
		System.out.println( "Mouse enter X:" + x + " Y:" + y );
		return true;
	}
	public boolean mouseExit( Event e , int x , int y){
		System.out.println( "Mouse exit X:" + x + " Y:" + y );
		return true;
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=mouse.class width=200 height=200>k</applet>
------------------------------------------------------------

#図4.9-1 <DONE>     動作結果(mouse.java)

---------
$ 
$ appletviewer test.html
Mouse enter X:197 Y:95    <- アプレットの中にマウスが入った
Mouse move X:181 Y:80	  <- 適当に動いて....
Mouse move X:176 Y:77
Mouse move X:172 Y:76
Mouse move X:167 Y:76
Mouse down! X:162 Y:78	  <- ボタンを押した
Mouse drag X:161 Y:78	  <- 押したまま少し動いた
Mouse up X:161 Y:78       <- ボタンを離した
Mouse move X:160 Y:79     <- また動いた
Mouse down! X:160 Y:79	  <- また押した
Mouse drag X:159 Y:79	  <- そのまま動いている
Mouse drag X:159 Y:82
Mouse drag X:157 Y:84
Mouse drag X:156 Y:85
Mouse up X:156 Y:85		  <- 離した
Mouse move X:158 Y:85	  <- また動いて...
Mouse move X:175 Y:84
Mouse move X:189 Y:86
Mouse exit X:207 Y:89	  <- ついにアプレットから出た。

---------
	 実行結果の座標と、アプレットのサイズに注目してください。

     マウスをいろいろに操作すると、どのようなイベントが起こっているのかが わ
     かると思います。OSや、マシンの状況によりますが、 mouseMoveのように連続
     的に 起こるイベントは、1秒に50回程度呼びだされます。mouseMoveのところに
     あんまり時間のかかる処理を入れると、動作が遅くなってしまいますので、 注
     意してください。
     また、マウスを動かすと、画面に黒い四角が描画されますが、滑らかに描画 さ
     せるために、「ダブルバッファリング」という手法(スケルトンプログラムでも
     使っています)を採用しています。ダブルバッファリングの典型的な使いかた
     です。updateメソッドの部分をなくすと、一気に表示が乱れてし まうことに注
     意してください。 (発展)上記のサンプルプログラムでは、イベントが起こった
     座標だけを表示して います。ゲームにおいてはその程度の情報で十分だからで
     す。でも、それぞれの イベントのもっと詳しい情報を、次のようにして知るこ
     とができます。 System.out.printlnの部分を、次のように置きかえてみてくだ
     さい。 System.out.println( e ); ここでは、Event型の変数を直接表示してい
     ます。表示された 結果を見てみてください。



4.10 キーボードの入力

     キーボードの入力も、基本的にマウスと似ています。マウスは、カーソルの位
     置の情報が 非常に重要でしたが、キーボードでは、「どのキーを押したか」が
     同じように重要です。 というわけで、キーボードのメソッドは、押したキーの
     番号をint型の変数 で直接得ることができるようになっています。
     キーボード関連のメソッドは次の2種類です。

	(注意)Windows 95用のJDK1.1beta2では、キーボードに関するイベントが全く
	発生しない場合があるようです。実際、筆者の周りの環境では、すべての環境で、
	イベントがきちんと発生しなかったために、第6章のサンプルゲームでは、
	マウスでも操作できるように改造しています。

#表4.10-1 <DONE>	キーボードイベントの表

-----------------------------------------------------------------
      メソッドの名前                 意味
      keyDown           アプレットの中でキーが押された。
      keyUp             アプレットの中でキーが離された。
-----------------------------------------------------------------
     これらのメソッドを使った簡単な例です。




File name: keydown.java
------------------------------------------------------------
import java.awt.*;
public class keydown extends java.applet.Applet
{
	public boolean keyDown( Event e , int key){
		System.out.println( "keydown" + key );
		return true;
	}
	public boolean keyUp( Event e , int key){
		System.out.println( "keyup" + key );
		return true;
	}
}

------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=keydown.class width=200 height=200></applet>
------------------------------------------------------------

#図4.10-1 <DONE>     動作結果(keydown.java)

----------
$ 
$ appletviewer test.html
keydown97		<- Aキーを押した
keyup97
keydown98		<- Bキーを押した
keyup98
keydown99		<- Cキーを押した
keyup99
keydown1004		<- カーソルキーの上を押した
keyup1004
$ 
----------

     この例では、キーを押した瞬間または離した瞬間に keyDownメソッドが呼ば
     れ、そのキー番号が 標準出力に表示されます。(キー番号については、付録
	 を参照してください。)

     このようにJavaでは、キーボードを「押す」「離す」という動作ごとにイベン
     トが 発生するようになっています。しかし、ほとんどのシステムには、「キー
     リピート」 というやっかいな機能がついています。この機能のおかげで、ユー
     ザーがキーを連打して いるのか、押し続けているのか、アプレットからは知る
     ことができないのです。 アクションゲームでは、「キーを押している間だけ、
     動く」というようになっている ものがほとんどですが、そのようなゲームは作
     れないということです。しかし、 キーリピートがあると言っても、ある程度ま
     での操作性を実現することはできます。 keyDownメソッドとkeyUpメソッドの両
     方を利用して次のサンプル のようなプログラムをすれば、ある程度の操作をす
     ることができます。このサンプルは、 キーボードの十字キーを押すと、黒い四
     角を動かします。

     (注意)Macintosh版のJDK1.0.2では、 keyUpメソッドが発生しないためこの
	アプレットは動作しません。Macintoshをお使いの方は、Netscape などを
	使って見てください。


File name: key.java
------------------------------------------------------------
import java.awt.*;

public class key extends java.applet.Applet implements Runnable
{
	Image offscr;
	Graphics og;
	int x , y;      // 動く四角の位置
	boolean down[] = new boolean [4]; // down[0]が上、以下右回り

	int houkou;
	Thread t;        // キャラを継続的に動かすためにスレッドを使う。
	final int UP = 1004; // 定数はこのように最初に定義しておきましょう。
	final int DOWN = 1005; // intの前にfinalをつけると、定数の意味になります。
	final int LEFT = 1006; 
	final int RIGHT = 1007;
	final int STOP = 0;

	public void init( ){
		offscr = createImage( size().width , size().height );
		og = offscr.getGraphics();
		og.setColor( Color.white );
		og.fillRect( 0 , 0 , size().width , size().height);

		houkou = STOP;  // 最初は止まっている。
		x = size().width/2;  // 最初は真ん中にいる。
		y = size().height/2;

		for(int i = 0 ; i < 4 ; i++) down[i] = false;

		t = new Thread( this );
		t.start();
	}
	public boolean keyDown( Event e , int key){

		//十字キーを押すと、変数keyに押したキーの番号が得られます。
		System.out.println( key );      
		if( key == UP ) down[0] = true;
		if( key == RIGHT ) down[1] = true;
		if( key == DOWN ) down[2] = true;
		if( key == LEFT ) down[3] = true;

		return true;
	}
	public boolean keyUp( Event e , int key ){
		System.out.println( key );
		if( key == UP ) down[0] = false;
		if( key == RIGHT ) down[1] = false;
		if( key == DOWN ) down[2] = false;
		if( key == LEFT ) down[3] = false;

		return true;
	}
	public void run()
	{
		while(true){

			if( down[0]) y = y - 4; //それぞれのキーが押されているか？
			if( down[1]) x = x + 4;
			if( down[2] ) y = y + 4;
			if( down[3] ) x = x - 4;

			og.setColor( Color.white );
			og.fillRect( 0 , 0, size().width , size().height);
			og.setColor( Color.black );
			og.fillRect( x,y,10,10);

			repaint();

			try{
				Thread.sleep(70);
			}catch( InterruptedException e ){}
		}
	}
	public void update( Graphics g){
		paint(g);
	}
	public void paint( Graphics g ){
		try {
			g.drawImage(offscr , 0 , 0 , this );
		} catch( NullPointerException e ){
			System.out.println("null paint");
		}
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=key.class width=200 height=200>k</applet>
------------------------------------------------------------

#図4.10-2 <DONE>     動作結果(key.java)

     このプログラムでは、黒い四角をゲームの主人公に見立てて、キーボードによ
     って 移動させています。この移動の処理もこれまた典型的な処理なので、記憶
     に値します。 イベントは、それが起こったときに「一回だけ」発生するものな
     ので、押している 間中キャラを動かし続けるということができません。そのた
     め、スレッドを使います。 これはアニメーションさせるところでやった通りで
     す。




4.11 ゲームプログラミングとコンポーネント

     アプレットでは、ボタンやスクロールバーなどはよく使われます。

#図4.11-1 <DONE>	アプレットではよくボタンなどが使われます


     ボタンやその他の、アプレットを構成している部品は、「コンポーネ
     ント(部品)」 と呼ばれています。コンポーネントは、Javaの汎用性を高めるた
     めに、非常に重要な 役割を果たしています。ところが、これらはゲームプログ
     ラミングには必ずしも 役にたつとは言えないのです。というのは、コンポーネ
     ントの外見や操作感は、機種や ブラウザーごとに違うものになるからです。そ
     れに加えて、ちらつきを防ぐ、 「仮想画面」の技術も使うのが困難になりま
     す。 ゲームにおいては、画面出力とそれに反応する人間の入力が重要なのに、
     コンポーネント を使うと肝心の出力をこまかくコントロールできなくなるので
     す。 というわけで、本書では、基本的に仮想画面に画像や図形を直接描画し、
     その仮想画面を 実際の画面に転送する、という形を取ります。したがってボタ
     ンやスクロールバーの 説明はばっさり省きます。(多くの「アプレットプログ
     ラミング」というような本では、 ボタンその他のコンポーネントについて説明
     をしていますので、コンポーネントに興味がある 方は、そちらを参照してくだ
     さい。)
     ここでは、「もうひとつ別なウインドウを出す」という処理について、サンプ
     ルプログラム を示します。そのウインドウの中用に別な仮想画面を用意すれ
     ば、こまかく表示をコントロール することができます。プレイヤーに多くの情
     報を表示しなければならないようなゲーム (例えばシミュレーションゲームと
     か、RPGとか)では、このような処理が必要になってくる こともあるでしょう。


File name: win.java
------------------------------------------------------------
import java.awt.*;
import java.awt.image.*;

public class win extends java.applet.Applet
{
	MyWindow w=null;
	public void init()
	{
		w = new MyWindow(100,100);
	}
	public boolean keyDown( Event ev , int c )
	{
		if( w == null ) return true;
		if( c=='h' ) w.moveRect(-4,0);
		if( c=='l' ) w.moveRect(4,0);
		if( c=='j' ) w.moveRect(0,4);
		if( c=='k' ) w.moveRect(0,-4);
		if( c=='c' ) w.hide();
		if( c=='s' ) w.show();
		return true;
	}
}

class MyWindow extends Frame
{
	Image offscr;
	Graphics offscr_g;
	int xsize = 100 , ysize = 100;
	int rectx=0 , recty=50;

	MyWindow(int x,int y)
	{
		super("mywindow");
		xsize = x;
		ysize = y;
		resize( xsize,ysize);
		show();  // createImageするより先にshowがある必要がある。
		offscr = createImage( xsize , ysize );
		offscr_g = offscr.getGraphics();
	}
	public void moveRect( int xdif, int ydif )
	{
		rectx += xdif;
		recty += ydif;
		repaint();
	}
	public void update( Graphics g )
	{
		paint( g );
	}
	public void paint(Graphics g )
	{
		offscr_g.setColor( Color.white );
		offscr_g.fillRect( 0 , 0 , xsize , ysize );
		offscr_g.setColor( Color.black );
		offscr_g.fillRect( rectx , recty , 10,10);
		g.drawImage( offscr , 0 , 0 , null );
	}
	public boolean keyDown( Event ev , int c )
	{
		hide();
		return true;
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=win.class width=200 height=200></applet>
------------------------------------------------------------

#図4.11-2 <DONE>     動作結果(win.java)

     この例では、アプレットの中でキーを押すと、いろいろなことが起こります。

        o 's': 小さなウインドウを表示します。
        o 'c': 小さなウインドウを閉じます。
        o 'h': 黒い四角を左へ移動します。
        o 'j': 黒い四角を下へ移動します。
        o 'k': 黒い四角を上へ移動します。
        o 'l': 黒い四角を右へ移動します。

     ウインドウを別に出すようなアプレットでは、まずinitメソッド の中で使う可
     能性のあるウインドウのクラスをnewしておきます。 そして、その後、必要に
     応じてshowやhideするように します。このようにするのはなぜかというと、
     newする処理は Javaではけっこう時間がかかるからです。showやhide の処理は
     一瞬にして済みます。ボタンを押した時に「ぱっ」と出てきた 方が気持ちがよ
     いものです。この例では、メインのアプレットの方のキー操作を 別なウインド
     ウの方に反映させる方法を示しました。ちなみに、小さい方のウインドウ の中
     で何かキーを押すと、ウインドウは閉じます。
     プログラム的には、このサンプルプログラムは、MyWindowという、Frameクラス
     をextendsしている 新しいクラスを用意して、その中で何もかもやっていると
     ころが重要です。 Frameクラスはコンポーネントの一種ですから、keyDown
     やcreateImageなど、Aplletクラスと同じような メソッドが使えて非常に便利
     です。
     ところで、Componentクラスのメソッドに、それ自体を 移動させるmoveという
     メソッドがあります。これを使えば、ウインドウを 自由な場所に移動させるこ
     とができるはずなのですが、多くの環境で(Windows95も)これは正しく動きま
     せん。ウインドウの位置は、システムの側で決められてしまうようです。この
     サンプルプログラムでも、出したり消したりする度に、違う位置に飛ばされて
     しまいます。
     ウインドウは、使いかたによってはゲームの表現を非常に豊かにします。ぜひ
     活用 してください。

	(注意)
	 Javaの「ごみ集め機構」が働くために、以下のようなコードはきちんと動いて
	 くれない場合があります。ウインドウを出したりするプログラムでは、
	 注意してください。

--------------------------------------
public class myApplet extends Applet
{
	
	....

	void doSomething()
	{
		myWindow win = new myWindow( ...);	// ここでウインドウが作られるが
		...
	}		// <-- ここでwinはスコープから外れるので、winのインスタンスが
			// メモリから抹消されてしまいます。
			//そうするとイベントも来なくなってしまうのです。
}
--------------------------------------

	これに対処するには、次のようにします。
--------------------------------------
public class myApplet extends Applet
{
	
	....
	myWindow win;
	void doSomething()
	{
		win = new myWindow( ...);	// ここでウインドウが作られるのは一緒
		...
	}		// ここでもまだスコープ内なので、winのインスタンスは無事。
			// イベントもきちんと来ます。
}
--------------------------------------

	* ウインドウの外側の領域の大きさを得る
		
	ゲームプログラムでは、プレイヤーにゲームの状態を正しく伝えるために、
	「正確な表示」が必要です。アプレット自身の場合は、アプレットの大きさと
	正確に同じ領域を得るのは簡単です。paint(Graphics g)メソッドの中で

		g.drawRect( 0 ,0 , size().width-1 , size().height-1 );

	のようにすれば、正確に同じ大きさの四角を書くことができます。

#図4.11-3 <DONE>	アプレットはinsetsの要素がすべて0なので正しく描画できる


	ところが、
-----------------------------------
class MFrame extends Frame
{
	MFrame(){
		super("Mframe");
		resize(100,200);
	}
	public void paint(Graphics g ){
		g.drawRect( 0 , 0 , size().width-1,size().height-1);
	}
}
-----------------------------------
	以上のようにして作ったウインドウでは、「ウインドウの端から端までの大きさ」
	が(100,200)になってしまうので、

		g.drawRect( 0 , 0 , size().width-1,size().height-1);

	は正しく描画されません。ウインドウの周りに
	は、太さをもつ枠やタイトルバーがあるため、その上に描画しているからです。
	そこで、Insetsというクラスを使います。paint(Graphics g)の中身を次のよう
	にかえれば、
-----------------------------------
	public void paint(Graphics g ){
		Insets ins = insets();			
		g.setColor( Color.red );
		g.drawRect( ins.left , ins.top , 
				   size().width-ins.right-1,size().height-ins.bottom-1);
	}
-----------------------------------

	正しく描画されるようになります。

#図4.11-4 <DONE>	動作結果


	Insetクラスには、次の4つのメンバ変数があって、それぞれ、Frameという
	コンポーネントの上下左右の「つけたし部分」のサイズの情報を持っている
	のです。Frame以外のコンポーネントにも、Insetは存在します。調べてみて
	ください。

#表4.11 <DONE>	Insetsのメンバ変数

----------------------------
	top			上辺
	bottom		下辺
	right		右辺
	left		左辺
----------------------------
		
	(注意)
	Frameをshow()する前にInsetを調べても、まだ外見が決まっていないため、
	値は不定になります。かならず、show()されていることを確認してください。
	例では、paintの中でinsets()を実行していますので、正しい値が得られています。


4.12 Javaでの画像処理

	第2章で、「工夫次第でデータを節約することができる」ということを説明して
	いましたが、その中で、「同じ形で違う色の敵を登場させて、あたかも種類が
	多いように見せかける。」という技を紹介していました。この節では、
	それを実現します。
    Javaにおいては、一般的な画像処理用のクラス群を使うことによって、画像の
	処理をすることができます。その典型的な例が、色の変換です。ここで示す例	
	は、色を変換するものですが、この方法をダブルバッファに使っている画像に
	対して用いれば、画面のある位置の色を得ることができます。(この方法は
	非常に遅いので、あまり頻繁に使用するのは避けたい方法です。)


File name: memSrc.java
------------------------------------------------------------
import java.awt.*;
import java.awt.image.*;

public class memSrc extends java.applet.Applet
{
	Image img,nimg;
	Graphics gr;

	PixelGrabber pg;
	int pix[];
	int height , width;

	public void init()
	{
		MediaTracker mt= new MediaTracker(this);
		img = getImage( getDocumentBase() , "kawai.jpg");
		mt.addImage( img, 0 );
		try{
			mt.waitForAll();         // 読みこみが終了するまで待つ。
		}catch( InterruptedException e ){}

		width = img.getWidth(null);
		height = img.getHeight(null);

		// 必要な分のメモリーを確保。要素数は (縦ドット数)×(横ドット数) です。 
		pix = new int[width*height];   

		resize( width*2 , height );
		pg = new PixelGrabber( img ,0,0, width,height,pix,0,width);
		try{
			pg.grabPixels();
		} catch ( InterruptedException e ){
			System.out.println(e );
		}
		// ここで画像を好きなように処理。
		for(int i=0;i<width*height;i++){
				pix[i]= pix[i]& 0xffff00ff;  //緑成分を全部殺す処理
		}
		nimg = createImage(
				new MemoryImageSource( width,height,pix ,0,width ));
	}

	public void paint( Graphics g ){
		g.drawImage( img , 0 , 0 , this );
		g.drawImage( nimg , width,0,this );

	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=memSrc.class width=500 height=400></applet>
------------------------------------------------------------

#図4.12-1 <DONE>	動作結果(memSrc.java)

	画面の左半分に女の子の画像が出て、右半分にその画像の緑成分を抜いた
	ものが表示されています。
	このプログラムのポイントごとに解説します。

	1) Imageのサイズを正しく取りだすために、MediaTrackerを使って確実に画像を
	ロードしている。
      ImageクラスのgetWidth() ,getHeight()は、それぞれ画像の
	幅と高さを得るメソッドですが、これらは、画像がロードされていないと、
	正しい値を返しません。したがって、これらのメソッドを呼びだす前に、
	waitForAll()を行なって、しっかりロードをしています。

	2) 画像処理のためのメモリーを確保
	幅×高さの要素数を持つint型の配列を確保(new)しています。
	
	3) PixelGrabberをnewしています。PixelGrabberクラスは、Image型の画像から、
	int[] の配列へ、色の情報を取りだします。配列の大きさは、最低2)で説明した
	大きさがあれば、大きすぎても大丈夫です。足りない場合は、
	ArrayIndexOutOfBoundsExceptionが発生します。

	コンストラクタの書式

	PixelGrabber( Image i, int x,int y,int w,int h,int[]pix,int off,int hsiz)
	
	Image i .... 色を取りだす対称の画像
	int x,y .... 色を取りだす部分の画像内の左上座標
	int w,h .... 色を取りだす幅と高さ
	int[] pix .. 色の情報を格納する配列
	int off   .. 配列の何番目の要素から格納を開始するか
	int hsiz  .. 画像の横幅

	4) 処理してできた新しい値を使って、新しい画像をもう一枚作る

	nimg = createImage( new MemoryImageSource( width,height,pix ,0,width ));

	今までダブルバッファを作るために、よくcreateImageを使っていましたが、
	また別の引数のタイプを持つcreateImageです。この行はほぼ決まった書きかた
	で、新しく作りたい画像の幅と高さと、色の情報が入っているint型の配列とを
	指定します。

	* 色の扱い

	最後に、色の情報が一個のint型の値の中にどのように格納されているのかを
	示します。

	int型は32bit値です。それを8ビットごとに4つに分解し、それぞれに0(0x00)
	から255(0xff)までの値が割りあてられています。

#図4.12-2 <DRAFT>	RGBAの32ビット割りあて


-----------------------------
	01234567   01234567   01234567   01234567
	A(透明度)  R(赤)      G(緑)      B(青)
-----------------------------

	透明度は0xffが最大値の不透明、0x00が完全な透明です。R,G,Bについては、
	0xffが最も強く発色する値で、0x00が暗黒です。

	例えば、0xffffffff は、完全な不透明のホワイトで、0x041122ffなら、
	限りなく透明に近いブルーということになります。

	画像を処理するループの中で、ある色に反応するように仕組んでおけば、
	敵の輪郭の色だけを変えたりといったことが自由にできます。活用してください。


4.13 フォント

	Javaでは、様々な言語の、様々な形式の文字を表示することができます。
	日本語の表示についてはいろいろな問題がからむので、付録の「日本語を表示
	する方法」を参照してもらうことにして、ここでは英文字を自由に表示する
	プログラムの例を示します。

File name: font.java
-------------------------------------------------------------
import java.awt.*;

public class font extends java.applet.Applet
{
	String font_names[];
	public void init(){
		// まず、使用可能なフォントを探します。
		font_names = Toolkit.getDefaultToolkit().getFontList();
		for(int i=0;i<font_names.length;i++){
			System.out.println( font_names[i] );
		}
	}
	public void paint(Graphics g ){
		// それぞれのフォントで、文字を描画します。色もサイズも
		// 変化させてみましょう。
		g.setColor( Color.white);
		g.fillRect( 0 , 0 , size().width , size().height);  //白で塗りつぶし
		for(int i=0;i<font_names.length;i++){
			Font f = new Font( font_names[i] , Font.PLAIN , 15+i*5 );
			g.setFont( f ); 
			g.setColor( new Color((int)( 0xffffff * Math.random()) ) );
			g.drawString( "God said 'are you here?'" , 20,40*i+50 );
		}
	}
}
-------------------------------------------------------------

File name: test.html
-------------------------------------------------------------
<applet code=font.class width=300 height=300></applet>
-------------------------------------------------------------

#図4.13-1 <DONE>	実行結果(font.java)

	標準出力は次のようになっています。
----------
$
$ appletviewer test.html
Dialog
Helvetica
TimesRoman
Courier
Symbol
$
----------

	様々なフォントが、様々な色で描画されています。プログラムの中では、まず
	
	font_names = Toolkit.getDefaultToolkit().getFontList();

	として、使用可能なフォントの名前を、String型の配列として得ています。
	筆者の環境では、Dialog,Helvetica,TimesRoman,Courier,Symbolという5つの
	フォントが利用可能でした。だいたいこれらの5つは、どの環境でも利用可能
	なので、このフォントがあると期待してよいでしょう。ゲームの中で特定の
	フォントを使いたい場合は、まず、例えばSymbolがあると仮定して、もしも
	Stringの配列に存在しない場合は、他のものを使う、というようにプログラムして
	おけばよいでしょう。

	フォントを使う基本的な手順は、
	1) フォントの名前を調べます。
	2) Font = new Font( String 名前 , int STYLE , int point)
	として、Font型のインスタンスを作ります。STYLEには、次のものがあります。
	
#表4.13<DONE>	フォントのスタイル表

----------------------------------
	Font.BOLD      太字
	Font.ITALIC    斜体
	Font.PLAIN	   標準
----------------------------------
	point数は、一番大きな文字の縦ドット数です。

	3) Graphicsクラスのインスタンスgに対して、g.setFont(Font)します。
	4) 描画します。
	


#図4.13-2 <DONE>	3種類のスタイルで色々に表示した例


	(注意)
	  Toolkit.getDefaultToolkit().getFontList()で得られたそれぞれのフォント
	は、どの大きさ(ポイント数)に指定しても利用可能であるというわけではあり
	ません。例えば、Symbolフォントのサイズ24以上が利用不可の場合もあります。
	その場合には、g.setFont(...)のところで、 例外が発生することがあります。
	(IOExceptionあるいは、FileNotFoundExceptionなど。)したがって、確実な
	プログラムにしたい場合は、

--------------------
try{
	Font f = new Font( font_names[i] , Font.PLAIN , 15+i*5 );
	g.setFont( f ); 
}catch( Exception e){
	// フォントがなかった場合の処理
}
--------------------
	というようにしておくのが安全です。(めったにありませんが。)

	* フォントごとの描画サイズを得る
	
	フォントはいろいろありますから、同じ文字列を描画してもサイズが異な
	ります。ゲームでは「正確に」描画したいことも多いので、実際に描画したら
	いったいどのくらいのサイズになるのかを知ることができると助かります。
	それを実現するのが、FontMetricsクラスです。次に使用例を示します。

File name: fmetr.java
--------------------------------------
import java.awt.*;

public class fmetr extends java.applet.Applet
{
	String font_names[];
	public void init(){
		font_names = Toolkit.getDefaultToolkit().getFontList();
	}
	public void paint(Graphics g ){

		for(int i=0;i<font_names.length;i++){
			Font f = new Font( font_names[i] , Font.PLAIN , 20 );
			g.setFont( f ); 
			String s = "GAME OVER";
			g.drawString( s , 10,40*i+20 );
			FontMetrics fm= g.getFontMetrics();  // FontMetricsを得ます。
			int width = fm.stringWidth( s );     // 文字列の長さを計算します。
			g.drawString( ""+width , 10,40*i+40 );

		}
	}
}
--------------------------------------

File name: test.html
--------------------------------------
<applet code=fmetr.java width=300 height=400></applet>
--------------------------------------

#図4.13-3 <DONE>	実行結果(fmetr.java)	



4.14 アプレットの後始末

	アプレットの実行を終了しようとした時や、ブラウザを終了させようとした時
	には、 destroy()メソッドが自動的に呼びだされます。(4章第1節、14を参照)
	アプレットの中でスレッドを使っている場合は、destroy()メソッドをオーバー
	ライド(書きかえ)して、その中でスレッドを止めるようにするのが、礼儀正しい
	アプレットであるとされています。以下の例は、スレッドを止めるdestroy()
	メソッドの例です。

--------------------------------------
public class destTest extends java.applet.Applet implements Runnable
{
	Thread t;
	....
	public void init()
	{
		t = new Thread( this );
		t.start();
	}
	public void run()
	{
		...
	}
	public void destroy()		// この4行を書いておくだけです。
	{
		t.stop();
	}
}
--------------------------------------

	5、6章のゲームの実例では、destroyメソッドをオーバーライドしています。
	それらは、上記の例とほとんど同じになっています。







































