
クラスライブラリ

このリファレンスでは、JDK1.1のコアAPI(どんな実行環境でも使えることが保 障さ
れているAPI)をベースに解説します。JDK1.0.2のライブラリに含まれていない もの
には、(Not available on 1.0.2マーク)をつけてあります。 (以下のHTMLでは、アス
タリスクをつけていきます。) パッケージはアルファベット順で、その中のクラスも
アルファベット順です。 それぞれのクラスのよく使うメソッドを紹介しています。

   * java.applet

     このパッケージには、アプレットの実行に関連する機能が詰まっています。 ア
     プレットプログラミングとは、つまりこのパッケージにあるクラスを使って プ
     ログラミングすることだと言えます。

     インターフェイス

        o AppletContext
          AppletViewerやその他、アプレットを下位の部品として使うような アプ
          リケーションを作るときに使うインターフェイスです。ゲームを作る分に
          は使う ことはないでしょう。
        o AppletStub
          これもAppletViewerなどが使うものです。普段は使うことはあ りませ
          ん。
        o AudioClip
          アプレットにオーディオを演奏させる時に使います。重要なメソッドとし
          ては
             + loop() 繰り返して演奏させます。
             + play() 一回だけ演奏させます。
             + stop() 演奏中の音があると、止めます。
               重ねてplayしても前に鳴っていた音は消えず、重ねて演奏されま
               す。

     クラス

        o Applet extends Panel
          アプレットの基本クラスです。
          よく使うメソッド
             + destroy() このメソッドを実行すると、アプレットが使用している
               資源を解放します。
             + getAudioClip(URL),getAudioClip(URL,String) URLを指定して、ア
               プレットで使う AudioClipをサーバから取ってきます。
               例： getAudioClip( getCodeBase(), "./bang.au");
             + getCodeBase() getAudioClipや getImageをするときに便利です。ア
               プレットのクラスそのもの URLを求めます。getDocumentBaseという
               のもあり ます。
             + getImage(URL),getImage(URL,String) アプレットで使う画像のファ
               イルを読みこんで展開し、Imageク ラスを得ることができます。
             + getParameter(String) <applet>タグを含むHTMLに書かれて
			   いる<param>タグの内容を 名前で読みだします。
             + init() アプレットを初期化するコードをこのメソッドの中に書きま
               す。
             + play(URL),play(URL,String) AudioClipを演奏します。
             + resize(Demension),resize(int,int) アプレットのサイズを変更し
               ます。
             + start() アプレットが初期化(init)された後や、他のページから戻
               って きたときなどに呼びだされます。
             + stop() ブラウザ上でアプレット以外のページに移動したときなどに
               呼びだされます。 もちろんappletviewerを終了させる時にも呼びだ
               されます。

   * java.awt

     Javaでグラフィカルなユーザインターフェース(GUI)を実現するためのAPI群で
     す。 全てのアーキテクチャに一般化できる機能が凝縮されています。JDK1.1で
     は、 大規模なアプリケーションも容易に開発できるように拡張されています。

     インターフェイス

        o Adjustable
		囲が決まっている、連続的な数値を値として持つようなオブジェクト(典型的
		には、Scrollbarなど)は、これをimplementsします。
        o EventSource
		他のオブジェクトによって使われるようなイベントを発生するような
		オブジェクト。
        o ItemSelectable
		0個以上の項目を選択できるようなオブジェクト。
        o LayoutManager
		Containerをレイアウトするクラスのためのインターフェイス。
        o LayoutManager2
		レイアウトに束縛されるようなContainerをレイアウトするクラスのための
		インターフェイス。
        o MenuContainer
		メニューに関係するすべてのクラスは、これをimplementsします。
        o PrintGraphics
		印刷のためのグラフィックスコンテキストを提供するインターフェイス。
        o Shape
		ある図形を表現するオブジェクトのためのインターフェイス。

     クラス

        o AWTEvent
          awtイベントの基本になるクラスです。
        o BorderLayout
          "North","South","East","West","Center"のいずれかを指定して 部品類
          を整列させるレイアウタです。
        o Button
          名前のついたボタンを実現します。
          例：add( new Button("OK!") );
        o Canvas
          キャンバス、その名のとおり、この上に絵を描くことができます。 この
          クラスをextendsして、面白い効果を持つボタン などを作ることができま
          す。extendsしたクラスでは、 paint(Graphics)メソッドを書く(オーバー
          ライド)する ことによって、好きな絵をかくことができます。 例：

          class FunnyButton extends Canvas
          {
             public void paint(Graphics g){
                 ....
             }
          }

        o CardLayout
          常には1枚のカードしか見えないようなUIを実現する ためのレイアウタで
          す。
        o Checkbox
          チェックされているかそうでないかという、 booleanの値を持つGUI部
          品。
        o CheckboxGroup
          CheckBoxをまとめて管理する。
        o CheckboxMenuItem
          メニューの中にある選択肢を表示するチェックボックス。
        o Choice
          クリックするとポップアップするメニュー。ドラッグして選ぶと、 現在
          選んでいる項目が、メニューのタイトルになる。
        o Color
          RGBを使って簡単に色を作ったりできる。 例： g.setColor( new
          Color(100,100,100) );
        o Component
          awtの基本的なクラス。awt内の他の多くのGUI部品は、このクラスを
          extendsしている。
        o Container
          他のawtコンポーネントを含むことができるコンポーネント。 例：
          myContainer.add( new Button(...
        o Cursor
          マウスカーソルを設定するためのクラス。
        o Dialog
          ユーザからの入力を要求するウインドウ。
        o Dimension
          幅と高さを一括管理できるクラス。多くのクラスのメソッドの引数になっ
          ています。
        o Event
          プラットフォームに依存しないGUIイベント処理を実現するためのクラ
          ス。 idというフィールド変数を持っていて、その値を見て 処理を振りわ
          けたりする。
        o EventQueue*
          複数のイベントを列にして管理しやすくするクラス。JDK1.1では、 大規
          模なアプリケーションの作成も容易にするために、Eventの管理方法 が拡
          張されています。
        o FileDialog
          アプリケーションにおいてファイルを選択する処理はいつも似たようなも
          の になる。その処理を一般化して使えるようにしたクラス。ファイルを
          選ぶまで はブロックします。
        o FlowLayout
          左から右へコンポーネントを並べるレイアウタ。
        o Font
          フォントを操作する。
        o FontMetrics
          幅や高さなど、フォントに関する情報を引きだす。
        o Frame
          タイトルつきのウインドウ。次のようにすれば新たなウインドウを出すこ
          とが できます。
          例：

          Frame f = new Frame("Title");
          f.show();

        o Graphics
          CanvasやImage、その他にも いろいろなオブジェクトに対してのさまざま
          な描画を実現する。
        o GridBagConstraints
          GridBagLayoutのお助けクラス。
        o GridBagLayout
          コンポーネントを複雑に配置するためのレイアウタ。コンポーネントの
          サイズは同じでなくてもよく、相当に柔軟な配置ができる。
        o GridLayout
          コンポーネントをマス目様に配置するレイアウタ。
        o Image
          Imageは直接にインスタンス化(new)することはできません。 createImage
          やgetImageで得るのが普通。
          例：

          Image myimg = getImage( getDocumentBase() , "hoge.gif" );
          Image ofscr = createImage( 100,100 );  // オフスクリーンイメージを作る
          Graphics ofscrg = ofscr.getGraphics(); // 以降ofscrgを使って描画する

        o Insets

          Containerの上下左右に挿入される空白のサイズを管理する。 新しくウイ
          ンドウを開いてその「中身の」本当の大きさを得るには次の ようにす
          る。
          例：

          Frame f = new Frame("title");
          f.resize(200,200);    // resizeを忘れると大きすぎるウインドウができる
          f.show();             // 先にshowすること
          Insets ins = f.insets(); // これでタイトルバーや枠の太さが求められる

        o Label
          読むことはできるが変更できないラベルをあらわすコンポーネント。 チ
          ェックボックスの横などに表示したりする。
        o List
          スクロールする選択メニュー。
        o MediaTracker
          画像や音声をロードする時に、それが終了するまで待ったり、状況を 調
          べたりするクラス。例えば画像の場合は次のようにして全てが ロードさ
          れ終わるまで待つことができる。 例：

          public void init()
          {
              MediaTracker tracker;
              Image img;
              tracker = new MediaTracker(this);
              img = getImage( getDocumentBase() , "hoge.gif");
              tracker.addImage(img , 0 );
              tracker.waitForAll(); // ロードが終わるまでinit()は終わらない
          }

        o Menu
          MenuBarの部品。
        o MenuBar
          メニューバー。メニューバーは、動作環境によって異なるが、それぞれに
          応じた 形式のメニューバーになる。
        o MenuComponent
          メニュー関係のクラスは、すべてこのクラスをextendsしている。
        o MenuItem
          メニューの選択項目になる文字列を内容とする一つの項目。
        o MenuShortcut*
          JDK1.1では、より一般的なアプリケーションを作成できるように、 メニ
          ューをキーボード操作できるようになったが、それを実現するための ク
          ラス。java.awt.Eventをextendsしている。
        o Panel
          Containerの一種で、一般的な機能を持つコンテナを 実現する。アプレッ
          トをいくつかのGUI群にわけたい時などは Panelを群の数だけ作ってそこ
          に細かいGUI部品を置く というようにすることが多い。
        o Point
          x,yという2つの値をあらわすクラス。 Pointが点の「位置」をあらわすの
          に対して、Dimension は、「幅と高さ」をあらわすことに注意。同じint
          の2値だが、 わざわざ意味を分けているのには目的がある。
        o Polygon
          複数の点の位置の配列で初期化される多角形をあらわす。 Graphicsクラ
          スのdrawPolygonというメソッドに 渡してポリゴンを描画することができ
          る。
        o PopupMenu*
          マウスを操作した場所で、その場に応じたメニューを出す。Netscapeの
          右クリックのような感じです。
        o PrintJob*
          プリンタを操作するためのクラス。Toolkitを使って得る。
        o Rectangle
          四角形をあらわす。左上の点と幅、高さをもつ。
        o ScrollPane*
          JDK1.1以前は、スクロールの処理が意外にややこしい上に、 システムの
          オーバーヘッドが大きく、パフォーマンス的も低かった ために、
          Containerクラスをextendsしている 新しいクラスが実装されました。他
          のContainerのように、 addができます。
        o Scrollbar
          単純なスクロールバーを実現します。JDK1.1以降では、ほぼ ScrollPane
          を使うという方向になっていくでしょうが。
        o SystemColor*
          Javaアプレット/アプリケーション以外の動作中のアプリケーションや、
          システム自体と色を共有するためのクラスです。GUIのそれぞれの部分ご
          との 色を取りだしたりすることによって、色の統一感があるGUIを構築す
          ることが できます。
        o TextArea
          複数行にまたがるテキスト入力エリアを設けます。変更ができないように
          すれば、アプリケーションの起動時にユーザに読ませる注意書きなどにも
          使えます。
        o TextComponent
          テキストを編集するようなクラス (TextArea,TextField) はこのクラスを
          extendsします。領域選択やカーソル移動 など、便利で一般的な機能を持
          っているからです。
        o TextField
          TextAreaと異なり、1行の入力フィールドを用意します。
        o Toolkit
          awtの中の抽象クラス(ImageやGraphics) を、実際の動作環境に応じたも
          のに結びつけます。Toolkit を得るには、コンポーネントをextendsして
          いるクラスの中で getToolkit()というメソッドを使います。
          例：

          import java.awt.*;
          public class myAplt extends java.applet.Applet
          {
              Toolkit tk;
              Image img;
              public void init(){
                  tk = getToolkit();
                  img = tk.getImage( "aho.gif");
              }
              public void paint(Graphics g){
                 g.drawImage( img ,0,0,this);
              }
          }

          ToolkitにはcreateImageという、 プログラム的に画像を作りだすメソッ
          ドがあって、それが使いたいために 上で示したような方法を取ることも
          多いです。
        o Window
          普段はほとんど使わないでしょう。APIマニュアルには、ポップアップメ
          ニューを作る ときに使えるということが書いてありますが、ウインドウ
          を作るのであれば Frameクラスを使うべきです。

     例外

        o AWTException
          awtの中で例外的な状況が発生した場合に投げられます。
        o IllegalComponentStateException*
          あるコンポーネントに、処理を要求(つまりメソッド呼びだし)した時に、
          たまたまそのコンポーネントが要求を処理できない状態であった場合に
          発生します。

     エラー

        o AWTError
          awt内部のエラーです。この原因はなかなかつきとめることができませ
          ん。 動作環境によって様々な原因がありえます。どうしてもこのエラー
          に苦しめられ るような場合は、あきらめて少し違う他のやりかたにする
          と直ったりします。

   * java.awt.datatransfer*

     アプリケーション同士の情報のやりとりを実現するためのAPI群です。

	  インターフェイス

		 o ClipboardOwner*
		   クリップボードに情報を渡すことができるオブジェクトは、これを
		   implementsします。
		 o Transferable*
		   実際にクリップボードとの間で情報をやりとりするために使われるクラス
		   はこれをimplementsします。

	  クラス

		 o Clipboard*
		   カット/コピー/ペーストといった、コンポーネント間あるいは他のアプリ
		   ケーション との間で一般的な情報のやりとりをするための操作を実現し
		   ます。 情報として、内容とその名前と所有者(所有コンポーネント)を持
		   っています。
		 o DataFlavor*
		   クリップボードとやりとりする情報がどのようなタイプのものであるかを
		   管理・操作します。
		 o StringSelection*
		   クリップボードとのやりとりで、単純な文字列(プレインテキスト)をやり
		   とり する単純なやりかたを実現します。

	  例外

		 o UnsupportedFlavorException*
		   当該DataFlovorが、要求されたデータに対応していない場合 に発生しま
		   す。

	* java.awt.event*

	  JDK1.1では、大規模なアプリケーションの開発を容易にするために、まずイベ
	  ント関連 の仕様が拡張されました。JDK1.0形式のイベント処理の方法から、
	  JDK1.1以降の方法へと変更する方法については、第4章の1節、17で扱っています。

	  インターフェイス

		 o ActionListener*
		   Button,List,MenuItem,TextField,Checkbox,Choiceなどが発生する
		   イベントを処理するクラスのためのインターフェイス。
		 o AdjustmentListener*
		   Scrollbarなどが発生するイベントを処理するクラスのためのイン
		   ターフェイス。
		 o ComponentListener*
		   Dialog,Frameなどが移動したり、リサイズされたりといったイベントを
		   処理するクラスのためのインターフェイス。
		 o FocusListener*
		   コンポーネントがフォーカスを得たり、失なったり、といったイベントを
		   処理するクラスのためのインターフェイス。
		 o ItemListener*
		   Checkbox,Choiceなど、項目の状態自体が変化した、というイベントを
	       処理するクラスのためのインターフェイス。
		 o KeyListener*
		   キーボードに関連するイベントを処理するクラスのためのインター
		   フェイス。
		 o MouseListener*
		   マウスのボタンに関するイベントを処理するクラスのための
		   インターフェイス。
		 o MouseMotionListener*
		   マウスの動きに関するイベントを処理するクラスのためのインター
		   フェイス。
		 o WindowListener *
		   Dialog,Frameなどが発生する、ウインドウの開け閉めに関するイベントを
           処理するクラスのためのインターフェイス。

	  クラス

		 o ActionEvent*
		   ActionListenerが受けとるイベント。Button,List,MenuItem,TextField,
		   Checkbox,Choiceなどが発生。
		 o AdjustmentEvent*
		   AdjustmentListenerが受けとるイベント。Scrollbarが発生。
		 o ComponentAdapter*
		   空メソッドをプログラム中でたくさん定義するのは繁雑なので、
		   それを回避するために、空のメソッドを定義してくれるクラス。
		   このクラスをextendsすれば、とりあえず必要ない処理を書かなくても
		   よくなります。 ComponentListener用のクラス。
		 o ComponentEvent*
		   ComponentListenerが受けとるイベント。Dialog,Frameなどが発生。
		 o FocusAdapter*
		   FocusListenerのクラスのプログラムをシンプルにするためのクラス。
		 o FocusEvent*
		   FocusListenerが受けとるイベント。あらゆるコンポーネントが発生する
			イベント。
		 o InputEvent*
		   コンポーネントに対する入力の基本クラス。
		 o ItemEvent*
		   ItemListenerが受けとるイベント。Checkbox,Choiceなどが発生。
		 o KeyAdapter*
		   KeyListenerのクラスのプログラムをシンプルにするためのクラス。
		 o KeyEvent*
		   KeyListenerが受けとるイベント。あらゆるコンポーネントが発生する
		   可能性があります。
		 o MouseAdapter*
	       MouseListenerのクラスのプログラムをシンプルにするためのクラス。
		 o MouseEvent*
		   MouseListenerが受けとるイベント。Canvas,Dialog,Frame,Panel,Window
		   などが発生。
		 o MouseMotionAdapter*
		   MouseMotinListenerのクラスのプログラムをシンプルにするためのクラス。
		 o PaintEvent*
		   コンポーネントの描画イベント。このイベントは、従来通りのプログラム
		   をすればよく、Listenerはありません。
		 o WindowAdapter*
		   WindowListenerのクラスのプログラムをシンプルにするためのクラス。
		 o WindowEvent*
		   WindowListenerが受けとるイベント。DialogやFrameが発生。

	* java.awt.image

	  awtで画像を扱う時に一歩ふみこんだ処理をするためのパッケージです。 画像
	  処理をする時には必需品です。

	  インターフェイス

		 o ImageConsumer
		   いわばImageProducerのしたうけとなるインターフェイスです。
		   ImageProducerをimplementsしているクラスは、 その内部で情報を得るた
		   めにImageConsumerで定義されている メソッドを使います。
		 o ImageObserver
		   イメージは非同期にロードされメモリ上に生成されていきますが、その
		   状況を調べるためのインターフェイスです。
		 o ImageProducer
		   Imageをあたらしく作りだせる能力を持つということを あらわすインター
		   フェースです。このインターフェイスを implementsしているクラスは、
		   たとえばToolkit のメソッドであるcreateImage(ImageProducer)の 引数
		   として与えられることができます。どのImageも、内部に その画像を生成
		   するためのImageProducerを必要とします。

	  クラス

		 o AverageScaleFilter*
		   単純なスムージングアルゴリズムを使って画像を拡大縮小します。 従来
		   はただ間延びさせるだけでした。
		 o ColorModel
		   Javaでは色はRGBAと呼ばれるモデルで統一されていますが、Java以外から
		   ピクセルのデータを読みだす場合はまずJavaの形式に変換しなければなり
		   ませ ん。その処理を助けます。
		 o CropImageFilter
		   イメージの部分的な領域を切りだします。
		 o DirectColorModel
		   ピクセル値から色へ直接的に変換します。
		 o FilteredImageSource
		   ある特定のフィルタをかけるようなImageProducerです。
		 o ImageFilter
		   新たにフィルタを作る場合はこのクラスをextendsし、それぞれ のメソッ
		   ドをオーバーライドします。そうすることによって ImageConsumerから
		   ImageProducerへの情報の 渡しかたを変え、フィルタをかけるのです。
		 o IndexColorModel
		   それぞれの色を番号で指定するようなカラーモデルです。ある色を透明色
		   に指定 することもできます。
		 o MemoryImageSource
		   int型の配列から新しいImageを作りだします。 非常にわかりやすいサン
		   プルプログラムが、APIマニュアルの同じ項に掲載さ れています。
		 o PixelGrabber
		   Imageからint型の配列へ情報を取りだします。 ちょうど上記の、
		   MemoryImageSourceの逆の処理になります。
		 o RGBImageFilter
		   標準のRGBカラーモデルを使った単純なフィルタを作るのを助けるクラス
		   です。 これもまたabstractクラスで、filterRGBという メソッドを実装
		   することで簡単にフィルタを作成できます。
		 o ReplicateScaleFilter*
		   最も単純な方法で画像を拡大縮小します。

	* java.awt.peer

	  動作環境に依存する部分とJavaを結びつけます。本書の範囲を越えているので
	  省略します。

	* java.io

	  Javaの国際化にともなって、従来のInputStreamやOutputStream に対応する
	  Unicodeストリームを扱う、Reader、Writerが 用意されました。

	  インターフェイス

		o DataInput
		  マシンに依存しない形で情報をストリームから入力するためのインターフ
		  ェイス。 Javaにおける様々な型の変数へ、直接読みこむことができる。
		o DataOutput
	      DataInputの逆、出力するためのインターフェイス。
	    o Externalizable*
	      VM外部から読みこんだり、VM外部に保存したりできるクラスのための
          インターフェイス。
        o FilenameFilter
          名前で指定するファイル名がディレクトリに存在するかどうかを調べる。
        o ObjectInput*
          Javaのオブジェクトをストリームから読みこむためのインターフェイス。
        o ObjectInputValidation*
		  ストリームから読みこんだオブジェクトを有効にします。
        o ObjectOutput*
          Javaのオブジェクトをストリームに書きだすためのインターフェイス。
        o Serializable*
          JDK1.1から、オブジェクトをバイト列にして(シリアライズするという)送
          信したり 受信したりするAPIが増えましたが、そのようなことが可能であ
          るクラスを作るには、 そのクラスはSerializableをimplementsしなけれ
          ばなり ません。

     クラス

        o BufferedInputStream
          読みこみをバッファリングしてくれます。それによって読みこみのパフォ
          ーマンスが 上昇します。JDK1.0.2では、ブロッキングしないというバグ
          がありました。
        o BufferedOutputStream
          書きこみをバッファリングします。書きこみのパフォーマンスが上昇しま
          す。
        o BufferedReader*
          バイト列ではなく、Unicodeの文字列を読みこみます。Javaの国際化にと
          もなって 生まれました。
        o BufferedWriter*
          Unicodeの文字列を書きこみます。
        o ByteArrayInputStream
          すでにあるバイト列を材料にして、そのバイト列のデータが入力のデータ
          に なっているようなストリームを作りだします。ストリーム関連のルー
          チンのデバッグ に使えます。read(),read(byte[],int,int)など、ストリ
          ームらしい ルーチンがそのまま使えます。
        o ByteArrayOutputStream
          バイト列に対して出力します。ひとしきり出力したら、 toStringや、
          toByteArrayなどのメソッドを使って データを得ます。
        o ByteToCharConverter*
          Unicode以外の文字フォーマット(JISやEUCなどでも)からUnicodeへの変換
          を 行ないます。
        o CharArrayReader*
          Char型の配列を基にして、Readerを作ります。
        o CharArrayWriter*
          Charの配列へデータを出力します。
        o CharToByteConverter*
          Unicode文字を他の文字コード(日本語だとJISやEUCなど)へ変換します。
        o DataInputStream
          Javaの基本型を直接にストリームから読みこむことができる便利な スト
          リームです。ネットワーク環境においても、書きこみと読みこみ が双方
          このメソッドを使うことによって、バイトオーダの異なる アーキテクチ
          ャ間でも安全に情報をやりとりできます。
        o DataOutputStream
          DataInputStreamと対をなす出力です。
        o File
          このクラスは、Javaの中での一般的なファイル名(絶対または相対パスも
          含む) から、それぞれの動作環境に対応したファイル名への変換を行ない
          ます。 JDK1.1においてはまだ完全に実装されてはいません。使う時は調
          査してから にしてください。
        o FileDescriptor
          標準出力や標準入力などをファイルのように扱うためのクラスです。 フ
          ァイルへの出力を標準出力に振りかえたりすることができます。
        o FileInputStream
          ファイルからの入力です。ブラウザ上で動作しているアプレットからは使
          えません。 appletviewerを使う場合でも、propertiesの項目で設定が必
          要です。
        o FileOutputStream
          ファイルからの出力です。FileInputStreamと同じく、アプレットで 使う
          時は注意が必要です。
        o FileReader*
          ファイルからUnicode文字列を読みこみます。アプレットから使う時は注
          意が 必要です。(FileInputStreamの項目を参照)
        o FileWriter*
          ファイルへUnicode文字列を書きこみます。アプレットから使う時は注意
          が必要 です。
        o FilterInputStream
          InputSreamの上にかぶせることによって、InputStream の機能を拡張しま
          す。DataInputStreamや、BufferedInputStream などがこのクラスを
          extendsしています。自分で独自の便利なス トリームを作りたい場合はこ
          のクラスをextendsし、それぞれの メソッドをオーバーライドします。
        o FilterOutputStream
          FilterInputStreamと対をなす出力です。
        o FilterReader*
          Readerにかぶせることによってより高機能なReader を作ります。ちょう
          どInputStreamに対する FilterInputStreamの関係と同じです。日本語で
          言うなら、 文節をくぎって入力するとか、段落とかカギカッコに対応す
          る、全部カタカナ にするなどといった拡張が考えられます。
        o FilterWriter*
          Writerにかぶせることによってより高機能な Writerを実現します。
          FilterReaderと対をなす出 力です。
        o InputStream
          入力ストリームをあらわします。 ストリーム入力クラスはこのクラスを
          extendsします。abstract クラスです。このクラスで、基本的な読みこみ
          メソッドである
             + int read(int) 1文字読みこみます。返り値は0から255でエラーの場
               合は-1.
             + int read(byte[]) byteの配列に、配列の長さだけ読みこみます。
             + int read(byte[],int ofs,int len) byte[]の配列に、始めの位置と
               長さを指定して読みこみます。
             + close()ストリームを閉じます。
          などといったメソッドが実装されているのですが、わたしたちが使う段階
          では、 もっと上位のストリームクラスを使うので、オーバーライドされ
          た これらのメソッドを使うことが多いはずです。その場合でも上記のメ
          ソッドは基本的に 同じ使いかたができるようになっています。これらの
          メソッドは、実際に読みこみが終わるまで ブロック(ずっと待つ)しま
          す。
        o InputStreamReader*
          普通のストリームから、バイト列をUnicode文字列へ変換しながら読みこ
          みます。 このクラスは内部でByteToCharConverterを使います。
        o LineNumberInputStream
          JDK1.1においては、このクラスは「古めかしい」クラスであると宣言され
          ています。 行を数えながら入力するストリームです。JDK1.1以降では、
          次のLineNumberReader を使えというように指示されています。
        o LineNumberReader*
          行を数えながらUnicode文字列の入力をします。LineNumberInputStreamに
          置きかえられました。
        o ObjectInputStream*
          シリアライズされたJavaオブジェクトを読みだしてオブジェクトに戻しま
          す。 RMI(遠隔メソッド呼びだし)で使います。 ストリームからオブジェ
          クトを読みだすには、readObjectを 使います。
        o ObjectOutputStream*
          オブジェクトをシリアライズしてストリームに出力します。Serializable
          インターフェイスをimplementsしているクラスだけがこのクラスの
          writeObjectの引数として渡されることができます。
        o ObjectStreamClass*
          ストリームにできるクラスを表現します。このクラスは、ストリームにで
          きるクラスの名前と、 その番号を保持します。
        o OutputStream
          InputStreamと対をなす出力です。よく使うメソッドを説明します。
             + write(int) 一文字書きこみます。
             + write(byte[]) byteの配列をその長さだけ書きこみます。
             + write(byte[],int ofs,int len) byteの配列の指定した位置から 指
               定した長さだけ書きこみます。
             + close() ストリームを閉じます。
          これらのメソッドは、実際に書きこみが終了するまでブロック(ずっと待
          つ)し ます。
        o OutputStreamWriter*
          InputStreamReaderと対をなす出力です。 write(char[],int ofs,int
          len)というメソッドを使って Unicodeの文字列を書きこむと、それが
          CharToByteConverterに 通され、別な文字フォーマットのバイト列として
          出力されます。
        o PipedInputStream
          PipedOutputStreamにつないで使います。 スレッド間の情報のやりとりに
          使うことが多いです。複数のスレッドが錯綜す るようなプログラムの場
          合、ストリームであることの特徴を生かして、 動作を同期させるために
          使うことができます。
        o PipedOutputStream
          PipedInputStreamとつないで使います。
        o PipedReader*
          Unicode文字列版のPipedInputStreamです。
        o PipedWriter*
          Unicode文字列版のPipedOutputStreamです。
        o PrintStream
          JDK1.1においては、このクラスは「古めかしい」ものとして宣言されてい
          ます。 デバッグのためと、従来との互換性を保つために残されているだ
          けです。 このかわりに、PrintWriterを使います。よく使う(使った)メソ
          ッドは 次のようなものがあります。
             + print(何でも) 引数のオブジェクトを文字列の形にしてストリーム
               に出力します。
             + println(何でも) printと同じですが改行文 字が付加されます。
          pintlnが呼びだされるまではブロックします。
        o PrintWriter*
          Unicodeに対応しています。 PrintStreamで実現されていたメソッドはす
          べて移植されています。 PrintStreamと同じように使えます。 printlnが
          呼びだされるまではブロックします。
        o PushbackInputStream
          ストリームを使っているとデータを先読みしたい場合がよく出てきます。
          例えば、 一行の長さを先に知りたいとか、実数か整数かを判別したいと
          かといった場合です。 ストリームは通常一方向の流れなのでそういう場
          合困るのですが、 このクラスを使うと、データを戻す(プッシュバック)
          ことができます。つまり、先に読んだデータを もう一度戻すことによっ
          て、先読みを実現するわけです。そのときに使う メソッドは：
             + unread(int) 一文字戻します。
             + unread(byte[]) byteの配列の長さ分だけ戻します。
             + unread(byte[],int ofs,int len) byteの配列の 始めの位置と長さ
               を指定して戻します。
          その性質と必要上、PushbackOutputStreamはありません。
        o PushbackReader*
          Unicode文字単位のプッシュバックをするクラスです。
             + unread(int)一文字を戻します。
             + unread(char[]) char配列の長さだけ戻します。
             + unread(char[],int ofs,int len) char配列中の位置の長さを指定し
               て 戻します。
        o RandomAccessFile
          好きな位置をアクセスできるファイルを開きます。開くにはコンストラク
          タでファイル名または Fileクラスを指定します。ファイルにアクセスす
          るので、アプレットで使う 時には注意が必要です。
             + RandomAccessFile(File,String mode) Fileを指定します。
             + RandomAccessFile(String,String mode) ファイル名を指定します。
          modeには、"r"(読みこみのみ) または"rw"(読み書きできる)を指定しま
          す。 アクセスするには次のメソッドをよく使います。
             + seek(long) ファイルの指定した位置にアクセスポイントを移動しま
               す。以降の 読み書きはここから始まります。
             + read(),read(byte[]),read(byte[],int,int),readInt(),....
               InputStreamやDataInputStreamで実現されている メソッド群が揃え
               られています。
             + write(int),write(byte[]),write(byte[],int,int),writeInt(int),....
               など、OutputStreamやDataOutputStreamで実現されている メソッド
               群が揃えられています。
             + close()オープンしているファイルを閉じます。
        o Reader*
          Unicode文字列のストリームを読みこむクラスがextendsする abstract ク
          ラスです。自分でUnicode対応の別なストリームクラスを作りたい時はこ
          の クラスをextendsして、メソッドを実装します。
        o SequenceInputStream
          複数のストリームを連続して扱いたい時に使うクラスです。アプレットで
          はあ まり必要ではありませんが、アプリケーションで、引数として与え
          られた多く のファイルを連続で統一的に処理したい場合は多いもので
          す。ある一つの ストリームが終わりになると、次のストリームにスイッ
          チします。サンプルプ ログラムを示します。実行してみると働きは一目
          瞭然です。

          import java.util.*;
          import java.io.*;
          class hoge {
              public static void main(String args[] ){
                  try{
                      FileInputStream f1 = new FileInputStream("aho.txt");
                      FileInputStream f2 = new FileInputStream("hoge.txt");
                      Vector v = new Vector();   // まずVectorを作る
                      v.addElement( f1 );
                      v.addElement( f2 );
                      v.addElement( System.in ); // こんなのを加えてもよい。
                      Enumeration enum = v.elements();
                      SequenceInputStream sin = new SequenceInputStream( enum );
                      while(true) System.out.print( (char) sin.read() );
                  }catch( Throwable t ){  System.out.println( t );   }
              }
          }

        o StreamTokenizer
          ストリームからの入力を、トークンごとに切りわける助けをするクラスで
          す。
        o StringBufferInputStream
          JDK1.1においては、このクラスは「古めかしい」と宣言されています。こ
          の代 わりに、次項のStringReaderを使うべきだとされています。 文字列
          をストリームとして使えるようにします。
        o StringReader*
          Unicode文字列(String)を情報源とするストリームを作ります。
        o StringWriter*
          Unicode文字列に出力するストリームです。
        o Writer*
          Readerと対をなす出力です。Unicode文字列単位の出力を実現し ます。
          abstractクラスなので、このクラスをextends するには、少なくても
          write(char[],int,int)とflush()とclose() を実装しなくてはなりませ
          ん。

     例外

        o CharConversionException*
          文字列を変換するときの例外です。
        o ConversionBufferFullException*
          変換する時に使うバッファが足りなくなりました。
        o EOFException
          入力の最中に、ファイルの終わりに達っしてしまいました。
        o FileNotFoundException
          ファイルが見つかりませんでした。
        o IOException
          入出力をしようとした時、もしくは最中に例外が発生しました。 他の
          java.io例外の基礎になる例外。
        o InterruptedIOException
          入出力に割りこみがかけられました。
        o InvalidClassException*
          オブジェクトをシリアライズする時に問題が発生しました。
        o InvalidObjectException*
          クラスがシリアライズされることを禁止している時にシリアライズしよう
          としました。
        o MalformedInputException*
          入力の文字フォーマットがおかしい。
        o NotActiveException*
          シリアライズの機能が働かなくなっています。
        o NotSerializableException*
          シリアライズしようとしているクラスがSerializableインター フェイス
          をimplementsしていない。
        o ObjectStreamException*
          シリアライズ関連の例外の基礎になる例外。
        o OptionalDataException*
          readObjectが発生する例外。
        o StreamCorruptedException*
          オブジェクトストリームの一貫性検査にひっかかりました。
        o SyncFailedException*
          ストリームをsyncしようとした時の例外です。
        o UTFDataFormatException
          DataInputStreamのreadUTF()が投げます。
        o UnknownCharacterException*
          文字コードが異常です。
        o UnsupportedEncodingException*
          要求されている文字フォーマットはサポートされていません。
        o WriteAbortedException*
          他のシリアライズ関連の例外が書きこみ中に発生している時に読みこんで
          いる場合、投げられます。

   * java.lang

     Javaの基本となるクラス群です。ともかくもこのパッケージがないと始まりま
     せん。 ということで、このパッケージだけはimportしなくてもよいようになっ
     ています。

     インターフェイス

        o Cloneable
		Cloneableなオブジェクトは、コピーしたりclone()したりすることができ
		ます。
        o Runnable
		Threadのサブクラスを作らずに、スレッドを作ることができます。
	 	public void run()をオーバーライドし、そのメソッドの中にスレッドとして
		実行させたいコードを書きます。Thread.sleep()することを忘れずに！

     クラス

        o Bignum*
		桁数が可変な数です。非常に大きな値を扱うことができます。
        o Boolean
		基本型booleanのラッパークラス。メソッドに対してbooleanへの参照を
		渡したい時に使います。
        o Byte*
		基本型byteのラッパークラス。
        o Character
		基本型charのラッパークラス。
        o Class
		VM上に存在するクラスの実行時表現を保管しているクラスです。それぞれの
		クラスの名前その他の情報を得たい時に使えます。
        o ClassLoader
		ファイルやネットワークからVMにクラスをロードする時に、ロードする方法
		を定義するクラスです。
        o Compiler
		コンパイラ。
        o Double
		基本型doubleのラッパークラス。
        o Float
		基本型floatのラッパークラス。
        o Integer
		基本型intのラッパークラス。
        o Long
		基本型longのラッパークラス。
		o Math
		標準数学ライブラリ。すべてのメソッドや変数がstaticなので、インスタンス
		を作ることはできません。ゲームプログラムでよく使うメソッドを挙げます。
		* Math.abs(x)  絶対値を求めます。どんな型でも使えます。
		* double Math.sin(double)  sinを求めます。引数はradで、返り値は-1から1.
		* double Math.cos(double)	cosを求めます。
		* double Math.atan(double)	アークタンジェント。返り値は±π/2です。
		* Math.min(a,b)	小さい方を返します。どんな型でも使えます。
		* Math.max(a,b)	大きい方を返します。
		* double Math.sqrt(double)	平方根を返します。
		* double Math.tan(double)	タンジェントを返します。引数はラジアンです。
		* double Math.random()		0.0から1.0の間の乱数を返します。
		o Number
		数値をあらわす全てのクラスのスーパークラスです。
        o Object
		すべてのクラスのスーパークラスです。クラスの定義の時にextends Objectを
		省略すると、自動的にextendsします。
        o Process
		Javaから起動している他のプロセスに関する情報や、標準出力/標準入力など
		を得ることができます。他のプロセスは、java.lang.Runtime.exec()を使って
		起動することができます。
        o Runtime
		JavaのVMの動作状況に関する情報を得たり、操作したりします。
		* Runtime.exec(String,String[]) 他のプロセスを引数つきで起動する
		* Runtime.exit(int) システムを終了する
		* Runtime.freeMemory() 空きメモリ量を得る
		* Runtime.totalMemory() 全使用メモリ量を得る
		* pRuntime.gc() ガベージコレクタを起動する
        o SecurityManager
		VMにクラスがロードされる時にチェックを行ないます。
        o Short*
		基本型shortのラッパークラス。
        o String
		文字列型。よく使うコンストラクタ・メソッドには次のようなものが
		あります。
		* String(byte[])		バイト列から文字列を作る
		* String(byte[],int ofs,int len) バイト列の指定した位置から文字列を作る
		* String(byte[],int HB,int ofs , int len ) (JDK1.0のみ)
		* String(char[])		char型の配列から文字列を作る
		char charAt( int index) (index-1)文字目の文字を返します。
		* void getChars(int srcBgn,int srcEnd,char carray[],int begin)
		文字列から、char型の配列を取りだします。
		* void getBytes( int srcBgn,int srcEnd, byte barray[] , int begin)
		文字列から、byte型の配列を取りだします。(1.0のみ)
		* byte[] getBytes() 文字列から配列を取りだすのには、これが最も
		便利でしょう。このメソッドを呼びだす前にnew byte[..]しておく必要は
		ありません。
		* int indexOf(int ch)指定した文字が最初に現れる位置を返します。
		* int lastIndexOf( int ch ) 最後に現れる位置を返します。
		* String substring( int begin,int end ) 部分的な文字列を返します。
		* String toLowerCase() 全て小文字にします。

		* Stringを使う時には、
		*StringIndexOutOfBoundsException に気をつけましょう。
	
        o StringBuffer
		Javaでは文字列を足し算できますが、それを実現するためのクラスです。
		コンパイラが活用する程度で、直接に使うことはないでしょう。
        o System
		VMが動作している環境に依存しない、システム機能を提供します。
		よく使う変数、メソッド：
		* System.out   標準出力
		* System.in    標準入力
		* System.err   標準エラー出力
		* System.arraycopy(Object src,int sbgn,Object dest,int dbgn, int len)
		高速配列コピー。ArrayIndexOutOfBoundsException,ArrayStoreException.
		* System.currentTimeMillis() ミリ秒単位で現在の時間を調べます。重宝。
		* System.exit(int code);		Java VM全体の実行を終了します。
		* System.gc()  ガベージコレクタを実行します。
		* System.getProperty(String name) システムの設定を得ます。
		o Thread
		複数同時に実行されうる、一連の処理の流れです。スレッドを新しく作るには
		* Thread( Runnable )のようにします。
		* Thread.sleep(long millisec)	ミリ秒を指定して、その間他のスレッドを
		実行します。
		* start()		起動します。
		* stop()		止めます。
		* run()		それぞれのスレッドの実体です。
		* interrupt() 割りこみます。
        o ThreadGroup
		スレッドをグループ化します。
        o Throwable
		例外やエラーなど、throwできるオブジェクトはすべて、このクラス
		をextendsします。
		* printStackTrace()    スタックの状態を表示します。
        o Void*
		基本型voidを意味するクラスへの参照を作ることができます。

     例外

        o ArithmeticException
		0で割り算しました。
        o ArrayIndexOutOfBoundsException
		配列の要素番号の範囲を越えました。
        o ArrayStoreException
		配列に、間違った型のオブジェクトを保存しようとしました。
        o ClassCastException
		キャストできない型にキャストしようとしました。
        o ClassNotFoundException
		クラスが見つからなかった(ので、読みこめませんでした。)
        o CloneNotSupportedException
		そのクラスは、clone()することができませんでした。
        o Exception
		普通のプログラムによってtry〜catchされるべき例外です。(Errorは、
		try〜catchされるべきだとは指示されていません。)
        o IllegalAccessException
		メソッドが見つかりません。
        o IllegalArgumentException
		引数が異常です。
        o IllegalMonitorStateException
		モニタが有効でない時に使用しようとしました。
        o IllegalStateException*
		メソッドを、使用するべき時でないのに使用しようとしました。
        o IllegalThreadStateException
		スレッドに対する特定の操作が使用できない時に、使用しようとしました。
        o IndexOutOfBoundsException
		配列その他の、インデクスが範囲を越えました。
        o InstantiationException
		abstractクラスやインターフェイスをインスタンス化しようとしました。
        o InterruptedException
		スレッドに対して割りこみが発生しました。
        o NegativeArraySizeException
		配列のサイズが負です。
        o NoSuchFieldException*
		指定された名前の変数は、このクラスには存在しません。
        o NoSuchMethodException
		指定された名前のメソッドは、このクラスには存在しません。
        o NullPointerException
		ヌル参照に対してアクセスしようとしました。
        o NumberFormatException
		文字列から数値に変換できない形式の文字列でした。
        o RuntimeException
		Java VMの実行中に起こる可能性のある例外のスーパークラス。
        o SecurityException
		セキュリティ違反。
        o StringIndexOutOfBoundsException
		文字列の文字数の範囲を越えた操作が行なわれました。

     エラー

        o AbstractMethodError
		abstractなメソッドを呼びだそうとしました。
        o ClassCircularityError
		クラスを初期化する時に、再帰的な構造になっていることがわかりました。
        o ClassFormatError
		読みこもうとしているクラスの形式がおかしい。
        o Error
		実行中に、本来起こるべきでない事が起こったことを意味する例外です。
		普通のプログラムは、Errorをtry〜catchしようとしてはいけません。
        o ExceptionInInitializerError*
		イニシャライザでエラーが発生しました。
        o IllegalAccessError
		アクセス例外
        o IncompatibleClassChangeError
		互換性のないクラス変更が発生した。
        o InstantiationError
		インタプリタが、abstractなクラスまたはinterfaceをインスタンス化し
		ようとした。
        o InternalError
		内部エラー。
        o LinkageError
		他のクラスに依存性があるクラス群の互換性がなくなった。
        o NoClassDefFoundError
		クラスがみつからなかった。
        o NoSuchFieldError
		特定のフィールド(変数)がみつからなかった。
        o NoSuchMethodError
		特定のメソッドが見つからなかった。
        o OutOfMemoryError
		メモリ不足
        o StackOverflowError
		スタック溢れ
        o ThreadDeath
		thread.stop()が呼びだされた。
        o UnknownError
		不明な、しかし重大なエラーが発生した。
        o UnsatisfiedLinkError
		不良なリンク。
        o VerifyError
		クラスの内容チェック時エラー。
        o VirtualMachineError
		仮想マシン(VM)が壊れているか、資源を使い果した。

   * java.lang.reflect*

	クラスやメソッド自体を扱うためのパッケージです。配列オブジェクトの
	インスタンスを直接作ったり、クラスからメソッドを抽出したりできます。
	プログラムが実行中に変化していくような効果を出せます。敵のアルゴリズム
	が変化していくとか、ゲームにも応用ができそうです。Methodクラスにいたっ
	ては、Cでいう関数ポインタのように使えます。

     インターフェイス

        o Member*
		あるクラスのメンバー(変数あるいはメソッド)またはコンストラクタであ
		るということを規定するインターフェース。

     クラス

        o Array*
		配列オブジェクト自体を操作します。例えば次のふたつのコードは同じ
		意味です。
		1) String sa[] = new String[20];
		2) String sa[] = Array.newInstance( new String().getClass(), 20 )

        o Constructor*
		それぞれのクラスのコンストラクタを表します。Constructorのインスタンス
		からは、引数や修飾子など、色々な情報が引きだせます。インスタンスを
		作ることもできます。(newInstance)
		1) Class cl = new String().getClass();
		2) Constructor ccc[] = cl.getConstructors();
		3) Class ptypes[] = ccc[0].getParameterTypes();
        o Field*
		それぞれのクラスのフィールド変数をあらわします。使いかたはConstructor
		とほぼ同じです。
        o Method*
		それぞれのクラスのメソッドをあらわします。
        o Modifier*
		それぞれのクラスやフィールド、メソッド、などの修飾子を識別するため
		のメソッドを含んでいます。
		例えば、Stringクラスがfinalかどうかは、次のように
		して調べることができます。
		1) Class cl = new String().getClass();
		2) boolean fflg = Modifier.isFinal( cl.getModifiers() );
	

     例外

        o InvocationTargetException*
		メソッド呼びだしの対象オブジェクトが、違法なものだった。


   * java.net

     ネットワーク機能を実現するパッケージです。JDK1.1では例外が細かく 分けら
     れたのと、マルチキャストが可能になったこと、Socket クラスがfinalではな
     くなったことが重要な変化でしょうか。

     インターフェイス

        o ContentHandlerFactory
		適切なContentHandlerを呼びだしてURLConnectionからの入力を
		変換する助けをします。

        o FileNameMap*
		ファイル名と、MIMEタイプの間のシンプルな対応付けをするための
		インターフェース。

        o SocketImplFactory
		SocketImplのインスタンスを様々な方法で作るためのインターフェース。

        o URLStreamHandlerFactory
		URLクラスは、プロトコルの種類によって様々なURLStreamHandlerを作成するが、
		そのために使用されます。

     クラス

        o ContentHandler
		URLConnectionからの入力をオブジェクトに変換するためのクラス。

        o DatagramPacket
		パケットの長さ、内容、IPアドレス、ポートの番号を備えたパケット。
	
        o DatagramSocket
		情報の欠損が生じるかもしれないデータグラムパケットの通信路を表します。
		* DatagramSocket( in port ) コンストラクタ
		* void send( DatagramPacket p )		送信
		* void receive( DatagramPacket p )	受信
		* void close()		閉じる

        o DatagramSocketImpl*
		データグラムソケットとマルチキャストソケットの実装のための
		基本クラス。

        o HttpURLConnection*
		HTTPの特徴に対応したURLConnection。

        o InetAddress
		一つのインターネットアドレス(IPアドレス)を表すクラス。
		* byte[] getAddress()  4バイトのIPアドレスを、ネットワークバイト
		オーダで得ます。
		* InetAddress.getByName(String) ホスト名からIPアドレスを得ます。

        o MulticastSocket*
		IP上でマルチキャストメッセージを送ったり受けとったりします。現在は、
		アプレットからは、このソケットを使えません。
		* MulticastSocket( int port )		コンストラクタ。
		* send( DatagramPacket, byte ttl)  送信します。
		
        o ServerSocket
		サーバーのソケットを表すクラス。
		* ServerSocket( int port )	コンストラクタ。

        o Socket
		クライアントのソケットを表すクラス。実際のソケット操作には、SocketImpl
		クラスを使っています。
		* Socket(String hostname , int port ) ソケットを作成します。
		クライアントからソケットを開いて、入出力を開始するには次の手順を
		踏みます。
		1) Socket so = new Socket( hostname , port );
		2) OutputStream out = so.getOutputStream();
		3) InputStream in = so.getInputStream();
		4) .....処理
		5) so.close();

        o SocketImpl
		Socket,ServerSocketの実際の操作は、このクラスによって行なわれます。

        o URL
		WWW上の資源を一意に特定できるオブジェクトです。定数であり、一旦作成
		されると、変更はできません。
		* URL(String urlstring) (MalformedURLException) コンストラクタ。 
		* Object getContent() (IOEx)  URLで指定される情報の種類に応じて、
		Imageなどのオブジェクトに変換します。
		* URLConnection openConnection() (IOEx)
		URLクラスを使って、あるサイトの情報を得るには、次の手順を踏みます。
		1) URL url = new URL(...);
		2) URLConnection uc = url.openConnection();
		3) uc.setDoInput();   // 出力する場合はuc.setDoOutput()
		4) InputStream in = uc.getInputStream();
		5) in.close();

        o URLConnection
		URLによって示されるオブジェクトへのアクティブな接続を表します。
		* getContent() URLによって示されるオブジェクトの内容を得ます。

        o URLEncoder
		普通の文字列を、 x-www-form-urlencodedフォーマットに変換します。
		* String URLEncoder.encode( String )   変換します。
		
        o URLStreamHandler
		URLのストリームを開くためのabstractクラス。

     例外

        o BindException*
		ポートが使用中であるとか、アドレスがおかしい、という理由により、バインド
		できなかった。
        o ConnectException*
		リモートのアドレスとポートに接続できなかった。相手のポートはlistenされて
		いなかった。
        o MalformedURLException
		URLの表記に誤りがあった。 new URL( String..)する時に発生します。引数の
		文字列をチェックしましょう。
        o NoRouteToHostException*
		接続先までの間にあるルータが落ちているか、もしくは、ファイアウォールに
		よって接続が拒否されたため、到達できなかった。
        o ProtocolException
		プロトコル例外。Socketクラスで発生。
        o SocketException
		ソケットを使おうとした時に何らかたの例外が生じた。
        o UnknownHostException
		アドレスからIPアドレスを得ることができなかった。
        o UnknownServiceException
		不明なサービスを使用しようとした。

   * java.rmi*

     オブジェクトシリアライズを基盤とする、「遠隔メソッド呼びだし」を実現す
     る パッケージです。他のバーチャルマシンに存在するオブジェクトのメソッド
     を、 その「代理」を介することによって呼びだします。そのためにはサーバー
     に 関連する情報を登録しておく必要があります。それらのことをするためには
     別の java.rmi.registryや、java.rmi.serverなどといった パッケージを使う
     必要があります。

     インターフェイス

        o Remote*
		オブジェクトが、リモートに存在することを指示するインターフェース。
		リモートオブジェクトは、すべてこのインターフェースをimplementsしなけれ
		ばなりません。

     クラス

        o Naming*
		URLによって示されるリモートオブジェクトへの参照を得るために使われます。
        o RMISecurityManager*
		リモートからロードされるスタブクラスは、RMISecurityManagerを通さない
		限りはロードされません。クライアントのmain()メソッドに、
		System.setSecurityManager( new RMISecurityManager());
		の一行を加えればOKです。


     例外

        o AccessException*
		リモートオブジェクトのアクセス例外。
        o AlreadyBoundException*
		リモートオブジェクトがすでにバインドされていた。
        o ConnectException*
		クライアント->サーバの接続に関する例外。
        o ConnectIOException*
		クライアント->サーバの接続に関する例外。
        o MarshalException*
		シリアライズ時の例外
        o NoSuchObjectException*
		そのようなオブジェクトはない。
        o NotBoundException*
		lookup()した時に名前がバインドされていなかった。
        o RMISecurityException*
		セキュリティチェックにひっかかった。
        o RemoteException*
		RMIレジストリに接続できなかった。
        o ServerError*
		サーバーエラー。
        o ServerException*
		サーバーで未知の例外が発生した。
        o ServerRuntimeException*
		サーバーの実行時エラー。
        o StubNotFoundException*
		スタブクラスが見つからない。
        o UnexpectedException*
		予期せぬ例外。
        o UnknownHostException*
		ホスト名からアドレスを辿れない。
        o UnknownServiceException*
		未知のサービスを使用しようとした。
        o UnmarshalException*
		シリアライズ時の例外

   * java.rmi.dgc*

     ネットワーク上にはたくさんのJavaバーチャルマシンが存在しますが、それら
     を 統一的なIDで管理し、ガベージ・コレクション(メモりのごみあつめ)をする
     ためのパッケージです。サーバ側で操作します。RMIを使うだけなら、通常は
     このパッケージは使いません。説明は省略します。

     インターフェイス

        o DGC*

     クラス

        o Lease*
        o VMID*

   * java.rmi.registry*

     ネットワークを介してJavaのアプリケーションサーバーと接続するには、 レジ
     ストリに登録しておく必要があります。このパッケージは登録とオブジェ クト
     探しの処理をするために使われます。RMIを使うだけなら、このパッケージは使
     いません。説明は省略します。

     インターフェイス

        o Registry*
        o RegistryHandler*

     クラス

        o LocateRegistry*

   * java.rmi.server*

     RMIのアプリケーションサーバーを作る時に使います。

     インターフェイス

        o LoaderHandler*
		RMIクラスローダを扱うためのインターフェース。
        o RMIFailureHandler*
		サーバ・クライアントの接続ができなかったときの動作を規定するための
		インターフェース。
        o RemoteCall*
		リモートオブジェクトの呼びだしを実装するためのインターフェース。
        o RemoteRef*
		リモートオブジェクトへの参照を表します。
        o ServerRef*
		リモートオブジェクトのサーバ側の参照を表します。
        o Skeleton*
		rmicによって作られるスケルトンクラスは、すべてこのインターフェースを
		impelementsします。サーバ側のスケルトンは、リモートオブジェクトへの
		呼びだしを実際に送信します。
        o Unreferenced*
		リモートオブジェクトへの参照がなくなったときに、その通知を受けとる
		ことができるように、リモートオブジェクトは、このインターフェースを
		implementsしておくべきです。

     クラス

        o LogStream*
		RMIを使ったシステムのデバッグに使います。
        o ObjID*
		VM内で、時間を経ても一意にオブジェクトを特定できるIDです。
        o Operation*
		Javaのメソッドの記述を保持します。
        o RMIClassLoader*
		ネットワークを通じてクラスをロードする機構を提供します。
        o RMISocketFactory*
		RMI呼びだしを実現するための、クライアント・サーバー接続を実現するために
		使われます。
        o RemoteObject*
		リモートオブジェクトが、java.lang.Objectのような振舞いができるように
		するためのクラスです。
        o RemoteServer*
		リモート参照を提供するための枠組を提供します。サーバーを実装するには、
		このクラスをextendsします。
        o RemoteStub*
		クライアントのスタブクラスの一般的なスーパークラスです。スタブとは、
		リモートオブジェクトと全く同一な代理です。
        o UID*
		あるホスト上で唯一なIDを作ります。唯一にするために、時間の情報
		が使われます。
        o UnicastRemoteObject*
		サーバが行きている間だけ有効な、ただひとつしかないリモートオブジェクト
		を定義します。
				

     例外

        o ExportException*
		exportできなかった。
        o ServerCloneException*
		サーバが多重化しています。
        o ServerNotActiveException*
		サーバがアクティブではありません。
        o SkeletonMismatchException*
		スケルトンとリモートオブジェクトの対応がとれていません。
        o SkeletonNotFoundException*
		スケルトンクラスが見つかりません。
        o SocketSecurityException *
		セキュリティ例外。

   * java.security*

     このパッケージは、パスワードや企業の情報管理など、より高度な セキュリテ
     ィ機能が必要なアプリケーションを開発するために使われます。 JDK1.1のベー
     タ版ではまだ実装が不完全です。このパッケージの内容は、	
     本書の内容からは外れているため、説明を省略します。

     インターフェイス

        o Certificate*
        o KeyParams*
        o Principal*

     クラス

        o DigestInputStream*
        o DigestOutputStream*
        o Identity*
        o IdentityScope*
        o Key*
        o KeyPair*
        o MessageDigest*
        o PrivateKey*
        o Provider*
        o PublicKey*
        o SecureRandom*
        o Security*
        o Signature*
        o Signer*

     例外

        o DigestException*
        o InvalidKeyException*
        o InvalidParameterException*
        o KeyException*
        o KeyManagementException*
        o NoSuchAlgorithmException*
        o NoSuchProviderException*
        o ProviderException*
        o SignatureException *

   * java.security.acl*

     java.securityと同様の理由で、省略します。

     インターフェイス

        o Acl*
        o AclEntry*
        o Group*
        o Owner*
        o Permission*

     クラス

     例外

        o AclNotFoundException*
        o LastOwnerException*
        o NotOwnerException *

   * java.security.interfaces*

     java.securityと同様の理由で、省略します。

     インターフェイス

        o DSAKey*
        o DSAParams*
        o DSAPublicKey*

   * java.sql*

     javaアプリケーション/アプレットが、非常に有用なデータベースアクセス端末
     になりうる ことが研究によって明らかになってきたことから開発されたパッケ
     ージです。メソッド 一発でSQLのデータベースサーバにアクセスすることがで
     きます。これを使えば ゲームも作ることができるかもしれませんが、サーバの
     管理やプロトコルなどの 説明が必要でそれは本書の範囲を越えてしまいます。
     したがって説明は省略します。

     インターフェイス

        o CallableStatement*
        o Connection*
        o DatabaseMetaData*
        o Driver*
        o PreparedStatement*
        o ResultSet*
        o ResultSetMetaData*
        o Statement *

     クラス

        o Date*
        o DriverManager*
        o DriverPropertyInfo*
        o Time*
        o Timestamp*
        o Types*

     例外

        o DataTruncation*
        o SQLException*
        o SQLWarning *

   * java.text*

     国際化された文字列を扱うためのパッケージです。本書の内容と関連が薄い
	 ので、説明は省略します。

     インターフェイス

        o CharacterIterator*

     クラス

        o ChoiceFormat*
        o CollatedString*
        o Collation*
        o CollationElementIterator*
        o CollationKey*
        o DateFormat*
        o DateFormatData*
        o DecimalFormat*
        o Format*
        o FormatStatus*
        o MessageFormat*
        o NumberFormat*
        o NumberFormatData*
        o ParseStatus*
        o SimpleDateFormat*
        o SortKey*
        o StringCharacterIterator*
        o TableCollation*
        o TextBoundary*

     例外

        o FormatException*

   * java.util

     他のパッケージには区別できないような、それでいて必要なクラス群が 含まれ
     ています。JDK1.1では国際化やイベント関連でかなり拡張されました。

     インターフェイス

        o Enumeration
		一組の値を並べたり、数えたりするためのメソッドを定義するイン
		ターフェースです。
		* boolean hasMoreElements()  次の要素が存在するかどうかを調べます。
		* Object nextElement()		次の要素を取りだします。
        o EventListener*
		全てのイベントリスナは、このインターフェースをextendsします。
        o Observer
		このインターフェースをimplementsすると、Observerによって監視できる
		ようになります。

     クラス

        o BitSet
		一組のビットのセット。必要に応じてサイズは伸びていきます。
        o Calendar*
		Dateオブジェクトと、年や月、日をあらわすint値との間の変換を行ないます。
		変換はさまざまなフォーマットを指定することができます。HTML版のオン
		ラインマニュアルに詳しいので、そちらを参照してください。
        o Date
		ミリ秒の単位で、時間を管理します。
        o Dictionary
		Hashtableのスーパークラスです。
        o EventObject*
		イベントをあらわすオブジェクトです。java.awt.eventの下のイベント群も、
		すべてこのオブジェクトをextendsしています。
		o GregorianCalendar*
		Calenderをextendsしています。グレゴリアン暦を使用してDateから変換します。
        o Hashtable
		便利なハッシュ・テーブルです。巨大な文字列の配列同士の比較をする場合
		などには、一旦ハッシュテーブルを作ると高速に処理することができます。
        o ListResourceBundle*
		言語間の特定の文字列の対応のリストを定義するクラスです。
        o Locale*
		国際化メソッドで使用する言語の名前です。
        o Observable
		Model-Viewパラダイムにおける、「観察されるデータ」は、このクラスを
		extendsします。データは自分自身が変化したことを、Observerで定義されて
		いるupdateメソッドを呼びだすことによって、知らせます。
        o Properties
		ストリームでセーブ/ロードできるハッシュテーブル。
        o PropertyResourceBundle*
		ストリームに保存したりロードしたりできるリソース。
        o Random
		乱数発生器。いつも同じ乱数列を発生させたい場合は、 new Random( 100);
		というように、long値を指定します。インスタンスが必要です。
		1) Random r = new Random(n);
		2) r.nextInt();   int値の最大値から最小値まで、負も含みます。
		
        o ResourceBundle*
		複数の言語に対応したプログラムを作りやすくするためのクラスです。言語に
		応じた一組のオブジェクトにアクセスします。
        o SimpleTimeZone*
		グレゴリアン暦に沿った単純なタイムゾーンを生成します。
        o Stack*
		LIFO(Last-In-First-Out)のスタックオブジェクトです。

        o StringTokenizer
		文字列をトークンに分解します。CGIのプログラムをする時などには重宝する
		でしょう。デフォルトでは " \n\r\t"をトークン分割文字とします。
		1) StringTokenizer st = new StringTokenizer( "this is a test" ," " );
		2) String next = st.nextToken() ....連続的にこのメソッドを呼びだします。

        o TimeZone*
		値域による時差をあらわします。

        o Vector
		必要に応じて長さが伸びる配列です。たくさんの要素を挿入するときは、
		setSize(int)を先に実行したほうが高速です。典型的な使用例：
		1) Vector v = new Vector();
		2) v.addElement( Object);
		3) Enumeration enm = v.elements();

     例外

        o EmptyStackException
		スタックが空なのにpopしようとした。
        o MissingResourceException*
		指定されたリソースが存在しない。
        o NoSuchElementException
		そのような要素は存在しない。
        o TooManyListenersException *
		イベントリスナが多すぎる。

   * java.util.zip*

     zipやgzipに代表される、情報を圧縮するためのパッケージです。
	 JDK1.1beta2の段階では、多少バグがあるようです。
	基本的には、
	1) GZIPInputStream gin = new GZIPInputStream( new FileInputStream(..));
	2) gin.write( byte[],...);
	というようにすれば、GZIP圧縮されたファイルを読みこむことができます。
	(しかし、バグがあるようで、正しく読みこめません。)
	というように使います。詳しいパッケージの説明は省略します。

     インターフェイス

        o Checksum*

     クラス

        o Adler32*
        o CRC32*
        o CheckedInputStream*
        o CheckedOutputStream*
        o Deflater*
        o DeflaterOutputStream*
        o GZIPInputStream*
        o GZIPOutputStream*
        o Inflater*
        o InflaterInputStream*
        o ZipEntry*
        o ZipFile*
        o ZipInputStream*
        o ZipOutputStream*

     例外

        o DataFormatException*
        o ZipException*
