
付録A Java言語リファレンス

本文では、Javaの言語仕様のすべてについては説明しませんが、ここにJava 言語の
仕様とライブラリの機能の概略を掲載したいと思います。 一般的な解説の他、ゲー
ムにどのように応用するかについても解説します。 これらがゲーム作りの参考にな
ればなによりです。

言語仕様


1. 予約語

     予約語とは、Java言語において特別な意味を持つ単語で、クラスや メソッド、
     変数の名前には使えません。

      abstract        default         if              private         throw
      boolean         do              implements      protected       throws
      break           double          import          public          transient
      byte            else            instanceof      return          try
      case            extends         int             short           void
      catch           final           interface       static          volatile
      char            finally         long            super           while
      class           float           native          switch
      const           for             new             synchronized
      continue        goto            package         this


2. 名前

     名前とは、クラス、メソッド、変数の名前としてユーザーが使うことができる
     単語です。次の文字を使うことができます。

      ABCDEFGHIJKLMNOPQRSTUVWXYZ
      abcdefghijklmnopqrstuvwxyz
      0123456789$_

     最初の文字に数字を使うことはできません。
     例：
      int a, $hoge , _foo , Thank_You , Test001;

     ユニコードを使えば、もっと別な文字を使うこともできます(漢字も！)が、 こ
     こでは説明しません。(付録Dを参照)


3. コメント

     次の3種類があります。
      /*  複数行にまたがることが
          可能なコメント
      */
      /**  javadocが使う特別なコメント */
      // 行末までのコメント


4. リテラル

     リテラルとは、各種の数値や文字などのデータをプログラム中で直接記述 する
     単位のことです。以下の例では太字の部分です。

     例：
      int a = 808;
      String s = "state!";

     リテラルには、整数、小数、文字列、文字、真偽値リテラルがあります。

        o 整数リテラル

          整数リテラルは、10進数、16進数、8進数があります。
          808のように普通に数値を書くと10進数として扱われます。
          0808のように0で始めると、8進数として扱われます。
          0x808のように"0x"で始めると、16進数として扱われます。16進数は、 数
          字が16種類に足りないので、10から15を、a〜fまたはA〜Fで代用します。
          整数リテラルは無指定だとint型として扱われますが、末尾に"l"とか"L"
          が 付いている場合はlong型として扱われます。
          例:
           long c = 0xffff0000l;
           int a = 0xffff0000;

        o 小数リテラル

          3.14159とか 8080808.08080のように ピリオドを使って小数を書く他、
          3.11343345e-5のように、指数表現もできます。 末尾に何もつけないと
          double型になり、fまたはFをつけると float型になります。

        o 文字リテラル

          文字リテラルは、一文字をプログラム中に埋めこむときに使います。 通
          常はchar 型の変数に代入したり比較したりします。
          文字とは、通常文字(英数字と記号)とエスケープシーケンス(特殊機能文
          字) のことです。 エスケープシーケンスには、次のものがあります。

           表記           機能

           \b    バックスペース
           \t    タブ
           \n    改行
           \f    カーソルを一段下に移動
           \r    カーソルを行頭に戻す
           \"    "という文字を文字列に含める
           \\    \という文字を文字列に含める


           \0nnn nnnのところに8進数を指定して、000から 377までの文字コード
                 を直接指定する

           \unnnnnnnnのところに16進数4桁を指定して、 Unicodeを直接指定す
                 る。これを使用すると、アプレットで漢字を表示できる。

          例：

          'a'  '8'  '\f'  '\ua808'
          char c = '\u5004';

          理解を深めるために、次のプログラムを実行してみてください。
------------------------------------------------------------
public class hoge extends java.applet.Applet
{
	public void init()
	{
		char c = 'a';
		int i = 'a';
		System.out.println( c );
		System.out.println( i );
	}

}
------------------------------------------------------------

        o 文字列リテラル

          文字列をプログラム中に埋めこむときに使います。 文字列型(String)の
          変数に 代入します。Javaでは、文字列は "+"記号でどんどんつなげてい
          く ことができます。 エスケープシーケンスも含めることができます。
          以下の例では、sbとsc、sdは同じ内容が代入されます。 例：

          String sa = "Pacific state\n";
          int i = 808;
          String sb = "state " + i ;
          String sc = "state 808";
          String sd = "state " + "808";



5. 変数の型

     型とは、情報を記憶しておく時にメモリ上に置かれる様式のことです。 タイプ
     とも言います。 Java言語においては、型には、「基本型」と「参照型」があり
     ます。

     基本型

       1. 数値型

          基本型のうち数値型は、以下の表のものがあります。

------------------------------------------------------------
  型名   種類   wrapperクラス サイズ(bit)       最小値               最大値
   byte  整数       Byte         8               -128                 127
  short  整数      Short        16              -32768               32767
    int  整数    Integer        32            -2147483648          2147483647
   long  整数       Long        64    -9223372036854775808     9223372036854775807
  float  整数      Float        32  1.4013e-45(負でない最小)       3.40282e+38
 double  整数     Double        64         0(負でない最小)         1.79769e+308
------------------------------------------------------------

          それぞれの数値型には、最大値と最小値があり、それを越える値を代入し
          よう としたときには、値の変換が行われます。 値の変換は、整数型と浮
          動小数型で動作が異なります。 異なる型同士の代入では、型の変換をし
          てやる必要があります。 (キャストと言います。) ここで挙げている変換
          の例にあるように、 (byte)や(float) というように、変換後の型をカッ
          コでかこみます。 これがないと、コンパイル時にエラーになります。
          整数型の場合、範囲を越えるということは、 代入される変数よりもビッ
          ト幅の大きい型から、 ビット幅の小さい型への代入になります。例え
          ば、int型から、 byte型への代入などです。 この場合は、下位ビットだ
          けがコピーされます。 次の例では、byte型の変数bには、 0という値が入
          ります。

          byte b = (byte)256;

          浮動小数型の場合は、代入する値が範囲を越える場合は、 値Infが入りま
          す。「無限大」という意味です。 次のコードでは、標準出力にInfという
          文字列が 表示されます。負の無限大の場合、-Infと表示されます。

          float f = (float) 5.0e+100;
          System.out.println( f );

          それぞれの最大値や最小値は、次のようにして知ることができます。

          System.out.println( Integer.MAX_VALUE );
          System.out.println( Double.MIN_VALUE );

		ラッパー(wrapper)・クラスは、基本型の参照を渡したい時に使えます。

       2. 文字型

          文字型はcharだけです。 Javaの仮想マシンの内部では、16ビットの
          Unicodeで扱われます。 一文字を記憶します。

       3. 真偽値型

          型名はbooleanです。代入できる値は、true(真)と false(偽)の2種類のみ
          です。

     参照型

     基本型が、ただ一つの情報を記憶しておくためのものだったのに対し、 参照型
     は、ただ記憶しておく以外にも、さまざまな処理をさせることができます。 そ
     して、ユーザーは、新しいクラスを定義することによって、自由に新しい型を
     作りだすことができます。
       1. 文字列型( Stringクラス)
          文字列型は、Javaのパッケージに最初から入っているクラスの 一つで
          す。クラスなので、普通にコンストラクタを呼びだして 実体を作ったり
          もできるのですが、このStringクラスは 特別になっていて、文字列リテ
          ラルをいかにも クラスであるように使えます。次のようにします。

          String s1 = "808state";                                 // いきなり代入できる。
          String s2 = new String();                               //コンストラクタを呼べる。
          System.out.println( "how many characters?".length() );  // 長さを求めるメソッドを使える。
          System.out.println( s1.length() );                      // もちろんこうすることもできる。
          if( s1 == s2 )....                                      // 比較はこうする。

       2. クラス型(オブジェクト)
          クラス型の変数は、あるクラスのインスタンスです。 インスタンスとい
          うのは、 クラスの定義に従ってメモリ上に構築されたひとかたまりの情
          報です。 これをオブジェクトとも言います。 オブジェクトがどのような
          情報を持っているのか、 またどのようなメソッドを持っているのかは、
          クラスの定義によります。 宣言は次のようにします。

          MyClass c;

          宣言しただけでは、参照が作られるだけです。実体を作るためには、 new
          使います。

          MyClass c = new MyClass();      // コンストラクタ呼びだし

          このようにすることで、 MyClassクラスのインスタンスが作れます。

       3. 配列

          配列とは、同じ型のものを複数個連続して管理し、添字(index)で参照 で
          きるようにしたものです。同じ種類の情報が連続している 時に使用しま
          す。
          基本型ばかりでなく、あらゆる型の配列を作ることができます。 配列の
          宣言は、次のようにします。

          int a[] = new int[100];
          MyClass ca[] = new MyClass[100];

          int型は、基本型なので、この宣言のあと、

          a[40] = 808;

          のようにして、直接に値を代入できます。ところが、MyClass型は、 クラ
          スなので参照型です。この宣言では、参照だけが100個用意され、 実体は
          まだメモリ上に確保されていないので、実体を作るためには、 それぞれ
          の要素について、コンストラクタを呼びだしてやる必要があるのです。
          それには次のようにします。

          MyClass ca[] = new MyClass[100];
          for(int i=0 ; i < 100 ; i++ ) ca[i] = new MyClass();

          また、配列は、Javaの内部では、クラスとして実装されているので、次の
          ようにして 要素の数を知ることもできます。インスタンス変数をアクセ
          スする要領です。

          int [] ia = new int[100];
          System.out.println(  ia.length );       // 100が表示される。


6. 変数宣言

     変数を宣言するには次のようにします。

     修飾子 型名 変数名(,変数名,..);

     型名は、前項で説明した型を指定します。
     修飾子には、以下のものが指定できます。複数の指定が可能です。
--------------------------------------------------------
        o static
          クラス変数に指定します。クラスのどのインスタンスからでも共通にアク
          セスされます。 static指定されている変数をアクセスするのには、
          static指定した メソッドを使うのがよいでしょう。
        o final
          定数という意味になります。
        o public/private/protected
          アクセスできる範囲を指定します。 publicは、その変数に対して、パッ
          ケージの外からもアクセスできます。
          privateは、そのクラス自身の中からしかアクセスできません。
          protectedそのクラスと、それをextendsしているクラスの中から のみア
          クセスできます。
          これら3つの指定をしないと、同じパッケージの中のどんなクラスからで
          もアクセスできる 指定になります。
        o volatile
		  複数のスレッドから参照される可能性がある変数に対して、指定します。
		  スレッド間の同期の問題を回避できます。
        o transient
		  変数が一時的な情報を保管しているという指定です。
--------------------------------------------------------

     変数名のところでは、'='演算子を使って初期化ができます。
        例：
        public final int MAGIC =10;
        private volatile vi=10;



7. 演算子

--------------------------------------------------------
      演算子          演算の内容                 注意事項、例
--------------------------------------------------------
      +     足し算
      -     引き算
      *     かけ算
      /     割り算
      %     割り算の余り
      +=    和を代入                       x = x + a
      -=    差を代入                       x = x - a
      *=    積を代入                       x = x * a
      /=    割り算の結果を代入             x = x / a
      %=    割り算の余りを代入             x = x % a
      ++    1加える                        前置、後置では働きが違う
      --    1減らす                        前置、後置では働きが違う
      ==    等しい
      !=    異なる
      <     〜より小さい
      >     〜より大きい
      <=    以下
      >=    以上
      &&    かつ(論理演算)
      ||    または(論理演算)
      !     否定(論理演算)
      &     ビットごとの積
      |     ビットごとの和
      ^     ビットごとの排他的和
      <<    左シフト
      >>    右シフト(算術)
      >>>   右シフト(論理)
      ~     ビット反転                     ~x
      <<=   左シフト代入                   x = x << a
      >>=   右シフト代入(算術)             x = x >> a
      >>>=  右シフト代入(論理)             x = x >>> a
      &=    ビットごとの積を代入           x = x & a
      |=    ビットごとの和を代入           x = x | a
      ^=    ビットごとの排他的論理和を代入 x = x ^ a
--------------------------------------------------------

     ++と--は、変数の前に置くときと後ろに 置くときでは、動作が違います。x++
     のように後ろに置くと、 xの値は、式の実行が全部終わってから加算されま
     す。 ++xのように前に置くと、式の実行が始まる直前に加算されます。 次のよ
     うなコードを実行して、試してみてください。

             int x = 20;
             System.out.println("x:" + ( ++x ));
             System.out.println("x:" + ( x++ ));

     演算子の優先順位

     それぞれの演算子には、次のような優先順位があります。
--------------------------------------------------------
       演算子
--------------------------------------------------------
      ()[].
      ++ -- ! ~ instanceof
      new
      * / %
      + -
      >> << >>>
      < > <= >=
      == !=
      &
      ^
      |
      &&
      ||
      ?:
      = += -= *= /= %= ^=
      &= != <<= >>= >>>=
--------------------------------------------------------

     文字列の加算演算子

     演算子の中で、+だけは、文字列を連結するために使えます。 次のように文字
     列と文字列を連結するだけでなく、
      String s = "how";
      String t = "are";
      String u = s + t + "you?";

     文字列以外のものも自由に連結できます。その際には、自動的に文字列に 変換
     されます。
      int c = 200;
      String s = "number:" + c;


8. 論理演算の真偽値表

--------------------------------------------------------
      演算子 値1   値2  結果
--------------------------------------------------------
      &&    true  true  true
      &&    true  false false
      &&    false true  false
      &&    false false false
      ||    true  true  true
      ||    true  false true
      ||    false true  true
      ||    false false false
      !     true  ---   false
      !     false ---   true
--------------------------------------------------------



9.  文とブロック
     x = y + a;

     これは一つの文です。文は、中括弧を使って複数をまとめることによって一つ
     の文にできます。

     {
         x = y + a;
         y++;
     }

     以上は一つの文になっています。これをブロックと呼びます。ブロックの中で
     宣言した変数は、 そのブロックより外では、使うことができません。この性質
     を使えば、局所的に一般的な 名前の変数を使ったりということができます。

     {
         int i=0;
         {
                 int x;
                 x = i; // このようにできるが、
         }
         x = 20;         // このようにはできない。
     }

     ブロックは一つの文として扱われます。基本的に、次の項目のフロー制御で
     は、 一つの文についての制御を行ないますが、ブロックにすることによって、
     複数の 文を制御することができます。

     if( true ) x = 10; y = 10;

     この場合は、ifで制御できるのは、 x = 10;の文だけです。 y=10;は、ifに関
     係なく実行されます。

     if( true ){ x = 10; y = 10;}

     この場合は、二つの文をブロック化しているので、一つの文として扱われま
     す。 ですから、x=10;とy=10;の二つの文がif で制御されます。



10. フロー制御

     フロー制御とは、プログラムの流れを分岐させたり、ループ(繰りかえし)させ
     たりする ことです。フロー制御を実現するための文には次に示すものがありま
     す。

       1. if

           if( 条件式 ) 文;

          この場合、(条件式)がboolean値でtrueの場合だけ 「文」が実行されま
          す。
           if( 条件式 ) 文1; else 文2;

          この場合、(条件式)がtrueの場合は「文1」が、false の場合は「文2」が
          実行されます。

       2. while

           while( 条件式 ) 文;

          (1)まず条件式を実行し、その結果がboolean型でtrue ならば(2)文を実行
          し、文を実行し終わると(1)に戻ります。while 文の中では、後述の
          continueとbreakが使えます。

       3. for

           for( 初期化式 ; 条件式 ; 更新式 ) 文;

          (1)まず最初に一回だけ初期化式が実行されます。(2)次に条件式が実行さ
          れます。 (3)条件式がboolean型のtrueの場合は、文が実行されます。
          (4)更新式が実行されます。 (5)(2)に戻ります。 for文の中では、break
          とcontinueが 使えます。
           for( int i = 0 ; i<10 ; i++ ){ .... }

          この例では、for文の外では、変数iは見えません。

       4. do〜while

           do 文 while( 条件式 );

          (1)まず文を実行します。(2)条件式を実行します。(3)条件式の結果が
          boolean型のtrueであった場合、(1)に戻ります。 do〜while文は、文の内
          容を、最低1回実行したいときに 役立ちます。

       5. switch

          switch文の中ではbreakをよく使うので、 ループであると勘違いされます
          が、ループではありません。 同じ型の値(整数型)によって分岐したいと
          きに、多数に及ぶ場合は ifを使うとわかりにくいプログラムになります
          が、switch を使うと、見やすいプログラムにできます。
           switch( 式 ){
               case 定数1:
                       文1;
               case 定数2:
                       文2;
               ..
               ..
               default:
                       文N;
           }

          caseの後に、判定したい値を書きます。この値は、整数のリテラル また
          は、final指定した整数変数でなければなりません。 式の値がそれぞれの
          定数に一致すると、その定数に対応した文が実行されます。 文の中に
          breakを書いておくと、switchの処理を 中止し、抜けます。breakがない
          と、一致した定数以降の文が実行されて しまいますので、注意してくだ
          さい。例えば、上の例で定数1に一致した場合で 文1にbreakがない場合
          は、文2も実行されてしまいます。

       6. continue

          ループを次の回に進めます。
           contiue;

          この使用例では、continueが含まれているループの処理を 次の回に進め
          ます。
          Javaでは、それぞれのループに名前をつけることで、continue が含まれ
          ているループより外側のループを次の回に進めることができます。 名前
          のつけかたは、label:のようにします。

           loop1:
           for(int j = 0 ; j < 10 ; j ++){  // このループの名前が、loop1
               loop2:
               for(int i = 0 ; i < 20 ; i++){  // このループの名前が、loop2
                       System.out.println( i );
                       if( i == 10 ) continue loop1;
               }
           }

       7. break

          ループを中断します。continue文と同じように、名前をつけた ループに
          対して操作することができます。
           break;

          この場合は、breakが含まれているループの処理を中断します。
           break label;

          この場合は、名前をつけたループの処理を中断します。 breakは名前をつ
          けたif文に対しても使えます。
           branch1:
           if( true ){  // このif文の名前が、branch1になる
           branch2:
               if( true ){  // このif文の名前がbranch2になる
                       break branch1;
               }
               文A;
           }

          この例だと、文Aは実行されません。

       8. return

          メソッドの実行を中断し、呼び出し元に戻ります。
           return 式;

          式に、メソッドの返り値と同じ型の値を指定することによって、メソッド
          の 返り値とすることができます。

       9. goto

          gotoは、予約語になっていますが、使うことはできません。




11. クラスとインターフェイス定義

     新しいクラスを定義するには、トップレベルでclassというキーワードを使いま
     す。 一般的には次の形です。

     (修飾子) class クラス名 (修飾子 修飾子への指定) ブロック

     「ブロック」の部分は、中括弧でくくったクラス定義の内容を書きます。
     括弧内は省略できます。 classの前には以下の修飾子を付けることができま
     す。複数指定可能です。

------------------------------------------------------------
        o final
          他のクラスによってextendsすることができなくなります。
        o abstract
          このクラスのインスタンスを作ることができなくなります。他のクラスの
          メソッドの返り値と して得るということになります。
        o public
          パッケージ外からアクセス(つまり、インスタンスを作る、extendsする、
          という ことができるわけです。そのために、ファイル名は、クラス名と
          一致している必要があります。
------------------------------------------------------------

      public final class hoge {
          int member_int;
          内容...
      }
      abstract class foo{
          int member_int;
      }

     classの後ろには次の修飾子を付けることができます。
        o extends スーパークラス
        o emplements インターフェース,インターフェース...
      class CompressImputStream extends InputStream
      {
          public int setMode(int mode ){
              内容...
          }
      }
      public class MyApplet extends Applet implements Runnable,Serializable
      {
              内容...
      }

     ブロックの部分には、クラスのメソッドや、メンバー変数などを記述します。

	 * インターフェース

	 クラスと似たものに、インターフェースがあります。インターフェースは、
	 変数やメソッドの宣言だけを含みます。変数は、すべてpublic finalとして
	 宣言されます。それぞれのクラスは、インターフェースをimplementsすることに
	 よって、そのインターフェースに規定されているメソッドを実装していることを
	 保証します。クラスの、外部からの見えかただけを規定するわけです。
	 複数のインターフェースをimplementsすることができます。
	 インターフェイスの定義は次のようにします。

	 public/abstract interface 名前 [ extends インターフェース名] ブロック

	 複数のインターフェースをextendsすることができます。
	 いろいろなクラスから共通に使うような変数を固めて定義したりするためにも
	 使えます。インターフェースは大規模なプログラムを開発することを容易にする
	 ことが目標なので、ゲームプログラムにおいてはそれほど使う機会はないかも
	 しれません。

     * クラス内クラス

     JDK1.1附属のjavacからコンパイル可能になった文法で、 クラスのほぼどのよ
     うな所でも新しいクラスを作ることができます。この仕様は コンパイラの機能
     拡張によってなされていて、バイナリの仕様は変更されていません。 クラス内
     クラスの名前は、そのクラス外には見えないので、 クラス内クラスを使うこと
     によって、一般的な名前のクラス(例："record"など) を使うことができるよう
     になります。

     例:
------------------------------------------------------------
class MyClass
{
	class record
	{
		private int type;
		private String name;
		record(int tp,String nm){       // recordクラスのコンストラクタ
			type = tp;
			name = nm;
		}
	}
	record records[] = new record[100];

	MyClass()               // MyClassクラスのコンストラクタ
	{
	}
}
------------------------------------------------------------

	


12. メソッドとコンストラクタ

     メソッドの定義は次のようにします。

     修飾子 型指定 メソッド名( パラメータ列 ) ブロック

     修飾子は以下のものがあります。nativeについては省略します。
--------------------------------------------------------
        o abstract
          メソッドをabstract指定するためには、このメソッドを含むクラスを
          abstract宣言する必要があります。さらに、そのクラスをextends するク
          ラスの中で、このメソッドの実体を定義してやる必要があります。
        o static
          static指定したメソッドは、そのクラスのどのインスタンスからでも共通
          に アクセスされます。static指定の変数にアクセスするために使えばよ
          いでしょう。
        o final
          final指定したメソッドは、サブクラスでオーバーライド(同じ引数、返り
          値の 型指定と名前で、違う内容に作りかえること。Appletプログラミン
          グでのpaint メソッドのように。)できなくなります。
        o synchronized
          この指定をしたメソッドは、別のスレッドによって同時に実行されること
          はなくなります。
        o public/private/protected
          アクセス指定です。変数宣言の所で説明した通りです。
---------------------------------------------------------



13. 例外とエラー

     プログラムの実行中に予期しない状態が発生した場合、通常の処理を中断して
     エラー 処理などの特別なプログラムを実行したい時があります。それを実現す
     るのがtry とcatchです。一般的には次のようにします。

     try{
         通常の処理
     } catch( 反応したい例外 ){
         例外処理
     } catch( 反応したい例外 ){
     } finally {
         必ずやっておかなければならないこと
     }

     プログラムの中で意図的に例外を発生させることもできます。その場合には
     throw( Throwable)を使います。例えば次のようにすれば、
	 ある例外をcatchしながら、その呼びだし元のクラスにも例外を飛ばすことができます。
	try{
	}catch( InterruptedException e ){
		throw( e );
	}



14. パッケージ

	ひとかたまりの機能を実現するクラス群をまとめてパッケージとする
	ことができます。大規模なプログラムを開発するときには必須の機能です。

	あるクラスをパッケージに含めるには次のようにします。
------------------------------
package mypackage;

public class myClass
{
	......
}
------------------------------
	クラスをpublic宣言すると、他のパッケージからextendsすることができる
	ようになります。
	同じパッケージに指定したクラス群は、そのパッケージの名前をつけた
	ディレクトリに、パッケージの階層構造と同じ構造にして保存しておく
	必要があります。
	例：
	java.awt.Button                ..../JDK/classes/java/awt/Button.class
	java.awt.image.PixelGrabber    ..../JDK/classes/java/awt/image/PixelGrabber
	
	

15. import

	ソースプログラムの中では、様々なクラスを使いますが、本来はそれぞれの
	クラスは、次のように「省略なし」で指定する必要があります。

------------------------------
public class myApplet extends java.applet.Applet
{
	java.lang.String message;
	java.awt.Button b;
	...
}
------------------------------
	しかしそれでは繁雑になるので、ソースコードの冒頭でそれぞれのクラスをimport
	することにより、コード量を減らすことができます。
------------------------------
import java.applet.Applet;
import java.awt.*;
public class myApplet Applet
{
	String message;
	Button b;
	...
}
------------------------------
	java.langはデフォルトでimportされているので、完全に省略してしまうことができ
	ます。この例でのjava.applet.Appletのように単一のクラスをimportすること
	以外にも、java.awt.* というように、パッケージ内のpublicクラスをすべて
	importすることができます。

	(注意)*という記号が有効なのは、1段階までです。

import java.*;

	という表記をしても、java.awtの下のクラスは、importされません。




