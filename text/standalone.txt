第5章 スタンドアローンのゲームを作る

「スタンドアローン」とは、ネットワークを通して対戦したりできない、 あるパソ
コン一台の中だけで完結しているゲームのことです。例えば普通の家庭用ゲーム機用
のゲームは、ほとんどすべてが、スタンドアローンのゲームです。ネットワークを利
用した ゲームは、中級以上の内容であるため、第6章で説明することにします。


5.1 小さいゲームを実際に作る

     この節以降で、実際にゲームを作ります。ここで作るゲームは、小規模なもの
     です。大規模なゲームは、画像の量が多いとか、面のデータが豊富とかの 理由
     によってサイズが膨らんでいるだけで、プログラムの基本は小さいゲームと 変
     わりありません。プログラムの内容も、 ここで紹介する例のプログラムと、基
     本的には変わるものではありません。 小さいゲームは、要素が凝縮されていま
     す。サンプルプログラム を、しっかり理解してください。
     サンプルプロゲームは、2種類です。それらには、それぞれ、ゲームプログラ
	 ミングにおいてよく使われる手法を取り入れています。また、取りこみきれない
	 ものについては、第5節以降でゲームとは別に紹介しています。


5.2 モグラ叩き

	 
     さて、まずテーマを決めます。かなり悩みますが、「もぐら叩き」にします。
     どちらかというと、「もぐら叩き」は、プレイヤーに対して連続的に問題(新し
     い モグラ)が与えられて、プレイヤーはそれをただ反射神経に任せて叩いてい
     くという、 ストレスの高い、そして体が資本なゲームです。この手のゲーム
     は、ダラダラした ゲーム展開になりやすいものです。多少でもその傾向をやわ
     らげるために、 様々な工夫ができますが、その工夫は皆さんにおまかせして、
     絶対に欠かすこと のできない部分だけを示します。
     それから、プレイヤーの技術が正当に反映されるように、できるだけランダム
     な 要素をなくします。具体的には、どのモグラも一定時間たつとまた穴の中に
     戻ってしまうようにします。もちろん出現位置はランダムです(これも、位置を
     微妙に調整することで、面白い効果を生むことができるかもしれません)
     だいたい基本的なデザインができたので、あとは表示のしかたとか、モグラの
     出てくる 穴の数とか、点数の配分などを決める必要があります。このへんは、
     テストプレイをして 調整していくことが非常に重要です。ですから、プログラ
     ムする時の注意としては、 「後から調整できるように、数値的なことは、独立
     させてプログラムする」ということが 必要になってきます。穴の数を変更する
     のが大変だ、ということになると、調整する のも一苦労です。ゲームの面白さ
     は、最後の調整で大きく前進するものです。(任天堂の ゲームなどは、開発期
     間の後ろ半分は、ほとんど調整に割りあてています。) このあたりのノウハウ
     も、サンプルプログラムから、吸収してください。
     とりあえずの数値設定として、横6×縦5とします。さらに、穴の大きさは、 適
     度に叩きやすいように、64ドット四方にします。マウスで操作するアクション
     ゲームの場合、 あまり小さな領域にしておくと、操作が困難であることがゲー
     ムを必要以上に難しくします。 (例えば、シューティングゲームで、ちょっと
     簡単すぎるというアンケート結果になった とします。その場合、ジョイスティ
     ックを8方向から4方向操作に変更するという難度調整 ではなく、敵の攻撃を激
     しくするという方法をとるべきです。しかし、外国のゲームでは この点をかん
     ちがいしているソフトもたくさんあります。) そして、「一定時間」というの
     は、4秒にしましょう。点数は、一匹やっつけるごとにレベル の分の点数が加
     算されるようにします。レベルは、一定数やっつけると上昇していきます。
     モグラ叩きのゲームは、ストーリーがあるわけではないので、いつまでも終わ
     らない ゲームにします。エンディングなども作りません。(無理矢理作ること
     はできますが。) ですから、点数勝負のゲームになります。お互いに競うため
     には点数ランキングは必須です。 点数ランキングには、全体で何秒かかったか
     ということも表示したらいいかもしれません。
     最後になりますが、操作は、トンカチの代用として、マウスカーソルを使いま
     す。 マウスカーソルをモグラに合わせてボタンを押すと、叩いたことになるよ
     うにします。 そして、プレイヤーが、今ボタンを押すとどのモグラを叩いたこ
     とになるのかを 把握しやすいように、現在マウスカーソルが合わさっている穴
     には、枠を表示する ようにしましょう。

     以上のアイデアを、整理すると、次のようになるでしょうか。

        o 基本は、モグラ叩きである。
        o 出てきたモグラは、一定時間(4秒)たつと、また穴に戻る。
        o 穴に戻る前にマウスカーソルを合わせてクリックすると、叩いたことにな
          る。
        o 10回ミスすると、ゲームオーバー
        o 一定数やっつけると、レベルが上昇する。
        o 最後に調整しやすいようなプログラムをする。
        o 点数の入りかたは、 一匹あたりレベル点とする。
        o 穴の数は、横6、縦5とする。穴の大きさは、64ドット四方とする。
        o 叩くと、音がでる。

     あとは、グラフィックです。モグラをアニメーションさせるかどうかによりま
     すが、 マウスカーソルでトンカチの代用にしますから、モグラのグラフィック
     だけでよさそうです。 音声も、叩いた音だけでよさそうです。(もちろん、レ
     ベルアップとか同時消しとか 逃がした時とかに、いろいろ音を出すのもいいで
     すね。これらは後で考えましょう。)
     いかがですか？ゲームを作るには、最低でもこれくらいの見通しをたててみま
     しょう。 慣れないうちはそれも大変なので、見通しを立てる努力だけでもして
     みましょう。そうする ことで、頭の中に、完成したゲームの像を描きながら開
     発することができます。現段階での 完成予想図は、次のような感じです。まだ
     できていないので、完成図ではありません。

#図5.2-1 <NOT YET>     完成予想図

     では、実際に作りましょう。

5.3 実際に作る

     まず、ゲームを作り慣れていない人は、「さあ、作るぞ」となったときに、ま
     ず、何を するかというと、モグラの絵を描きはじめるのです。そして、あーだ
     こーだ言っている あいだに、根気が尽きたり、他のことに興味が移ったり、忙
     しくなったりして、未完成の まま終わるのです。ソフトハウスにおいては、プ
     ログラムとグラフィックの作業が 協調して同時に進められるため、そういう問
     題は発生しにくいです(というか、仕事だから そんなことが起こるはずはない
     のですが)。京大マイコンクラブのようなサークルにおいては、 そういう経緯
     をたどってポシャってしまうプロジェクトが後をたちません。
     ゲームを作りあげるコツは、まず最初に、本質的に重要な部分を作ってしまう
     ことです。表示に 凝るのは、後でもできることですから。
     前節でこのゲームのデザインをしましたが、その中から、どれが本質的に重要
     な部分なのか を洗いだしてみましょう。
     それはずばり、「もぐらを出して、ひっこめる」という部分です。もちろん、
     最初から 「もぐら」である必要はなく、「白い四角」でもいいわけです。実
     際、プロの作業では、 ゲームの開発の後半にかかるまで、画面に白い四角が動
     いていて、最後に急に外見が 整いはじめる、ということもあります。
     この節では、プログラムは、前に紹介した、「スケルトン」を使い、それを発
     展させていきます。 まずは、プログラムを打ちこんで、実行してみてくださ
     い。(かなり大変ですが、 がんばってくださいね。) プログラム中に、コメン
     トがありますので、読み進める参考にしてください。

     プログラム


File name: game.java
----------------------------------------------------------
import java.applet.Applet;
import java.applet.AudioClip;  // AudioClipを使うためのimport
import java.awt.*;
import java.awt.image.*;
import java.util.*;


public class game extends Applet implements Runnable
{


	Thread thread;
	Image double_buffer;
	Graphics dg;

	int cron=0;

	// 変更可能個所、数値のところだけ色を変える。 
	int width , height;

	final int holesize = 64;  // 穴のサイズ(正方形)

	// もぐら叩きを調整するための変更部分 
	final int yokosize = 5; // 穴の数
	final int tatesize = 4; 
	public final int interval = 100;	// ゲームの進行速度
	final int mogtime = 40;   // モグラの寿命
	final int misstime = 4;   // ミス表示の時間
	final int hittime = 4;    // ヒットした表示の時間
	final int mogblank = 8;   // 同じ穴に続けて出る時の間
	final int rate = 10;      // モグラが出現する頻度
	final int life_max = 10;  // 10回ミスしたら終わり
	final int levelunit = 10; // 10匹やっつけるごとにレベルアップ


	int mog[][] = new int[yokosize][tatesize ]; // もぐらを、必要な数だけ用意する
	int mogstate[][] = new int[yokosize][tatesize];  // モグラの状態

	final int ALIVE = 1;  // もぐらの状態は、これらの値を入れておく。
	final int MISS = 2;
	final int HIT = 3;
	final int OUT = 0;


	int score,level,life, hitno;

	MediaTracker mt; // 画像ロードのために使うMediaTracker
	Image aliveimg;  // モグラの画像(出現している時の)
	Image hitimg;    // モグラの画像(叩いた瞬間の)
	AudioClip hitsound,hellosound; // 叩いた音と出てくる音
	

	int mode;  
	final int TITLE= 1;       //modeに入れる値
	final int GAME = 2;
	final int GAMEOVER = 3;

	public void init()
	{

		width = size().width;
		height = size().height;
		thread = new Thread(this);
		double_buffer = createImage( width , height );
		dg = double_buffer.getGraphics();

		thread.start();

		/* ここからもぐら叩きのための変更部分 */
		dg.setColor( Color.black );
		dg.fillRect( 0 , 0 , width , height );


		// 使う画像をロードする。ロードが終わるまで、MediaTrackerを使って待つ
		aliveimg = getImage( getDocumentBase() , "alive.gif" );
		hitimg = getImage( getDocumentBase() , "hit.gif" );
		
		mt = new MediaTracker( this ); // 同じIDで待つ
		mt.addImage( aliveimg, 1 );
		mt.addImage( hitimg , 1 );
		try{
			mt.waitForID( 1 ); // ロード開始し、指定したIDの画像が全部ロードされるまで待つ。
		}catch( InterruptedException ie ){}

		hitsound = getAudioClip( getDocumentBase() , "yahoo.au");
		hellosound = getAudioClip( getDocumentBase() , "hi.au");
		// タイトル画面を表示
		mode = TITLE;


	}

	public void paint( Graphics g )
	{
		g.drawImage( double_buffer , 0 , 0 , null );

	}
	public void update( Graphics g )
	{
		paint( g );
	}
	public void run()
	{
		while( true )
		{
			cron++;
			try{
				Thread.sleep( interval );
			} catch( InterruptedException e ){}

			doIt();
			repaint();
		}
	}

	void doIt()
	{

		if( mode == TITLE ){
			dg.setColor( Color.black );
			dg.fillRect( 0 , 0 , width , height );
			dg.setColor( Color.white );
			dg.drawString( "DestroMogura",30, height/2 );
			dg.drawString( "press mouse button" , 30 , height/2+50);
		} else if( mode == GAME ){

		/* 変更可能個所 */
		
			// 一定時間ごとに、モグラを出現させる
			// レベルに応じて、出てくるモグラが増えていく。

			if( ( cron % rate ) == 0 ){
				int kazu;
				kazu = new Random().nextInt() & 255;
				kazu = kazu % level;
				for(int i = 0 ; i <= kazu ; i++){

					putMogura();
				}
			}
			// モグラの寿命を減らしていく。
			moveMogura();

			// 命がなくなったら、ゲームオーバー
			if( life < 0 ){
				mode = GAMEOVER;
			}
			
			// 点数などを表示、消してから書くことに注意
			dg.setColor( Color.black );
			dg.fillRect( yokosize * holesize+10,0, width - yokosize*holesize , 100);

			dg.setColor( Color.white );
			dg.drawString("Score " + score , yokosize * holesize +10 , 30);
			dg.drawString("Life " + life , yokosize * holesize+10,60);
			dg.drawString("Level " + level , yokosize * holesize+10,90);

		} else if( mode == GAMEOVER ){
			dg.setColor( Color.black );
			dg.fillRect( 0 , 0 , width , height );
			dg.setColor( Color.red );
			dg.drawString("Game Over",30, height/2 );
		}
	}
	void moveMogura( )
	{
		// 死ぬまでの時間を1減らす。死んだものは、消してしまう。
		for(int i = 0 ; i < tatesize ; i++){
			for(int j = 0 ; j < yokosize ;j++ ){
				mog[j][i]--;
				if( mog[j][i] < 0 ){
					mogstate[j][i] = OUT;
					outMogura( j , i );
				}
				if( mog[j][i] == misstime ){
					mogstate[j][i] = MISS;
					life--;
					missMogura( j , i );
				}
			}
		}
	}


	// もぐらを一匹出現させる
	void putMogura( ){
		
		int r = new Random().nextInt();
		r = r & 255; // 正の値に戻す。この結果、rには、0から255の値が入る。
		r = r % (yokosize * tatesize );
		int yoko = r % yokosize;
		int tate = r / yokosize;

		// モグラが消えてから一定時間たたないと同じ穴には登場できない
		if( mog[yoko][tate] > -mogblank ) return;
		hellosound.play(); // 出現時の音を出す
		mogstate[ yoko ][ tate ] = ALIVE;
		mog[ yoko ][ tate ] = mogtime;

		dg.setColor( Color.white );
		dg.fillRect( yoko * holesize , tate*holesize , holesize , holesize );
		dg.drawImage( aliveimg , yoko * holesize , tate*holesize ,null);
	}
	// モグラを消す。
	void outMogura( int x , int y ){
		
		dg.setColor( Color.black );
		dg.fillRect( x * holesize , y * holesize , holesize , holesize );
		dg.setColor( Color.white );
		dg.drawRect( x * holesize , y * holesize , holesize , holesize );
	}
	// 逃げ状態のモグラを表示する。
	void missMogura( int x , int y ){

		dg.setColor( Color.black );
		dg.fillRect( x * holesize+1 , y*holesize+1 , holesize-1 , holesize-1 );
		dg.setColor( Color.yellow );
		dg.drawString( "MISS" ,x*holesize , y*holesize+(holesize/2) );


	}
	//やられ状態のモグラを表示する。
	void yarareMogura( int x , int y ){
		dg.setColor( Color.red );
		dg.drawLine( x * holesize , y* holesize , x*holesize + holesize , y*holesize + holesize );
		dg.drawLine( x * holesize + holesize , y * holesize , x * holesize , y * holesize + holesize );
		dg.drawImage( hitimg , x*holesize, y*holesize ,null);
	}
	// マウスが押されたときの処理
	public boolean mouseDown( Event e , int x , int y )
	{
		if( mode == TITLE ){
		
			// もぐらを初期化
			for(int i = 0 ; i < yokosize ; i++){
				for(int j = 0 ; j < tatesize ; j++){
					mogstate[i][j] = OUT;
					mog[i][j] = 0;
				}
			}
			score = 0;
			level = 1;
			life = life_max;
			hitno = 0;
			mode = GAME;
		} else if( mode == GAME ){
			// どのモグラを叩いたのかを判定する
			int yoko ,tate; // モグラの穴の位置
			yoko = x / holesize;
			tate = y / holesize;
			
			// モグラが生きているときだけヒット。
		
			if( yoko>=0 && yoko < yokosize &&
			    tate>=0 && tate < tatesize &&
			   mogstate[yoko][tate] == ALIVE ){
				mog[yoko][tate] = hittime;
				mogstate[yoko][tate] = HIT;
				yarareMogura( yoko , tate );
				score = score + level;
				hitsound.play();  // 音をだす
				hitno++;
				// レベル
				if( (hitno % levelunit ) == 0 ){
					level++;
				}
			}
		} else if( mode == GAMEOVER ){
			mode = TITLE;
		}
		return true;
	}

}
----------------------------------------------------------

File name: test.html
----------------------------------------------------------
<applet code=game.class width=500 height=400></applet>
----------------------------------------------------------

#図5.3-1 <DONE> 	もぐらたたきの実行結果(game.java)


	このプログラムが動作するには、game.classが置かれているディレクトリと同じ
	ディレクトリに、alive.gif, hit.gif, hi.au, yahoo.au
	の4つのファイルが必要です。これらはCD-ROMに収録されています。コピーして
	使用してください。


     プログラムを書
     きはじめる前に、 見通しを立てておきましょう。プログラミングの熟練者と初
     心者とでは、プログラムを始める前の 見通しの段階で最も差が出ます。熟練者
     は、実現したい事柄に必要なデータ構造やプログラムの 構造を的確に見通すこ
     とができるところが初心者と違います。熟練者はまず、プログラムの最も大切
     な中 枢部分(これができないと全体が成立しないという部分)を的確に取りだ
     し、それに必要なデータ構造を デザインします。そして、それを操作する関数
     (メソッド)群を記述していきます。このような方法をとると、 常に全体を見失
     わないでプログラムを進めることができるのです。しかし初心者のうちはその
     ような ことはなかなかできないので、進んだり戻ったりしながら、時には最初
     から作りなおしたりしながら(これが なかなかためになるのです)ゆっくり進め
     ていきましょう。

     では、モグラ叩きゲームを作る時の見通しを筆者なりに立ててみます。
     まず、重要な部分は、操作、表示、モグラの動作に分けることができます。操
     作については、マウスでやる ということが決まっていて、モグラの動作に関連
     するのは、マウスを押したときだけです。 ですから、mouseDownメソッドの中
     に何かプログラムを書けばできるということがわかります。 次に表示につい
     て。表示は、モグラを絵で表示します。モグラが生きている状態の時と、 死に
     かかっている状態を別の表示にするので、画像は2種類必要なことがわかりま
     す。そのために、 Imageクラスの変数を2個用意します。それらをゲームが始ま
     るまでにロードするために、 MediaTrackerを使いましょう。次にモグラの動作
     です。モグラは、一定時間出現して、消えます。 出現している間に叩かれた場
     合は、その場で叩かれている絵に変化させます。モグラの時間を管理する ため
     に、runメソッドの中で定期的にモグラを出現させたり消したりするプログラム
     を 実行する必要があります。

     以上のような見通しができたので、プログラムに入ります。まずクラスの名前
     を決めます。 ここで、「オブジェクト指向」を徹底的に追及するなら、「モグ
     ラクラス」と「ゲームクラス」に クラスを分けたりするのですが、無理に追及
     することもありません。全体像を把握しやすい ようにクラスは一つにしてしま
     いましょう。名前はgameです。 それから必要なパッケージをimportします。こ
     れは、今までに 出てきたサンプルプログラムのようにします。

     次にスケルトンプログラムをコピーします。ここで、またモグラの情報をどう
     管理するかを決めていないので、モグラのデータ構造について考えます。
     画面上のモグラは、きれいに縦横に並んでいるので、2次元の配列にして管理す
     るのが よさそうです。モグラの状態は「出現」と「叩かれ」と「消え」と「逃
     げ」の4種類があり、 それぞれの持続時間もまちまちなので、時間を管理する
     変数と状態を管理する変数の2種類を 宣言します。それが、mog[][]と
     mogstate[][]です。 モグラを動かすプログラムの部分では、この2種類の変数
     を増減したり、範囲を調べたりする わけです。そういう処理をするメソッドを
     一つ用意しましょう。moveMogura() メソッドでその処理をします。このメソッ
     ドは、doItメソッドの中に書かれ、 一定時間ごとに実行されます。これによっ
     て、モグラが自発的に消えたり出現したりします。 プログラムする上でのポイ
     ントは、モグラを管理するのではなく、「モグラの穴を管理 する」ということ
     です。時間や状態は、「モグラの穴」についてのものであるということ に注意
     してください。(ですから、モグラがいない、消えている時でも、穴についての
     時間は 計算し続けます。)
     以下に、一つのモグラの穴の状態と時間の関係を図にしてみます。

#図5.3-2 <DRAFT>	モグラの状態

------------------------------------------------------
     叩かれずに逃げる場合
            *----mogtime----*-misstime-*--mogblank-*.........*--mogtime--~~
     .......+---------------+----------+..............~~.....+-----~~~
            出現            逃げ       消え                  出現
     OUT    ALIVE           MISS       OUT                   ALIVE

     出現している途中に叩かれた場合
               *-------*hittime*--mogblank-*............*-mogtime-~~
     ..........+-------+-------+...............~~.......+------~~~
               出現    叩かれ  消え                     出現
     OUT       ALIVE   HIT     OUT                      ALIVE
------------------------------------------------------

     時間を管理する変数mog[][]は、状態を変化させる契機として使っています。
     それから、プログラムの中には、ゲームの速度を決める定数や タテヨコの穴の
     大きさ など、後から変更できるようにしておくことが重要です。特にゲームで
     は、大体完成してから 微妙なゲームバランスを調整することが非常に重要です
     ので、ゲームの中で使うような 値は、変数に入れておくようにします。例えば
     穴の縦横の数やモグラが消えるまでの時間 などは後で変更したくなる確率が高
     いです。 プログラム中では次のようにして、「変更したくなるであろう」値を
     最初から変数にして います。もちろん、最初からこれらの変数を全部思いつい
     たわけではなくて、途中で 「必要そうだな」と思ったときに加えるようにして
     います。

     final int yokosize = 5; // 穴の数
     final int tatesize = 4;
     public final int interval = 100;        // ゲームの進行速度
     final int mogtime = 40;   // モグラの寿命
     final int misstime = 4;   // ミス表示の時間
     final int hittime = 4;    // ヒットした表示の時間
     final int mogblank = 8;   // 同じ穴に続けて出る時の間
     final int rate = 10;      // モグラが出現する頻度
     final int life_max = 10;  // 10回ミスしたら終わり
     final int levelunit = 10; // 10匹やっつけるごとにレベルアップ

     これらの値はすべて、ゲーム感覚に影響を与えるパラメータですね。
     モグラの動作の詳細について考えてみます。 モグラは、一定時間たつと消えま
     す。消える時間は、 mogtime=40として変数に しました。この値を配列変数
     mog[][]に入れて、runメソッドの中で 1づつ減らしてゆき、負の値になったら
     消えるというようにします。最初の設定値では、 0.1秒ごとにゲームの時間が
     進みますから、最初に40という値を入れておけば、4秒でモグラが消える よう
     になります。
     さらに、モグラ(の穴)には4つの状態があると述べましたが、その中に、「逃
     げ」と「叩かれ」という2つの状態がある ことがプレイ感覚の上で重要です。
     これらの状態は、クリックした時にちょうどモグラが消え た場合、それが自分
     の攻撃によるものなのか、時間切れによるものなのかの区別がつかないことを
     防ぐために導入します。攻撃がヒットしていた場合は、「叩かれ」グラフィッ
     クになり、 時間切れが原因でモグラが消えた場合は「逃げ」グラフィックにな
     るというようにすれば、 プレイヤーは不安にならずにすみます。実際にその不
     安を体験するために、プログラムを改造して、 叩いたグラフィックと逃がした
     グラフィックが省略されているバージョンを作ってみてください。 非常にプレ
     イしにくくなっているはずです。

     では、プログラム開始です。

     まずスケルトンプログラムをコピーします。 それから、絶対に必要な
     mouseDownを外側だけ書いてみましょう。
     それから、一定時間ごとに呼ばれるmoveMoguraも書いておきます。
     run,paint,init,doItは スケルトンのものを流用します。
     これだけでプログラムの外側はだいたいできました。もちろん、プログラムし
     ていく 時に、必要に応じて、様々なメソッドや変数を加えていくこともためら
     ってはなりません。
     筆者は、以上のメソッドに加えて、あらかじめ モグラの4つの状態に対応して
     いる 

     putMogura
     missMogura
     yarareMogura
     outMogura
     の4つのメソッドを作りました。(もちろん最初は内容はありません。) もちろ
     ん必ずこれらの4つのメソッドにしなければならないということはありません。
     考えかた次第で、もっとスマートなやりかたもあるはずです。このプログラム
     はほんの一例だ ということを理解してください。

     それぞれのメソッドの中身

     では、プログラム中で使っている変数と、それぞれのメソッドの中身を解説し
     ます。 プログラムの文法的な面の説明以外にも、なぜそのメソッドを作ったの
     か、なぜそのような 記述をするのかという目的を汲みとるように注意してくだ
     さいね。 メソッドの中身の説明では、プログラムのコメントなどと照らしあわ
     せながら読んでください。

       1. 変数
          このプログラムで使っている変数は多いですが、すべて必要があったもの
          です。 大体はプログラムのコメントとして説明していますが、もう少し
          説明を加えます。
             + Thread thread
               このアプレットは自発的に動作する(何も働きかけなくても動いてい
               る)ものに するために必要です。
             + Image double_buffer,Graphics dg
               オフスクリーンを使って、画面のちらつきを防ぎます。これは「ち
               らつき防止」の節で 説明した通りです。
             + int cron
               ゲーム全体の時間を管理します。ただ増えていくだけのカウンタで
               す。この変数を使って、 モグラを出現させる部分は、記憶に値しま
               す。割り算の余りの典型的な使用法です。これは doItメソッドの中
               を参照してください。
             + int width,height
               これはアプレットの大きさを代入して後々の役に立てています。
               initメソッド の中で初期化されています。
             + final int holesize
               穴のサイズです。長方形にするなら、縦の大きさと横の大きさの2種
               類の変数が必要ですが、 このゲームでは正方形ですので、変数は一
               つでOKです。宣言時に64に初期化しています。
             + final int yokosize,final int tatesize
               穴の縦横の数の設定です。finalがついているのは、プログラム実行
               中には 変化しないという意味です。プレイ中に設定を変更できるよ
               うにするのであれば、 finalは外さなければなりません。
             + final int interval
               ゲーム全体の進行の単位時間です。この時間間隔(ミリ秒)より細か
               いタイミングでは モグラが消えたり出たりすることはありません。
             + final int mogtime
               モグラの寿命です。この寿命は整数で、interval変数によって決ま
               る ゲームの単位時間の単位数です。interval変数の値が100の場
               合、この変数の 値が40なら、40×100=4000(ms)つまり4秒でモグラ
               が逃げることになります。
             + final int misstime
               モグラを逃がした時に、「逃げ」グラフィックが表示されている時
               間です。これもゲームの単位 時間の単位数になります。
             + final int hittime
               「やられ」グラフィックの表示時間です。単位は他と同じ、単位時
               間数です。
             + final int mogblan
               これは、同じ穴に次のモグラが出現できるようになるまでの時間で
               す。これも単位時間数です。
             + final int rate
               これは、モグラの出現する頻度を表しています。doItメソッドの中
               では、 変数cronをこの値で割って 0だった場合に出現の処理をする
               という風にしています。
             + final int life_max
               ゲームオーバーまでに許されるミスの数です。
             + final int levelunit
               この変数の値の数だけモグラをやっつけると、次のレベルに進みま
               す。
             + int mog[][] = new int[yokosize][tatesize ]
               それぞれのモグラの(穴の)時間を管理します。縦×横の穴の数だけ
               配列を用意します。
             + int mogstate[][] = new int[yokosize][tatesize]
               それぞれのモグラの(穴の)状態を管理します。mog[][]と同じ大きさ
               の 配列です。
             + final int ALIVE = 1;
               final int MISS = 2;
               final int HIT = 3;
               final int OUT = 0;

               配列変数mogstate[][]には、これらの値のどれかが入っていて、 こ
               れらの変数と比較すれば、モグラの状態がわかるようになっていま
               す。このように それぞれの定数に名前をつけておくと、プログラム
               中に0とか2などといった値を埋め こんでおくよりも理解しやすく、
               デバッグしやすいプログラムになります。
             + int score,level,life, hitno
               それぞれ、点数、レベル、残りミス、やっつけた数です。
             + MediaTracker mt
               画像ロードに使います。ゲームが始まっても画像が完成していな
               い、ということがないように するためです。詳しくは、「画像ロー
               ドのメカニズム」を参照してください。
             + Image aliveimg,Image hitimg
               モグラが出現している時の画像と、「やられ」状態の画像を入れて
               おきます。扱う画像 の種類が多い場合は、Image images[] = new
               Image[数]というようにして 配列変数にして管理するのもよいかも
               しれません。ここでは2種類しかないので普通の 変数にしていま
               す。
             + AudioClip hitsound,hellosound
               それぞれ、 叩いた時の音と出てくる時の音を入れておきます。これ
               はJDKのデモについている音です。
             + int mode
               ゲームのモードです。ゲームのモードには次の値を入れます。

               final int TITLE= 1;
               final int GAME = 2;
               final int GAMEOVER = 3;

               ゲームの進行は、
               初期化 -> タイトル -> ゲーム -> ゲームオーバー -> タイトルに
               戻る
               というようになっていますが、それぞれのモードに対応していま
               す。スケルトンプログラムは runメソッドの中ができるだけ単純に
               なるようになっていますが、そのような 構造のまま上のようなモー
               ドを実現するために、mode変数を導入したわけです。 こうなってい
               ると、ゲームプレイ中でも、modeに値を代入するだけでタイトルに
               戻ったり、といったことが簡単にできます。あるキーを押すとタイ
               トルに戻る、というような機能 を改造して付けてみてください。

       2. public void init()
          このメソッドのポイントは

            1. size()を使ってアプレットのサイズを記憶する(スケルトン通り)
            2. Thread(this)とthread.start()により、スレッドを初期化する(アニ
               メーションする アプレットでは必須。スケルトン通り)
            3. createImage(width,height)を使ってオフスクリーンイメージ(ダブ
               ルバッファ)を作る(スケルトン通り)
            4. fillRect()で作ったダブルバッファを黒く塗る
            5. getImage()した後、MediaTrackerクラスに登録することにより、画
               像をロードする
            6. getAudioClip()して、音声をロードする
            7. modeをTITLEにセットする

          上記のような処理の塊にわけることができます。それぞれは、別の節で説
          明したことの組みあわせになっていますので、 特に問題はないでしょ
          う。注意点としては、getImageやgetAudioClipでロードする ファイル
          は、アプレットのクラスファイルが置かれているのと同じディレクトリ
          (フォルダ)に置いておく ことが必要です。そうでないと、音は出ない
          し、画像も真っ黒(白の場合もある)になってしまいます。(エラーは出な
          い)
       3. public void paint(Graphics g)
          スケルトンそのままです。
       4. public void update(Graphics g)
          スケルトンそのままです。
       5. public void run()
          このメソッドもスケルトンそのままです。
       6. void doIt()
          描画はすべてこのメソッドの中で行われます。 modeの値により大きく3つ
          の部分に分かれます。 if文の中身を省略すると次のようになっていま
          す。

          if( mode == TITLE ) {
          } else if( mode == GAME ){
          } else if( mode == GAMEOVER ){
          }

            1. mode == TITLE の時
               毎回オフスクリーンを黒で消去し、その上にタイトルの文字を表示
               しています。Graphicsクラスの 基本的な描画メソッドを使用してい
               ますので、問題はないはずです。ここにタイトル画面用の画像を
               dg.drawImage などとすれば、立派なタイトル画面を作ることができ
               ます。この例では文字だけになっています。

            2. mode == GAME の時
               このメソッドの処理は、
                 1. モグラを出現させる。
                 2. モグラを動かす(寿命を縮める)
                 3. ゲームオーバーの判定をする。
                 4. 雑表示
               以上の4つの部分に分けることができます。モグラを出現させる部分
               では、毎単位時間ごとに増えるintの 変数cronをrateで割った余り
               を0と比較することによって、モグラの出現タイミングを決めて い
               ます。rateの値が正で小さいほど、割り算の余りが0になる頻度が高
               くなるので、モグラの出現頻度も 高くなります。この技は、一定周
               期で物事を起こすには大変便利でわかりやすい方法です。

               if( ( cron % rate ) == 0 ){
                       int kazu;
                       kazu = new Random().nextInt() & 255;
                       kazu = kazu % level;
                       for(int i = 0 ; i <= kazu ; i++){
                                       putMogura();
                       }
               }

               もうひとつこの部分で重要なのは、Randomクラスの使いかたです。
               Randomクラスは 乱数を得るためのクラスで、nextInt()というメソ
               ッドを呼びだすと、新しいint 型のランダムな値を得ることができ
               ます。nextIntは、-2147483648から2147483647までの値を 返しま
               す。ここではこのランダム値を、同時にモグラをいくつ出現させる
               かを決めるために使っています。レベルが 上昇しても出現の頻度は
               変化しませんから、同時に出る数を増やすことによって難度を上昇
               させようとしている のです。まず負の値でなくするために、kazuに
               は、nextInt()の返り値に255をアンド 演算して得られる値を代入し
               ています。kazuには、0から255までの値が入ります。なぜアンド演
               算でその ような範囲の値が得られるのかを次の図で示します。

#図5.3-3 <NOT YET>               ビット演算


               0から255までの範囲に絞られたら、今度はさらに0からlevelまでの
               値にするために、また%(剰余記号) を使っています。%は本当に色々
               に使えるということがわかると思います。 あとは、一匹のモグラを
               出現させるためのputMoguraを、forループを使って先ほど決めた 回
               数だけ繰りかえします。これで、レベルに応じて増加するモグラを
               実現することができました。

               次にモグラを動かす部分です。ここでのポイントは、どのモグラも
               一定時間画面に現れた後には逃げるということ です。こういう場合
               はそれぞれのモグラにとっての寿命が等しく減っていくようにすれ
               ば、 これを実現できます。寿命を等しく減らす部分のコードは次の
               ようになっています。(moveMoguraメソッドの 中身です。

------------------------------------------------------------
for(int i = 0 ; i < tatesize ; i++){
	for(int j = 0 ; j < yokosize ;j++ ){
		mog[j][i]--;
		if( mog[j][i] < 0 ){
			outMogura( j , i );
		}
		if( mog[j][i] == misstime ){
			life--;
			missMogura( j , i );
		}
	}
}
------------------------------------------------------------

               2次元配列の中身をすべて減算するために、2重のループを組んでい
               ます。そしてmog[j][i]--; というコードで1減らしています。1を減
               らした結果、寿命が切れた(値が負になった)場合は消す処理を する
               ためにoutMogura(...)を呼びます。負にならなくても、寿命の値
               が、逃げるタイミングに 設定された値(misstime)になれば、残りの
               lifeを減らして「逃げグラフィック」 を表示する処理を呼びだしま
               す。

               次にゲームオーバーの判定です。このゲームでは、ゲームオーバー
               のルールは、残りライフがなくなった時 ということでしたのでそれ
               をそのままプログラムにすると次のようになります。

------------------------------------------------------------
if( life < 0 ){
	mode = GAMEOVER;
}
------------------------------------------------------------

               プレイ中のモードから、ゲームオーバーのモードに移行するだけで
               す。これが実行された以降は、doIt メソッドの中では、GAMEOVERモ
               ードの所だけが実行されるようになります。
               残りの部分では、プレイヤーにとって役にたつ情報を表示していま
               す。これらはプログラムを見た方が わかりやすいでしょう。ポイン
               トは、黒い塗りつぶしの四角で、前に描いた文字を消している とこ
               ろです。こうしないと面白いことになってしまいます。

            3. mode == GAMEOVER の時
               ゲームオーバーの表示だけを行っています。

       7. void moveMogura()

          doItメソッドの所で説明しています。そちらを参照してください。
          moveMoguraは 一箇所でしか呼びだされていないので、わざわざメソッド
          にする必要はありませんが、プログラムを見やすく するためにこうして
          います。

       8. void putMogura()

          モグラを一匹新しく登場させます。位置を決めるときに、前述したRandom
          を使っています。 変数tateとyokoに、登場させたい位置を求めます。と
          ころが、プレイヤー を混乱させないために、「消えてから一定時間は登
          場させない」というルールを導入していますから、 if( mog[yoko][tate]
          > -mogblank ) return;というコードでもってその処理をしています。 こ
          のコードは、モグラの寿命が負になってもまだ減っていくということを使
          って、モグラの穴の時間 がmogblank*-1より大きい場合は登場させない
          (returnして後ろを実行しない) ようにしています。

       9. void outMogura(int x , int y)

          モグラの状態をMISSまたはHITから、OUTの状態に変更し、 それに伴って
          表示も変化させています。表示に関してはプログラムを見ればわかるはず
          です。

      10. void missMogura(int x , int y)
          outMoguraとほとんど同じようなコードですね。逃がしたらMiss という文
          字を表示します。 このメソッドによって、モグラの穴の状態は、ALIVEの
          状態から、MISSの状態に 変化します。

      11. void yarareMogura(int x , int y)
          これもoutMoguraと同じようなコードです。これら3つは、どうにかしてま
          とめてしまうことが できるかもしれません。モグラの穴の状態は、ALIVE
          の状態から、HITの状態 に変化します。

      12. public boolean mouseDown(Event e , int x , int y )
          このメソッドも、doItメソッドのように、ゲームのモードによって3つに
          分かれています。

      13. mode==TITLEの時
          タイトル画面モードでは、1回でもマウスが押されたらゲームが始まりま
          す。 このメソッドのこの部分も1ゲームあたり1回だけの実行になるの
          で、モグラの穴の初期化を行います。 2重ループを使ってすべてのモグラ
          の穴の状態をOUTにし、時間を0に設定します。

      14. mode==GAMEの時
          ゲーム中はマウスをクリックすることはモグラに対する攻撃の意味になり
          ますから、まずプレイヤーが どのモグラを叩いたのかを調べます。
          mouseDownメソッドでは、変数xと変数y に、マウスクリックの位置を得る
          ことができますから、それを穴の番号に直すために、それぞれholesize
          で割っています。一般にこのようなマス目の番号をもっと細かい単位の位
          置から得たい場合には、マスの大きさ を表す定数で割ることによって得
          ることができます。
          次に、叩いた対象の穴に、生きている状態のモグラが出ているかどうかを
          調べます。それにはifの条件 の中に、mogstate[yoko][tate] == ALIVEを
          含めればいいだけです。 以上で、モグラをやっつける条件の判断はでき
          ました。あとは先ほど紹介したyarareMoguraを呼びだして 「やられ」状
          態のモグラを表示し、点数を加算し、音を出すだけです。
          レベルを上昇させる部分では、またまた剰余演算子"%"を使っています。

      15. mode==GAMEOVERの時
          マウスが押されたらタイトルモードに移行します。
     いかがでしたか？マウスを使用するタイプのゲームのうち典型的なものの一つ
     にこのモグラ 叩きがあります。小さなゲームながら様々な要素を持っていまし
     た。


5.4 スネークゲーム

     さて、次に挙げるゲームは、典型的な「スネークゲーム」です。 自分が長く
     生きのこると、どんどん長くなってゆき、最後に
     自分自身に当たると ゲームオーバーになってしまうという単純なゲームです。
     どれだけ長くできるかを 競います。この例では一定時間ごとに長くなっていく
     という風に設定しています。 スネークは止まることができません。また、右に
     曲るか左に曲るか、という 操作しかできません。 この例で示したいのは、
     「遠い記憶は配列を使え」と、「回転系」です。 スネークの尻尾のプログ
     ラムと、キー操作の処理がハイライトです。


File name: snake.java
------------------------------------------------------------
import java.applet.Applet;
import java.awt.*;
import java.awt.image.*;
import java.util.*;

public class snake extends Applet implements Runnable
{
	Thread thread;
	Image double_buffer;
	Graphics dg;
	int cron=0;

	int width ,height;
	int interval = 30;	// milli second 

	public void init()
	{
		thread = new Thread(this);
		width = size().width;
		height = size().height;
		double_buffer = createImage( width , height );
		dg = double_buffer.getGraphics();

		thread.start();

		initSnake();
		gameStart();
	}

	public void paint( Graphics g )
	{
		g.drawImage( double_buffer , 0 , 0 , null );
	}
	public void update( Graphics g )
	{
		paint( g );
	}
	public void run()
	{
		while( true )
		{
			cron++;

			try{
				Thread.sleep( interval );
			} catch( InterruptedException e ){}

			doIt();
			repaint();
		}
	}

	int snake_max=1000;
	int snake_unit=12;
	int snake_len=5;
	int snake_start_len=5;
	int snake_dir;  // 方向は真上が0で右周りに7までの8方向とします。
	double dx[] = { 0,1.41,2,1.41,0,-1.41,-2,-1.41};  // それぞれの方向の移動量
	double dy[] = { -2,-1.41,0,1.41,2,1.41,0,-1.41};
	double snake_x[] = new double[snake_max];
	double snake_y[] = new double[snake_max];
	double snakehead_x , snakehead_y;
	int score = 0;
	double snake_xsiz = 36;
	double snake_ysiz = 36;
	final double SNAKE_SPEED = 3;

	void initSnake(){
		for(int i=0;i<snake_max;i++){
			snake_x[i] = snake_y[i] = -1000;   //世界の果てにしておく
		}
		snakehead_x = width/2;
		snakehead_y = height/2;
		snake_dir = 2;
		snake_len = snake_start_len;
	}

	public boolean keyDown(Event e , int c ){
		if( c == 'h' ){ 
			snake_dir--;  // 左回転
		}
		if( c == 'j' ){
			snake_dir++;  // 右回転
		}
		// 常に値が0から7の間になるようにする
		if( snake_dir >= 7 ) snake_dir-=8;
		if( snake_dir < 0 )snake_dir +=8;
		
		return true;
	}
	void moveSnake(){
		snakehead_x += dx[snake_dir] * SNAKE_SPEED;
		snakehead_y += dy[snake_dir] * SNAKE_SPEED;
		if( snakehead_x < 0 || snakehead_y < 0 || snakehead_x > width ||
		   snakehead_y > height ){
			snakeDie();
		}
		snake_x[cron % snake_max ] = snakehead_x;
		snake_y[cron % snake_max ] = snakehead_y;
		
	}
	void snakeDie(){
		initSnake();
		gameStart();
	}
	void gameStart(){
		score = 0;
		snake_len = 5;
	}
	double tmpx[] = new double[ 200];   
	double tmpy[] = new double[ 200];
	void drawSnake(){
		dg.setColor( fg );

		for(int i=0;i<snake_len ; i++){
			if( ( cron - (i*snake_unit))<0 )continue;
			int index = ( cron - (i * snake_unit) ) % snake_max;
			tmpx[i] = snake_x[index];
			tmpy[i] = snake_y[index];
			dg.fillRect( (int)snake_x[index],(int)snake_y[index],
						(int)snake_xsiz , (int)snake_ysiz );
		}
		// 自分の体に当たると死ぬ。
		// 衝突の判定については、次の節で説明します。
		for(int j=1;j<snake_len;j++){
			if( snakehead_x+snake_xsiz > tmpx[j] && 
			    snakehead_x < tmpx[j]+snake_xsiz  &&
			    snakehead_y+snake_ysiz > tmpy[j] && 
			    snakehead_y < tmpy[j]+snake_ysiz  )
			{
				snakeDie();
				return;
			}
			    
		}
	}

	Color fg = new Color( 0xffaa44 );
	Color bg = new Color( 0x110921);
	void doIt()
	{
		dg.setColor( bg );
		dg.fillRect(0, 0 , width , height );
		moveSnake();
		drawSnake();

		// 難易度調整
		if( (cron % 200 )==0){
			snake_len++;
		}
		dg.setColor( fg );
		dg.drawString( "Score: " + score , 30,30);

		score += snake_len-snake_start_len;
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=snake.class width=400 height=300></applet>
------------------------------------------------------------

#図5.4-1 <DONE>	動作中のスネークゲーム

     スケルトンプログラムにどのように変更を加えていくか、順を追ってみましょ
     う。

       1. スケルトンをコピーします。
       2. クラスの名前をgameからsnakeに変更します。
       3. スケルトンは周期が500ミリ秒なので、30ミリ秒に変更しています。周期
          は intervalという変数に格納されています。その初期化部分を変更します。
       4. 蛇の体を管理するために、double型の配列を宣言します。snake_x,snake_y
       5. 蛇の速度や頭の位置をあらわす変数を宣言します。
		snake_dir,snakehead_x,snakehead_y
       6. 蛇のサイズをあらわす、snake_xsiz,snake_sizを宣言します。
       7. 蛇は4方向で、右や左に回る操作なので、回転系にします。 dx、dy
          配列を宣言します。
       8. keyDownメソッドを作ります。
       9. 蛇の移動部分moveSnake()を書きます(普通はここで試行錯誤があるでしょう)
      10. 蛇の体を描画する部分drawSnake()を書きます。
      11. doItの中に蛇が長くなっていく処理を書きます。これは微調整です。
      12. doItの中にスコア表示の処理を書きます。

     このプログラムをする時には基本に忠実に、まずそのゲームが成立するために
     どうしても 必要な部分からまず作ります。スコア表示や難度調節などは最後で
     よいのです。 最後に柔軟な難度調節をしやすいようにプログラムしておくことが
	 大切です。最も重要な部分は、やはり蛇の移動と操作ですから、それをまず
     作ります。 必要な変数はプログラムを進めていく途中にいくつか出てきます
     が、それらはどんどん追加して いきましょう。

     このプログラムでぜひ学んでほしいことを順を追って説明します。


       5.4.1 回転系

          スネークゲームでは、蛇は、進行方向を持っています。常にその方向に進
	      んでいくわけです。 そしてキーボードを使って右や左に回転させること
          によって操作します。右や左に回るという ことを、変数の値を加えたり
          減らしたりすることによって実現できれば、簡単そうです。 そのため
          に、蛇の方向を記憶しておくためのsnake_dirという変数を 用意し
          ました。これは、常に0から7の値を取ります。右回転で1増加し、左回転
          で1減少します。 この例では、0という値が真上をあらわし、右に回転し
          ていって3が左になります。 このように扱うと、次のような配列を定義し
          ておくことにより、方向から座標へと 簡単に結びつけることができま
          す。(回転系の考えかたをもっと掘りさげて、方向の数も無限にすると、
		  極座標系を使うという話になってきます。それについては、この章の
		  第7節で取りあつかっています。参考にしてください。)

#図5.4.1 <NOT YET>         方向とベクトルの対応


		  double dx[] = { 0,1.41,2,1.41,0,-1.41,-2,-1.41};
		  double dy[] = { -2,-1.41,0,1.41,2,1.41,0,-1.41};

          この配列の要素番号(インデクス)に方向snake_directionを直接入れてや
          れば、

          x = dx[ snake_dir ];
          y = dy[ snake_dir ];

          というようにして座標(移動量ベクトル)を求めることができます。このゲ
          ームでは8方向ですが、 簡単にn方向に拡張できます。
          キー操作すると、snake_dirが7の時にも右に回転で きますか
          ら、その時も同じように計算すると、8という値になり、配列の インデク
          スの範囲を越えてしまいますから、次のようなプログラムで
          制限する 必要があります。

		  if( snake_dir >= 7 ) snake_dir-=8;
		  if( snake_dir < 0 )snake_dir +=8;

          このやりかたは、一度に9以上の方向の変化がある場合は正しく処理され
          ない(つまり、 7という方向から9右に回転すると、補正しても8になって
		  しまいます。これを、どんなに大きな角度 回転してもよいようにするには、
          方向の数が2の累乗になっている時はビット演算を使用して

          snake_dir = snake_dir & 7;

          とするとよいでしょう。



       5.4.2 遠い記憶は配列に保存

          ここでいう遠い記憶とは、蛇の尻尾の位置のことです。このゲームでは、
          尻尾のひとつひとつは、蛇の頭より、
		  snake_unitループ 遅れて移動していくので、昔頭が通った場所を憶えて
          おく必要があるのです。 これを簡単に実現するには、配列に蛇が通って
          いった位置を連続的に記録 すればよいのです。この例では配列のどの位
          置に頭を記憶していくかを、ループカウンタcronを利用して計算していま
		  す。

#図5.4.2-1 <NOT YET>       蛇の移動と、配列のインデクスの対応


          配列は前から順ぐりに使っていきます。そして最後までいくと、最初に
          戻ります。それを計算するのは次の式です。 またもや剰余演算子
		  '%'を使います。

          ind = cron % snake_max;  

		  位置記憶用配列にアクセスする時はかならずこのように剰余を使うように
		  すれば、配列の長さが無限であるかのように扱うことができます。それを	
 		  図にすると次のようになります。

#図5.4.2-2 <NOT YET>        配列の中身がループしていると考える


          このようにして求めたインデクスindを使って、記憶用配列に位置を記憶しま
          す。indは上で求めたものとすると

	  	  snake_x[ind ] = snakehead_x;
		  snake_y[ind ] = snakehead_y;

          ここまでで、蛇のsnake_maxループ前までの位置の記憶が、この配列の 中
          に順番に記憶されていることになりますね。尻尾を描画するときに、これ
          をどうやって 利用するかです。たとえば50ループ遅れている位置は、次
          のようにして知ることができます。

          x50before = snake_x[ (cron-50)%snake_max ];  //かならず%snake_maxする
          y50before = snake_y[ (cron-50)%snake_max ];

          ということは、蛇の各節の位置は,節番号を前から0、1、...Nと振っていくと 
		  それぞれ
		  int index = i * snake_unit;

		  で計算されるindexループ遅れた位置にいるのですから、indexを今求めた
		  値とすれば、

		  tmpx[i] = snake_x[(cron-index)%snake_max];
		  tmpy[i] = snake_y[(cron-index)%sbake_max-index];

          というようにすればよいことになります。snake.javaにおいては、当たり
		  判定の時だけ必要な情報なので、その時に計算しています。すべての節の
		  位置を求めてから、頭と当たっているかどうかを調べています。ここで
		  使っている衝突判定のアルゴリズムについては、次の章で詳しく説明します。


     以上がこのサンプルゲーム「スネーク」でのポイントです。ゲームプログラミ
     ングばかりでなく プログラミング全体にとって、「配列」はかくも重要です。
     いろいろな配列の使いかたを 勉強してください。




5.5 当たり判定

	 アクションゲームを作っていると、複数の物同士がお互いに衝突する、という
	 状況に出くわします。典型的には、シューティングゲームの自機の弾(複数)と、
	 敵の弾(複数)との衝突です。それぞれの衝突をどのように判定したらよい
	 でしょうか。この節では、その模範となるプログラムを示し、今後の役に立て
	 ます。	 では、早速、プログラムの全体を掲載します。


File name: atari.java
----------------------------------------------------------
import java.awt.*;
import java.awt.image.*;
import java.util.*;

public class atari extends java.applet.Applet implements Runnable
{
	Thread thread;
	Image double_buffer;
	Graphics dg;
	int cron=0;

	// 変更可能個所

	int width ,height;
	int interval = 50;	// milli second 

	Choice cho;

	public void init(){
		thread = new Thread(this);
		width = size().width;
		height = size().height;
		double_buffer = createImage( width , height );
		dg = double_buffer.getGraphics();

		setLayout( new BorderLayout() );
		initBox();
		thread.start();
	}
	public void paint( Graphics g ){
		g.drawImage( double_buffer , 0 , 0 , null );
	}
	public void update( Graphics g ){
		paint( g );
	}
	public void run(){
		while( true ){
			try{ 
				Thread.sleep( interval );
			} catch( InterruptedException e ){}
			doIt();
			repaint();
		}
	}
	
	int maxnum=100;							// 最大の箱の個数
	int nownum=1;							// 現在の箱の個数
	double bx[] = new double[maxnum];		// 位置のX座標
	double by[] = new double[maxnum];		// 位置のY座標
	double bxsiz[] = new double[maxnum];	// 箱の幅
	double bysiz[] = new double[maxnum];	// 箱の高さ
	double bdx[] = new double[maxnum];		// X方向の移動量
	double bdy[] = new double[maxnum];		// Y方向の移動量
	boolean bfill[] = new boolean[maxnum]; //何かに当たった時に点滅させるフラグ

	void initBox(){
		for(int i=0;i<maxnum;i++){
			bx[i] = ( width * Math.random());
			by[i] = ( height * Math.random());
			bdx[i] = (-4.0 + 8.0*Math.random());
			bdy[i] = (-4.0 + 8.0*Math.random());
			bysiz[i] = (20.0 + 40.0*Math.random());
			bxsiz[i] = (20.0 + 40.0*Math.random());
			bfill[i] = false;
		}
	}

	double react = 17;  // 大きいほど緩やかな反射になる。割り算の定数
	void moveBox(){
		double before_x , before_y;
		for(int i=0;i<nownum;i++){
			before_x = bx[i];
			before_y = by[i];
			bx[i] += bdx[i];
			by[i] += bdy[i];
			for(int j=0;j<nownum;j++){
				if( i == j )continue;
				if( check( bx[i] , by[i], bxsiz[i] , bysiz[i] , 
						  bx[j] , by[j] , bxsiz[j] , bysiz[j] ) ){
					bfill[i] = true;
					double relx , rely;   // 箱の中心の相対位置関係。
					relx = (bx[j]+bxsiz[j]/2) - (bx[i]+bxsiz[i]/2);
					rely = (by[j]+bysiz[j]/2) - (by[i]+bysiz[i]/2);

					bdx[i] = -relx / react;  // お互いを離す
					bdy[i] = -rely / react;
					bdx[j] = relx /  react;
					bdy[j] = rely /  react;
				}
				// 壁に当たったら、移動方向の符号を変える。
				if( bx[i] < 0 ){ bx[i]=0;bdx[i]*=-1;bfill[i]=true;}
				if( bx[i]+bxsiz[i] > width ){
					bx[i]=width-bxsiz[i];bdx[i]*=-1;bfill[i]=true;
				}
				if( by[i] < 0 ){ by[i]=0;bdy[i]*=-1;bfill[i]=true;}
				if( by[i]+bysiz[i] > height ){
					by[i]=height-bysiz[i];bdy[i]*=-1;bfill[i]=true;
				}
			}
		}
	}

	// 当たり判定。心臓部です。正確に四角の範囲。
	boolean check( double x1, double y1 , double x1size , double y1size ,
				  double x2 , double y2 , double x2size , double y2size ){
		return( x2 <= (x1+x1size) && x1 <= (x2+x2size ) &&
			    y2 <= (y1+y1size) && y1 <= (y2+y2size) );
	}
	// マウスのボタンを押すと箱が増えます。
	public boolean mouseDown( Event e , int x , int y){
		bx[nownum] = x;
		by[nownum] = y;
		nownum++;
		return true;
	}
	void doIt(){

		// 箱を動かす。
		moveBox();
		
		dg.setColor( Color.white );
		dg.fillRect( 0 , 0 , width , height );
		dg.setColor( Color.black  );

		// 全部描画する。
		for(int i=0;i<nownum;i++){
			if( bfill[i] ){
				dg.fillRect( (int)bx[i] , (int)by[i] ,
							(int)bxsiz[i] , (int)bysiz[i]);
				bfill[i] = false;
			} else {
				dg.drawRect( (int)bx[i] , (int)by[i] ,
							(int)bxsiz[i] , (int)bysiz[i]);
			}
		}
	}
	public void destroy()
	{
		thread.stop();
	}
}
----------------------------------------------------------

File name: test.html
----------------------------------------------------------
<applet code=atari.class width=400 height=300></applet>
----------------------------------------------------------

#図5.5-1 <DONE>	実行中画面(atari.java)

	 appletviewerのウインドウの中でマウスボタンを押すと、その場所に箱が
	新しく出現します。それぞれの箱はランダムな方向に移動を始め、壁か
	他の箱に当たると反射します。反射するかどうかを判定しているのが、当たり
	判定用のメソッドの、 boolean check( double..... )です。
	このメソッドに、衝突しているかどうか判定したい二つの箱の座標とサイズを
	代入すれば、衝突しているかどうかがbooleanの値として得られます。
	値がtrueだと当たっています。このメソッドが当たり判定(衝突判定)の心臓部
	です。なぜこの不等式で当たり判定ができるのかは、次の図を見れば一目
	瞭然です。(筆者はこの方法を思いつくまでは、絶対値の差を使って
	当たり判定をしていました。絶対値の差では、大きさの異なる敵を出したとき
	に困ったことになるのでした。)

#図5.5-2 <NOT YET>	当たり判定の不等式の意味


	  ゲームプログラムにおいては、ほとんどの場合(3Dポリゴンゲームにおいても
	いまだに多用されます)四角形の当たり判定ルーチンが使われます。
	キャラクタの形には、丸や三角、もっと変な形もいろいろありますが、それらの
	場合も、その内部に含まれるような四角形を使って衝突判定をしているのが
	普通です。

#図5.5-3 <NOT YET>	当たり判定はキャラの内部に設定します。
	ボスなど複雑な形のものは四角をいくつか組みあわせればOK


	プレイヤーにとって有利なアイテムなどは大きめの当たり判定にしておき、
	敵などは外見よりも小さくしておきましょう。


	当たり判定以外では、反射の処理が記憶に値します。この例では、箱の中心同士
	の相対的な位置関係を調べて、お互いが反発しあうような向きに移動量を設定し
	ています。その結果、たくさん箱を入れても、重なりにくいようになっています。

#図5.5-4 <NOT YET>	お互いの中点に対称に移動量が設定される

	 
	このような効果を使えば、コナミの名作「グラディウスII」以降で見られるような、
	撃つと割れる氷がお互いに反射している場面とか、壁に当たった氷がくっついて
	いく、といった演出ができます。

	



5.6 キャラクタの移動アルゴリズム色々

     プレイヤーキャラクタ、つまり主人公、自機などが自分の思った通りに移動し
     なくて、 イライラした経験はありませんか？プレイヤーキャラクタの移動の出
     来のよしあし は、ゲームの出来のよしあしに深く影響を与えます。
     javaによるゲームプログラミングにおいては、プレイヤーキャラクタの操作
     は、 ジョイスティックを使えないため、その代わりになるキーボード入力と、
     マウス入力との2種類に大別できます。
     ジョイスティックに比べると、キーボードは、かなり操作しづらい(さらにjava
     では、 第4章「キーボードの入力」で述べたようにキーリピートの問題もあり
     ます)上に、 マウスというデバイスが使えるということもあり、アプレットに
     おいては まずマウスを使ったゲームを作ることを考えるのが普通だと思いま
     す。 しかし、やはりゲームプログラミングを語る上では、ジョイスティックに
     よる 操作に触れないわけにはいきません。この節では、ジョイスティックやキ
     ーボード を使用する場合にプレイヤーキャラクタの移動に使われるアルゴリズ
     ムのうち 代表的なものの解説をしたいと思います。
     この節は、京大マイコンクラブの中西英之さんの寄稿によるものです。

     プレイヤーキャラクタの移動とは、プレイヤーからのジョイスティック入力に
     よって、 キャクラクタの座標を変化させることです。どのように座標の変化さ
     せていくかは ゲームによって千差万別ですが、基本となる部分は共通です。こ
     こでは、それらの アルゴリズムを4つに分類して解説します。解説には2次元の
     座標系を用いますが、 その他の座標系にも簡単に拡張することができます。
     解説では、次の変数を共通して使います。

      double x,y           : 主人公の(x,y)座標
      double dx,dy         : 主人公の(x,y)方向の速度
      double ddx,ddy       : 主人公の(x,y)方向の加速度
      int input_x,input_y  : プレイヤーからの入力

     キャラクタの移動は常に次の式で計算されます。
      x = x + dx;
      y = y + dy;

     このdxとdyをどのように変化させていくかに、 腐心しているわけです。 さ
     て、キャラクタの移動アルゴリズムは、4つに分類できます。 それぞれについ
     て解説し、そのあと、これらの全てを含むプログラム例を示します。

       5.6.1 等速アルゴリズム
           dx = input_x;
           dy = input_y;

          キャラクタは、等速直線運動をします。最も基本的で単純で、よく使われ
          ます。 プレイヤーの予測通りにキャラクタが正確に移動しなければなら
          ないような ゲーム(特にシューティング)ではよく用いられます。 プログ
          ラム例の中では、input_xとinput_yは直接使わず、 方向を求めてから間
          接的に使用しています。

#図5.6.1 <NOT YET>         入力ON/OFFからの速度の立ちあがりグラフ(tousoku)

       5.6.2 慣性アルゴリズム
           ddx = input_x;
           ddy = input_y;

           dx = dx + ddx;
           dy = dy + ddy;

          プレイヤーが加速度を入力しない限り、速度は変化せず、キャラクタは等
          速直線運動 を続けます。宇宙空間や空中での、ふわふわした移動を再現
          できます。このアルゴリズム をY座標にだけ用いてしかも加速度を一定に
          すれば、スーパーマリオなどのような ジャンプに応用できます。

#図5.6.2 <NOT YET>         入力ON/OFFからの速度の立ちあがりグラフ(kansei)


          この式だけでは、プレイヤーが同じ方向に入力し続けると、dx、dy は際
          限なく増加/減少してしまうので、制限する必要があります。制限のやり
          かたを 2種類紹介します。

            1. dx,dyを別々に一定範囲内に保つ方法

               次のように定数を定義します。
                XMIN : dxの最小値
                XMAX : dxの最大値
                YMIN : dyの最小値
                YMAX : dyの最大値

               プログラムは次のようなものになります。if文を使って、素直に範
               囲 を制限しています。
                if (dx < XMIN) {
                    dx = XMIN;
                } else if (dx > XMAX) {
                    dx = XMAX;
                }
                if (dy < YMIN) {
                    dy = YMIN;
                } else if (dy > YMAX) {
                    dy = YMAX;
                }

            2. 速さ(速度ベクトルの長さ)を一定範囲内に保つ方法
               次のように定数やメソッドを定義します。

                speed      : 速さ
                MAXSPEED   : 速さの最大値
                sqrt()     : 平方根を求めるAPIメソッド

               プログラムは次のようになります。

                speed = Math.sqrt(dx * dx + dy * dy);
                if (MAXSPEED < speed) {
                    dx = dx * MAXSPEED / speed;
                    dy = dy * MAXSPEED / speed;
                }

               速度が範囲を越えた場合、元のdx,dyの比率を保ったままでベクトル
               長を制限しな ければならないため、かけ算をすることによって調整
               しています。

       5.6.3 終端アルゴリズム

          定数RESISTを空気抵抗のような抵抗係数とします。

           ddx = input_x;
           ddy = input_y;

           dx = dx + ddx - dx * RESIST;
           dy = dy + ddy - dy * RESIST;

          この内容は高校2、3年の物理に出てくるものです。
          ddxとdx * RESISTが等しくなると、dxは変化し なくなります。dxとdyが
          両方ともその状態になると、 速度は変化しなくなる、つまり終端速度に
          達っしたことになります。 dx、dyはそれぞれ一定範囲内に保たれ、範囲
          の広 さは抵抗係数RESISTの値によって決まります。範囲の形状はddx
          、ddyの形状と同じになるので、速さ(速度ベクトル長)を一定範囲内に 保
          ちたいときは、ddx、ddy(すなわち、input_xと input_yのベクトル長が一
          定になるようにすればよいことになります。) これは慣性アルゴリズムの
          拡張版ともいえ、ゲームの中で用いられる場面も慣性アルゴリズム と似
          ています。特に、空気中や水中といった抵抗のある場面での移動に使われ
          ます。

#図5.6.3 <NOT YET>       入力ON/OFFからの速度の立ちあがりグラフ(syuutan)


       5.6.4 漸近アルゴリズム

          定数を次のように定義します。

           RATE : dx, dyの変化率で、1未満の正の値

          そうするとプログラムは次のようになります。

           dx = dx + (input_x - dx) * RATE;
           dy = dy + (input_y - dy) * RATE;

          dx、dyの変化量は、それぞれinput_x 、input_yの差が大きいほど大き
          く、差が小さくなるほど小さくなり ます。キャラクタの移動は、徐々に
          プレイヤの入力値に収束していくように変化 します。ジョイスティック
          の入力そのままにキャラクタが移動するよりも、プレイヤ の入力に滑ら
          かに従っていくような移動をさせたいときに用いられます。

#図5.6.4 <NOT YET>       入力ON/OFFからの速度の立ちあがりグラフ(zenkin)


     ゲーム内容に合わせて、これらのアルゴリズムを適切に使いわけて プレイヤキ
     ャラクタの移動を魅力的なものにすれば、きっとプレイヤをゲームに引きこむ
     ことができるでしょう。 最後に、Javaで上記のアルゴリズムを実装した例を示
     します。 input_xとinput_yは、直接には入力データとして 使えないので、
     dir2Xとdir2Yという配列を媒体として、 計算に使える入力データに変換してい
     ます。 その変換をするのが、int calcDirection(boolean cursor[])メソッド
     です。その他の部分は、だいたい解説と同じになっています。



File name: player.java
------------------------------------------------------------
public class player {
	public final int TOSOKU = 0, KANSEI = 1, SHUTAN = 2, ZENKIN = 3;
	final double HR2 = Math.sqrt(2) / 2;
	final double dir2X[] = {0, HR2, 1, HR2, 0, -HR2, -1, -HR2, 0};
	final double dir2Y[] = {-1, -HR2, 0, HR2, 1, HR2, 0, -HR2, 0};

	double  x, y, dx, dy;
	int     width, height, size;
	double  speed, accel, resist, rate;

	player(int width, int height, int size, 
		double speed, double accel, double rate) {
		this.width = width;
		this.height = height;
		this.size = size;
		this.speed = speed;
		this.accel = accel;
		this.rate = rate;

		x = this.width / 2;
		y = this.height / 2;
		resist = this.accel / this.speed;
		dx = dy = 0.0F;
	}

	public double getX() {return x;}
	public double getY() {return y;}

	public void move(boolean cursor[], int mode) {
		int direction = calcDirection(cursor);

		switch (mode) {
			case TOSOKU:
			calcTosoku(direction);
			break;
			case KANSEI:
			calcKansei(direction);
			break;
			case SHUTAN:
			calcShutan(direction);
			break;
			case ZENKIN:
			calcZenkin(direction);
			break;
		}

		x += dx;
		y += dy;

		if (x < 0) {
			x = 0;
		} else if (x > width - size) {
			x = width - size;
		}
		if (y < 0) {
			y = 0;
		} else if (y > height - size) {
			y = height - size;
		}
	}

	int calcDirection(boolean cursor[]) {
		int input_x = 0, input_y = 0;

		if (cursor[3]) {
			if (!cursor[1]) {
				input_x = -1;
			}
		} else {
			if (cursor[1]) {
				input_x = 1;
			}
		}

		if (cursor[0]) {
			if (!cursor[2]) {
				input_y = -1;
			}
		} else {
			if (cursor[2]) {
				input_y = 1;
			}
		}

		// 真上が0で右回りに7まで。入力無しは8
		if (input_x > 0) {
			if (input_y > 0) {
				return 3;
			} else if (input_y < 0) {
				return 1;
			} else {
				return 2;
			}
		} else if (input_x < 0) {
			if (input_y > 0) {
				return 5;
			} else if (input_y < 0) {
				return 7;
			} else {
				return 6;
			}
		} else {
			if (input_y > 0) {
				return 4;
			} else if (input_y < 0) {
				return 0;
			} else {
				return 8;
			}
		}
	}

	void calcTosoku(int direction) {
		dx = dir2X[direction] * speed;
		dy = dir2Y[direction] * speed;
	}

	void calcKansei(int direction) {
		double sp;

		dx += dir2X[direction] * accel;
		dy += dir2Y[direction] * accel;
		sp = Math.sqrt(dx * dx + dy * dy);
		if (sp > speed) {
			dx = dx * speed / sp;
			dy = dy * speed / sp;
		}
	}

	void calcShutan(int direction) {
		dx += dir2X[direction] * accel - dx * resist;
		dy += dir2Y[direction] * accel - dy * resist;
	}

	void calcZenkin(int direction) {
		dx += (dir2X[direction] * speed - dx) * rate;
		dy += (dir2Y[direction] * speed - dy) * rate;
	}
}

------------------------------------------------------------

     このプログラムは、それ自体にはアルゴリズムしかないので、他の表示などを
     する クラスと結合する必要があります。このクラスを呼びだして使うクラスの
     ソースを 示します。(もちろんこれもゲームのスケルトンプログラムが元にな
     っています。) 簡便のため、珍しくコンポーネントを使用してアルゴリズムを
     選択するように なっています。


File name: game.java
------------------------------------------------------------
import java.awt.*;
import java.awt.image.*;
import java.util.*;

public class game extends java.applet.Applet implements Runnable
{

	Thread thread;
	Image double_buffer;
	Graphics dg;

	int cron=0;

	public int width,height;                        // 単位はピクセル
	public final int interval = 50;         // ミリ秒

	MenuBar mb;
	player p ;

	int mode = 0;
	Choice c;

	public void init()
	{
		setLayout( new BorderLayout() );

		c = new Choice();

		c.addItem("tosoku");
		c.addItem("kansei");
		c.addItem("shutan");
		c.addItem("zenkin");
		add( "South",c );

		width = size().width;
		height = size().height;

		thread = new Thread(this);
		double_buffer = createImage( width , height );
		dg = double_buffer.getGraphics();

		thread.start();

		//変更可能個所

		p = new player( width , height ,8 ,(double)4 ,(double)1,(double)0.1 );
		mode = p.TOSOKU;

	}

	public void paint( Graphics g )
	{
		g.drawImage( double_buffer , 0 , 0 , null );

	}
	public void update( Graphics g )
	{
		paint( g );
	}
	public void run()
	{
		while( true )
		{

			cron++;

			try{
				Thread.sleep( interval );
			} catch( InterruptedException e ){}

			doIt();
			repaint();
		}

	}

	final int UP = 1004;
	final int DOWN = 1005;
	final int LEFT = 1006;
	final int RIGHT = 1007;

	boolean down[] = new boolean[4];

	public boolean keyDown( Event e , int key){

		if( key == UP ) down[0] = true;
		if( key == RIGHT ) down[1] = true;
		if( key == DOWN ) down[2] = true;
		if( key == LEFT ) down[3] = true;

		return true;
	}
	public boolean keyUp( Event e , int key ){

		if( key == UP ) down[0] = false;
		if( key == RIGHT ) down[1] = false;
		if( key == DOWN ) down[2] = false;
		if( key == LEFT ) down[3] = false;

		return true;
	}

	void doIt()
	{

		// 変更可能個所
		// ここにプログラムを加えていってみましょう。
		dg.setColor( Color.white );
		dg.fillRect( 0 ,0, 300,50 );
		dg.setColor( Color.black );
		dg.drawString( Integer.toString( cron ) , 0 ,20  );
		p.move( down , mode );
		draw();

	}
	void draw()
	{
		dg.setColor( Color.white);
		dg.fillRect( (int) p.getX() - 10 , (int)p.getY()-10 , 30,30);
		dg.setColor( Color.black );
		dg.fillRect( (int) p.getX() , (int)p.getY() , 8,8 );

	}

	public boolean action( Event e , Object o ){
		if( e.target == c ){
			String s;
			s = o.toString();
			if( s.equals("kansei")){
				mode = p.KANSEI;
			}
			if( s.equals("tosoku")){
				mode = p.TOSOKU;
			}
			if( s.equals("shutan")){
				mode = p.SHUTAN;
			}
			if( s.equals("zenkin")){
				mode = p.ZENKIN;
			}
			System.out.println( e );
			System.out.println( o );
		}
		return true;
	}
	public void destroy()
	{
		thread.stop();
	}
}
------------------------------------------------------------

File name: test.html
------------------------------------------------------------
<applet code=game.class width=500 height=400></applet>
------------------------------------------------------------

図5.6.4-2 <DONE>    動作中の画面(player.java)

     操作は、キーボードのカーソルキーを使用します。キーボードにカーソルキー
     がない 場合は、UP、DOWN、LEFT、RIGHT の定数がキーコード(keyDownメソッド
     の引数として得られる値) になっていますので、それを適宜変更してくださ
     い。アルゴリズムの変更は、 左下に表示されているメニューからドラッグして
     選びます。
     player.javaの内容は、簡単に流用できるようになっていて、もちろんフリー 
	ですので、存分に利用してください。





5.7 極座標系を使って、楽しい動きを！
	
	さらに発展的な内容になっていきますが、この節では、今までと違った
	キャラクターの管理・操作方法を説明します。なお、この節も、京大マイコン
	クラブの中西英之さんの寄稿によるものです。

	まず言葉の説明をしておきます。

	o 直交座標系： X軸とY軸が直角に交わる座標系。位置を表すには、
	X座標とY座標の2種類の情報が必要。

#図5.7-1 <NOT YET>	直交座標系

	o 極座標系： 距離と角度で位置を表す座標系。位置を表すには、距離と
	角度の2種類の情報が必要。

#図5.7-2 <NOT YET>	極座標系
	
    これまでのサンプルプログラムでは、すべて、キャラクタたちの位置は、
	直交座標系で表していたことはおわかりですね。それはなぜかというと、
	プログラムする時に使う、
	
	 g.drawLine( x1 , y1 , x2, y2 );

	というような描画のためのメソッドが直交座標系を採用しているからです。
	キャラクタの管理方法もそれにあわせていたわけです。

	しかし、ゲームの中でキャラクタに「ゲームらしい」つまり楽しませる動きを
	させるには、直交座標系よりも、極座標系を使ったほうが効果的なのです。
	ここで想定している楽しい動きには、
	「クルクル回る」「追いかける」「ふわふわ飛ぶ」「ジャンプ」
	「とつぜん引きかえす」「行きすぎる」「ぶつかる」「カクカク曲がる」
	「扇形に弾をまきちらす」などなど、いろいろなバリエーションがあります。
	この中には前節で説明したような、漸近移動や慣性移動を使って実現できる
	ものもあります。しかし、特に関数化しにくい動作つまりXとYが一対一に
	対応しないような動作をさせるには、極座標系を使わないとほぼ無理です。
	例えば、「ハチが8の字を描いて一定速度で飛ぶ」という動作を直交座標系を
	使って実現するのは、非常に困難です。

#図5.7-3 <NOT YET>	ハチが8の字を描いて飛ぶ

	ところが、極座標系を使うと、ハチの速度と向きに注目しますから、ハチの	
	動きは、「速度は一定で、最初の一周分は向きに対して右に旋回、
	次の一周分は左旋回。回転量は常に一定。」という単純な計算で済むのです。
	このように極座標系を使う価値は十分にあります。極座標系と直交座標系を
	うまく組みあわせて、より面白い動きを作りだしましょう。
	
	さて、実際のプログラムにおいては、どのようにすればよいのかを、以下で
	解説していきます。

	* 使う記号

--------------------------
 dx , dy     : 速度(直交座標系)
 r , theta   : 速度(極座標系)
--------------------------
	ただし、thetaは次の条件を満たすものとします。(thetaに制限をつけるための
	メソッドを用意するということです。)


	5.7.1 座標系の間での変換方法

	・直交座標系(dx, dy) −＞ 極座標系(r, theta)

	   (dx, dy)からthetaを計算するメソッドを以下のように定義します。
-------------------------------   
    double   Delta2Theta(double dx, double dy)
    {
        if (dx > 0) {
            if (dy >= 0) {
                return Math.atan(dy / dx);
            } else {
                return Math.atan(dy / dx) + 2 * Math.PI;
            }
        } else if (dx < 0) {
            return -Math.atan(dy / -dx) + Math.PI; 
        } else {
			return 0;
		}
    }
-------------------------------   
   すると、変換は次の2式で表されます。

   r = Math.sqrt(dx * dx + dy * dy);
   theta = Delta2Theta(dx, dy);

   ・極座標系(r, theta) −＞ 直交座標系(dx, dy)
	
	この場合は簡単で、三角関数を使えば次の2式で変換することができます。
-------------------------------   
   dx = r * Math.cos(theta);
   dy = r * Math.sin(theta);
-------------------------------   

	ここまでの知識で、シューティングゲームで多用される、自機に向かって
	まっすぐに飛んでくる弾が実現できます。では、敵が自機に向かって弾を
	発射して攻撃してくる場合を考えてみましょう。これは、弾を発射する処理
	と、その後弾が飛んでいく処理に分かれます。


    ここで使用する各変数の意味は次の通りです。

-------------------------------   
   自分の座標           : mx, my
   敵の座標             : ex, ey
   弾の座標             : sx, sy
   弾の速度(直交座標系) : dx, dy
   弾の速度(極座標系)   : s_r(速さ), s_theta(角度)
-------------------------------   

    まずは弾を発射する処理ですが、弾は敵から発射されますから、弾の座標は
    最初は敵の座標と同じです。

    sx = ex;
    sy = ey;

    弾が自機の方向に発射されるように直交座標系から極座標系への変換を用い
    て角度を計算します。自分と敵の座標が分かっているとすると、弾を発射す
    る角度は次のように計算します。

    s_theta = Delta2Theta(mx - ex, my - ey);

    弾の速さは定数SHOT_SPEEDとして定義されているものとすると、

    s_r = SHOT_SPEED;

	と初期化できます。
    後の、弾が飛ぶ処理のために極座標系から直交座標系への変換を用いて座標
    増分を計算します。

    dx = s_r * Math.cos(theta);
    dy = s_r * Math.sin(theta);

	この処理も、初期化時に一度行なうだけです。
    次に弾が飛ぶ処理ですが、弾が等速直線運動する場合は移動する度に次の計算を
	行うだけです。移動量が一定となります。dxとdyは、途中で変化しないからです。

    sx += dx;
    sy += dy;

    もし、弾が途中で曲がる場合や加減速する場合は、s_thetaやs_rを更新し、
    dx, dyを計算し直した後、上の計算をすることになります。例えば、弾が自
    分を追いかけてくるようにしたい場合は、定期的に次の計算によって
    s_thetaを更新してやります。

    s_theta = Delta2Theta(mx - sx, my - sy);


	5.7.2 角度を扱うための判定関数群

    速さ(r)に比べて、角度(theta)を扱うにはちょっとしたコツが必要です。角度
    (theta)を扱うときに知っておくと便利なメソッドを3つほど挙げます。このあたり
	のメソッドは、後で再利用しやすいようにしておくと、ゲームを新しく作るとき
	に非常に便利です。

    * メソッド InRange

	処理内容 : 相手が自分の前方のある一定範囲の角度にいるかどうか判定する
    返り値   : 範囲内にいる場合は1、そうでない場合は0
    引数     : me   ...  自分の角度
	         : you  ...  相手の角度
		     : range ... 角度の範囲

#図5.7.2-1 <NOT YET>	自分の角度と相手の角度

------------------------
int InRange(double me, double you, double range)
{
    double   dtheta = Math.abs(me - you);
    if (dtheta <= range) return 1;
    else return 0;
}
------------------------

	* メソッド RightLeft

  	処理内容 : 目標の角度を向くには左右のどちらに回転するべきか判定する
    返り値   : 右回転(正の方向)の場合は1、左回転(負の方向)の場合は-1
    引数     : now   ...  現在の角度
             : target ..  目標に対する角度

#図5.7.2-2 <NOT YET>	現在の角度と目標への角度

------------------------
int RightLeft(double now, double target)
{
    if (now < Math.PI) {
        if (now < target && target <= now + Math.PI) return 1;
        else return -1;
    } else {
        if (now - Math.PI < target && target <= now) return -1;
        else return 1;
    }
}
------------------------

    * メソッド  ForBack

    処理内容 : 相手が自分の前方にいるのか後方にいるのか判定する
    返り値   : 前方にいる場合は1、後方にいる場合は-1
    引数     : me   ...  自分の角度
	         : you  ...  相手に対する角度

#図5.6.2-3 <NOT YET>	forbackの値

------------------------
int ForBack(double me, double you)
{
    me -= Math.PI / 2.0;
    if (me < 0.0) me += 2.0 * Math.PI;
    return RightLeft(me, you);
}
------------------------

   5.7.3 極座標系を用いた移動アルゴリズムの例：猪突猛進キャラ


   ここでは実際に極座標系を用いた移動アルゴリズムの例として、マウスカーソ
   ルに向かって猪突猛進してくるキャラクタ(Mario64の「ボムへい」の動きを
	思いうかべてください。)のプログラムを示します。先に上げ
   た3つの関数をそれぞれ用いていますので参考にしてください。

    クラスmoshinは、移動のアルゴリズムだけを抽出したものなので、それを
    表示に結びつけるものが必要です。そのために、第4章で紹介した
    ゲームのスケルトンプログラムを使います。これらのファイルは別々になって
    います。別々にコンパイルして、実行する時にjavaが自動的に読みこみます。
	スケルトンプログラムは、game.javaで、キャラクタのアルゴリズムは、
	moshin.javaの中に記述されています。

	このプログラムを書くにあたっては、表示部分を筆者が書き、それとは全く別に
	アルゴリズム部分を中西英之さんがプログラムしました。そしてそれぞれの
	プログラムの連絡部分、つまり 
	getX() , getY() , getTheta() , Move()
	といったメソッドの仕様だけをしっかり決めておけば、あとはお互い、中身
	のことについては一切知らなくてよいわけです。このあたりが、オブジェクト指向
	の言語を使うことによって分担がやりやすくなる、典型的な例でしょう。
	

	以下に、moshin.java , game.java , test.html の3つを連続で示します。


File name: moshin.java
----------------------------------------------------
class moshin {
    final double MAXSPEED = 12.0, ACCEL = 1.0, MUKU = Math.PI / 15.0;
    final int WAIT = 15;
    final int SEARCH = 0, ATTACK = 1;
    
    double x, y, r, theta;
    int width, height, size, phase, count;

    moshin(int width, int height, int size) {
		this.width = width;
		this.height = height;
		this.size = size;
		x = this.width / 2.0;
		y = this.width / 2.0;
		theta = r = 0.0;
		count = phase = 0;
    }

    public double getX() {return x;}
    public double getY() {return y;}
    public double getTheta() {return theta;}

    void LimitTheta() { /* thetaの値を0から2πの間に保つ */
		if (theta < 0.0) {
			theta += 2 * Math.PI;
		} else if (theta >= 2 * Math.PI) {
			theta -= 2 * Math.PI;
		}
    }

    double   Delta2Theta(double dx, double dy)
    {
        if (dx > 0) {
            if (dy >= 0) {
                return Math.atan(dy / dx);
            } else {
                return Math.atan(dy / dx) + 2 * Math.PI;
            }
        } else if (dx < 0) {
            return -Math.atan(dy / -dx) + Math.PI; 
        } else {
			return 0;
		}
    }

    int NextStep() {
		x += r * Math.cos(theta);
		y += r * Math.sin(theta);

		if (x < 0) {
			x = 0;
			return 1;
		} else if (x > width - size) {
			x = width - size;
			return 1;
		}
		if (y < 0) {
			y = 0;
			return 1;
		} else if (y > height - size) {
			y = height - size;
			return 1;
		}
		return 0;
    }

    int InRange(double me, double you, double range)
    {
		double   dtheta = Math.abs(me - you);

		if (dtheta <= range) return 1;
		else return 0;
    }

    int RightLeft(double now, double target)
    {
		if (now < Math.PI) {
			if (now < target && target <= now + Math.PI) return 1;
			else return -1;
		} else {
			if (now - Math.PI < target && target <= now) return -1;
			else return 1;
		}
    }

    int ForBack(double me, double you)
    {
		me -= Math.PI / 2.0;
		if (me < 0.0) me += 2.0 * Math.PI;
		return RightLeft(me, you);
    }

    public void Move(double cx, double cy) {
		double	target = Delta2Theta(cx - x, cy - y);

		switch (phase) {
			case	SEARCH: /* 回転してマウスカーソルの方を向く */
			++count;
			if (0 != InRange(theta, target, MUKU)) {
				if (WAIT < count) {
					phase = ATTACK;
					count = 0;
				}
			} else {
				theta += MUKU * RightLeft(theta, target);
				LimitTheta();
			}
			break;
			case	ATTACK: /* 真っ直に猛進していく */
			if (0 < ForBack(theta, target)) { /* 前方にいれば加速 */
				r += ACCEL;
				if (r > MAXSPEED) r = MAXSPEED;
			} else { /* 後方にいれば減速停止 */
				if (r > ACCEL) {
					r -= ACCEL;
				} else {
					r = 0;
					phase = SEARCH;
				}
			}
			if (0 != NextStep()) { /* 外枠に衝突したときは停止 */
				r = 0;
				phase = SEARCH;
			}
			break;
		}
    }
}
----------------------------------------------------




File name: game.java
----------------------------------------------------
import java.awt.*;
import java.awt.image.*;
import java.util.*;

public class game extends java.applet.Applet implements Runnable
{
	Thread thread;
	Image double_buffer;
	Graphics dg;

	int cron=0;

	// 変更可能個所、数値のところだけ色を変える。 

	int width ,height;
	int interval = 100;	// milli second 
	moshin mos;    

	public void init()
	{

		thread = new Thread(this);
		width = size().width;
		height = size().height;
		double_buffer = createImage( width , height );
		dg = double_buffer.getGraphics();
		mos = new moshin( width, height , 16 );
		thread.start();
	}
	public void paint( Graphics g )
	{
		g.drawImage( double_buffer , 0 , 0 , null );
	}
	public void update( Graphics g )
	{
		paint( g );
	}
	public void run()
	{
		while( true )
		{
			cron++;
			try{
				Thread.sleep( interval );
			} catch( InterruptedException e ){}
			doIt();
			repaint();
		}
	}
	double mouse_x , mouse_y;
	public boolean mouseMove( Event e , int x , int y )
	{
		mouse_x = (double) x;
		mouse_y = (double) y;
		return true;
	}
	void doIt()
	{
		mos.Move(mouse_x , mouse_y);
		
		dg.setColor( Color.black );
		
		int x = (int)mos.getX();
		int y = (int)mos.getY();
		double r = mos.getTheta();

		dg.drawOval( x-8 , y-8 , 16,16 );
		dg.drawLine( x , y ,x + (int)( Math.cos( r )*20) , y+(int)(Math.sin(r)*20));
	}
	public void destroy()
	{
		thread.stop();
	}
}
----------------------------------------------------



File name: test.html
----------------------------------------------------
<applet code=game.class width=400 height=400></applet>
----------------------------------------------------

#図5.7.3-1 <DONE>	動作結果(moshin.java,game.java)
	
	丸の中心が位置をあらわし、直線が向きを意味しています。マウスカーソル
	にむかって突進してくるキャラクタが見事に表現されています。少し行きすぎる
	あたりが、「面白さ」を出しています。そうすることで、キャラクタに「スキ」
	ができて、やっつけるチャンスが生まれるからです。


	(発展)

	このクラスは、複数のインスタンスを作ることで、同じ動きをする
	キャラクターを同時に複数出現させることができます。それには
	
	for(int i=0;i<c_number;i++){
		moshin mm[i] = new moshin( width ,height,size );	
	}	
	
	というようにして初期化した後、移動ルーチンもキャラクターの数だけ平等に呼び
	だします。それについては自分でやってみてください。




