
Java言語リファレンス

本文では、Javaの言語仕様のすべてについては説明しませんが、ここにJava 言語の
仕様とライブラリの機能の概略を掲載したいと思います。 一般的な解説の他、ゲー
ムにどのように応用するかについても解説します。 これらがゲーム作りの参考にな
ればなによりです。

言語仕様


1. 予約語

     予約語とは、Java言語において特別な意味を持つ単語で、クラスや メソッド、
     変数の名前には使えません。

      abstract        default         if              private         throw
      boolean         do              implements      protected       throws
      break           double          import          public          transient
      byte            else            instanceof      return          try
      case            extends         int             short           void
      catch           final           interface       static          volatile
      char            finally         long            super           while
      class           float           native          switch
      const           for             new             synchronized
      continue        goto            package         this


2. 名前

     名前とは、クラス、メソッド、変数の名前としてユーザーが使うことができる
     単語です。次の文字を使うことができます。

      ABCDEFGHIJKLMNOPQRSTUVWXYZ
      abcdefghijklmnopqrstuvwxyz
      0123456789$_

     最初の文字に数字を使うことはできません。
     例：
      int a, $hoge , _foo , Thank_You , Test001;

     ユニコードを使えば、もっと別な文字を使うこともできます(漢字も！)が、 こ
     こでは説明しません。(付録Dを参照)


3. コメント

     次の3種類があります。
      /*  複数行にまたがることが
          可能なコメント
      */
      /**  javadocが使う特別なコメント */
      // 行末までのコメント


4. リテラル

     リテラルとは、各種の数値や文字などのデータをプログラム中で直接記述 する
     単位のことです。以下の例では太字の部分です。

     例：
      int a = 808;
      String s = "state!";

     リテラルには、整数、小数、文字列、文字、真偽値リテラルがあります。

        o 整数リテラル

          整数リテラルは、10進数、16進数、8進数があります。
          808のように普通に数値を書くと10進数として扱われます。
          0808のように0で始めると、8進数として扱われます。
          0x808のように"0x"で始めると、16進数として扱われます。16進数は、 数
          字が16種類に足りないので、10から15を、a〜fまたはA〜Fで代用します。
          整数リテラルは無指定だとint型として扱われますが、末尾に"l"とか"L"
          が 付いている場合はlong型として扱われます。
          例:
           long c = 0xffff0000l;
           int a = 0xffff0000;

        o 小数リテラル

          3.14159とか 8080808.08080のように ピリオドを使って小数を書く他、
          3.11343345e-5のように、指数表現もできます。 末尾に何もつけないと
          double型になり、fまたはFをつけると float型になります。

        o 文字リテラル

          文字リテラルは、一文字をプログラム中に埋めこむときに使います。 通
          常はchar 型の変数に代入したり比較したりします。
          文字とは、通常文字(英数字と記号)とエスケープシーケンス(特殊機能文
          字) のことです。 エスケープシーケンスには、次のものがあります。

           表記           機能

           \b    バックスペース
           \t    タブ
           \n    改行
           \f    カーソルを一段下に移動
           \r    カーソルを行頭に戻す
           \"    "という文字を文字列に含める
           \\    \という文字を文字列に含める


           \0nnn nnnのところに8進数を指定して、000から 377までの文字コード
                 を直接指定する

           \unnnnnnnnのところに16進数4桁を指定して、 Unicodeを直接指定す
                 る。これを使用すると、アプレットで漢字を表示できる。

          例：

          'a'  '8'  '\f'  '\ua808'
          char c = '\u5004';

          理解を深めるために、次のプログラムを実行してみてください。
------------------------------------------------------------
public class hoge extends java.applet.Applet
{
	public void init()
	{
		char c = 'a';
		int i = 'a';
		System.out.println( c );
		System.out.println( i );
	}

}
------------------------------------------------------------

        o 文字列リテラル

          文字列をプログラム中に埋めこむときに使います。 文字列型(String)の
          変数に 代入します。Javaでは、文字列は "+"記号でどんどんつなげてい
          く ことができます。 エスケープシーケンスも含めることができます。
          以下の例では、sbとsc、sdは同じ内容が代入されます。 例：

          String sa = "Pacific state\n";
          int i = 808;
          String sb = "state " + i ;
          String sc = "state 808";
          String sd = "state " + "808";



5. 変数の型

     型とは、情報を記憶しておく時にメモリ上に置かれる様式のことです。 タイプ
     とも言います。 Java言語においては、型には、「基本型」と「参照型」があり
     ます。

     基本型

       1. 数値型

          基本型のうち数値型は、以下の表のものがあります。

------------------------------------------------------------
  型名   種類   wrapperクラス サイズ(bit)       最小値               最大値
   byte  整数       Byte         8               -128                 127
  short  整数      Short        16              -32768               32767
    int  整数    Integer        32            -2147483648          2147483647
   long  整数       Long        64    -9223372036854775808     9223372036854775807
  float  整数      Float        32  1.4013e-45(負でない最小)       3.40282e+38
 double  整数     Double        64         0(負でない最小)         1.79769e+308
------------------------------------------------------------

          それぞれの数値型には、最大値と最小値があり、それを越える値を代入し
          よう としたときには、値の変換が行われます。 値の変換は、整数型と浮
          動小数型で動作が異なります。 異なる型同士の代入では、型の変換をし
          てやる必要があります。 (キャストと言います。) ここで挙げている変換
          の例にあるように、 (byte)や(float) というように、変換後の型をカッ
          コでかこみます。 これがないと、コンパイル時にエラーになります。
          整数型の場合、範囲を越えるということは、 代入される変数よりもビッ
          ト幅の大きい型から、 ビット幅の小さい型への代入になります。例え
          ば、int型から、 byte型への代入などです。 この場合は、下位ビットだ
          けがコピーされます。 次の例では、byte型の変数bには、 0という値が入
          ります。

          byte b = (byte)256;

          浮動小数型の場合は、代入する値が範囲を越える場合は、 値Infが入りま
          す。「無限大」という意味です。 次のコードでは、標準出力にInfという
          文字列が 表示されます。負の無限大の場合、-Infと表示されます。

          float f = (float) 5.0e+100;
          System.out.println( f );

          それぞれの最大値や最小値は、次のようにして知ることができます。

          System.out.println( Integer.MAX_VALUE );
          System.out.println( Double.MIN_VALUE );

		ラッパー(wrapper)・クラスは、基本型の参照を渡したい時に使えます。

       2. 文字型

          文字型はcharだけです。 Javaの仮想マシンの内部では、16ビットの
          Unicodeで扱われます。 一文字を記憶します。

       3. 真偽値型

          型名はbooleanです。代入できる値は、true(真)と false(偽)の2種類のみ
          です。

     参照型

     基本型が、ただ一つの情報を記憶しておくためのものだったのに対し、 参照型
     は、ただ記憶しておく以外にも、さまざまな処理をさせることができます。 そ
     して、ユーザーは、新しいクラスを定義することによって、自由に新しい型を
     作りだすことができます。
       1. 文字列型( Stringクラス)
          文字列型は、Javaのパッケージに最初から入っているクラスの 一つで
          す。クラスなので、普通にコンストラクタを呼びだして 実体を作ったり
          もできるのですが、このStringクラスは 特別になっていて、文字列リテ
          ラルをいかにも クラスであるように使えます。次のようにします。

          String s1 = "808state";                                 // いきなり代入できる。
          String s2 = new String();                               //コンストラクタを呼べる。
          System.out.println( "how many characters?".length() );  // 長さを求めるメソッドを使える。
          System.out.println( s1.length() );                      // もちろんこうすることもできる。
          if( s1 == s2 )....                                      // 比較はこうする。

       2. クラス型(オブジェクト)
          クラス型の変数は、あるクラスのインスタンスです。 インスタンスとい
          うのは、 クラスの定義に従ってメモリ上に構築されたひとかたまりの情
          報です。 これをオブジェクトとも言います。 オブジェクトがどのような
          情報を持っているのか、 またどのようなメソッドを持っているのかは、
          クラスの定義によります。 宣言は次のようにします。

          MyClass c;

          宣言しただけでは、参照が作られるだけです。実体を作るためには、 new
          使います。

          MyClass c = new MyClass();      // コンストラクタ呼びだし

          このようにすることで、 MyClassクラスのインスタンスが作れます。

       3. 配列

          配列とは、同じ型のものを複数個連続して管理し、添字(index)で参照 で
          きるようにしたものです。同じ種類の情報が連続している 時に使用しま
          す。
          基本型ばかりでなく、あらゆる型の配列を作ることができます。 配列の
          宣言は、次のようにします。

          int a[] = new int[100];
          MyClass ca[] = new MyClass[100];

          int型は、基本型なので、この宣言のあと、

          a[40] = 808;

          のようにして、直接に値を代入できます。ところが、MyClass型は、 クラ
          スなので参照型です。この宣言では、参照だけが100個用意され、 実体は
          まだメモリ上に確保されていないので、実体を作るためには、 それぞれ
          の要素について、コンストラクタを呼びだしてやる必要があるのです。
          それには次のようにします。

          MyClass ca[] = new MyClass[100];
          for(int i=0 ; i < 100 ; i++ ) ca[i] = new MyClass();

          また、配列は、Javaの内部では、クラスとして実装されているので、次の
          ようにして 要素の数を知ることもできます。インスタンス変数をアクセ
          スする要領です。

          int [] ia = new int[100];
          System.out.println(  ia.length );       // 100が表示される。


6. 変数宣言

     変数を宣言するには次のようにします。

     修飾子 型名 変数名(,変数名,..);

     型名は、前項で説明した型を指定します。
     修飾子には、以下のものが指定できます。複数の指定が可能です。
--------------------------------------------------------
        o static
          クラス変数に指定します。クラスのどのインスタンスからでも共通にアク
          セスされます。 static指定されている変数をアクセスするのには、
          static指定した メソッドを使うのがよいでしょう。
        o final
          定数という意味になります。
        o public/private/protected
          アクセスできる範囲を指定します。 publicは、その変数に対して、パッ
          ケージの外からもアクセスできます。
          privateは、そのクラス自身の中からしかアクセスできません。
          protectedそのクラスと、それをextendsしているクラスの中から のみア
          クセスできます。
          これら3つの指定をしないと、同じパッケージの中のどんなクラスからで
          もアクセスできる 指定になります。
        o volatile
		  複数のスレッドから参照される可能性がある変数に対して、指定します。
		  スレッド間の同期の問題を回避できます。
        o transient
		  変数が一時的な情報を保管しているという指定です。
--------------------------------------------------------

     変数名のところでは、'='演算子を使って初期化ができます。
        例：
        public final int MAGIC =10;
        private volatile vi=10;



7. 演算子

--------------------------------------------------------
      演算子          演算の内容                 注意事項、例
--------------------------------------------------------
      +     足し算
      -     引き算
      *     かけ算
      /     割り算
      %     割り算の余り
      +=    和を代入                       x = x + a
      -=    差を代入                       x = x - a
      *=    積を代入                       x = x * a
      /=    割り算の結果を代入             x = x / a
      %=    割り算の余りを代入             x = x % a
      ++    1加える                        前置、後置では働きが違う
      --    1減らす                        前置、後置では働きが違う
      ==    等しい
      !=    異なる
      <     〜より小さい
      >     〜より大きい
      <=    以下
      >=    以上
      &&    かつ(論理演算)
      ||    または(論理演算)
      !     否定(論理演算)
      &     ビットごとの積
      |     ビットごとの和
      ^     ビットごとの排他的和
      <<    左シフト
      >>    右シフト(算術)
      >>>   右シフト(論理)
      ~     ビット反転                     ~x
      <<=   左シフト代入                   x = x << a
      >>=   右シフト代入(算術)             x = x >> a
      >>>=  右シフト代入(論理)             x = x >>> a
      &=    ビットごとの積を代入           x = x & a
      |=    ビットごとの和を代入           x = x | a
      ^=    ビットごとの排他的論理和を代入 x = x ^ a
--------------------------------------------------------

     ++と--は、変数の前に置くときと後ろに 置くときでは、動作が違います。x++
     のように後ろに置くと、 xの値は、式の実行が全部終わってから加算されま
     す。 ++xのように前に置くと、式の実行が始まる直前に加算されます。 次のよ
     うなコードを実行して、試してみてください。

             int x = 20;
             System.out.println("x:" + ( ++x ));
             System.out.println("x:" + ( x++ ));

     演算子の優先順位

     それぞれの演算子には、次のような優先順位があります。
--------------------------------------------------------
       演算子
--------------------------------------------------------
      ()[].
      ++ -- ! ~ instanceof
      new
      * / %
      + -
      >> << >>>
      < > <= >=
      == !=
      &
      ^
      |
      &&
      ||
      ?:
      = += -= *= /= %= ^=
      &= != <<= >>= >>>=
--------------------------------------------------------

     文字列の加算演算子

     演算子の中で、+だけは、文字列を連結するために使えます。 次のように文字
     列と文字列を連結するだけでなく、
      String s = "how";
      String t = "are";
      String u = s + t + "you?";

     文字列以外のものも自由に連結できます。その際には、自動的に文字列に 変換
     されます。
      int c = 200;
      String s = "number:" + c;


8. 論理演算の真偽値表

--------------------------------------------------------
      演算子 値1   値2  結果
--------------------------------------------------------
      &&    true  true  true
      &&    true  false false
      &&    false true  false
      &&    false false false
      ||    true  true  true
      ||    true  false true
      ||    false true  true
      ||    false false false
      !     true  ---   false
      !     false ---   true
--------------------------------------------------------



9.  文とブロック
     x = y + a;

     これは一つの文です。文は、中括弧を使って複数をまとめることによって一つ
     の文にできます。

     {
         x = y + a;
         y++;
     }

     以上は一つの文になっています。これをブロックと呼びます。ブロックの中で
     宣言した変数は、 そのブロックより外では、使うことができません。この性質
     を使えば、局所的に一般的な 名前の変数を使ったりということができます。

     {
         int i=0;
         {
                 int x;
                 x = i; // このようにできるが、
         }
         x = 20;         // このようにはできない。
     }

     ブロックは一つの文として扱われます。基本的に、次の項目のフロー制御で
     は、 一つの文についての制御を行ないますが、ブロックにすることによって、
     複数の 文を制御することができます。

     if( true ) x = 10; y = 10;

     この場合は、ifで制御できるのは、 x = 10;の文だけです。 y=10;は、ifに関
     係なく実行されます。

     if( true ){ x = 10; y = 10;}

     この場合は、二つの文をブロック化しているので、一つの文として扱われま
     す。 ですから、x=10;とy=10;の二つの文がif で制御されます。



10. フロー制御

     フロー制御とは、プログラムの流れを分岐させたり、ループ(繰りかえし)させ
     たりする ことです。フロー制御を実現するための文には次に示すものがありま
     す。

       1. if

           if( 条件式 ) 文;

          この場合、(条件式)がboolean値でtrueの場合だけ 「文」が実行されま
          す。
           if( 条件式 ) 文1; else 文2;

          この場合、(条件式)がtrueの場合は「文1」が、false の場合は「文2」が
          実行されます。

       2. while

           while( 条件式 ) 文;

          (1)まず条件式を実行し、その結果がboolean型でtrue ならば(2)文を実行
          し、文を実行し終わると(1)に戻ります。while 文の中では、後述の
          continueとbreakが使えます。

       3. for

           for( 初期化式 ; 条件式 ; 更新式 ) 文;

          (1)まず最初に一回だけ初期化式が実行されます。(2)次に条件式が実行さ
          れます。 (3)条件式がboolean型のtrueの場合は、文が実行されます。
          (4)更新式が実行されます。 (5)(2)に戻ります。 for文の中では、break
          とcontinueが 使えます。
           for( int i = 0 ; i<10 ; i++ ){ .... }

          この例では、for文の外では、変数iは見えません。

       4. do〜while

           do 文 while( 条件式 );

          (1)まず文を実行します。(2)条件式を実行します。(3)条件式の結果が
          boolean型のtrueであった場合、(1)に戻ります。 do〜while文は、文の内
          容を、最低1回実行したいときに 役立ちます。

       5. switch

          switch文の中ではbreakをよく使うので、 ループであると勘違いされます
          が、ループではありません。 同じ型の値(整数型)によって分岐したいと
          きに、多数に及ぶ場合は ifを使うとわかりにくいプログラムになります
          が、switch を使うと、見やすいプログラムにできます。
           switch( 式 ){
               case 定数1:
                       文1;
               case 定数2:
                       文2;
               ..
               ..
               default:
                       文N;
           }

          caseの後に、判定したい値を書きます。この値は、整数のリテラル また
          は、final指定した整数変数でなければなりません。 式の値がそれぞれの
          定数に一致すると、その定数に対応した文が実行されます。 文の中に
          breakを書いておくと、switchの処理を 中止し、抜けます。breakがない
          と、一致した定数以降の文が実行されて しまいますので、注意してくだ
          さい。例えば、上の例で定数1に一致した場合で 文1にbreakがない場合
          は、文2も実行されてしまいます。

       6. continue

          ループを次の回に進めます。
           contiue;

          この使用例では、continueが含まれているループの処理を 次の回に進め
          ます。
          Javaでは、それぞれのループに名前をつけることで、continue が含まれ
          ているループより外側のループを次の回に進めることができます。 名前
          のつけかたは、label:のようにします。

           loop1:
           for(int j = 0 ; j < 10 ; j ++){  // このループの名前が、loop1
               loop2:
               for(int i = 0 ; i < 20 ; i++){  // このループの名前が、loop2
                       System.out.println( i );
                       if( i == 10 ) continue loop1;
               }
           }

       7. break

          ループを中断します。continue文と同じように、名前をつけた ループに
          対して操作することができます。
           break;

          この場合は、breakが含まれているループの処理を中断します。
           break label;

          この場合は、名前をつけたループの処理を中断します。 breakは名前をつ
          けたif文に対しても使えます。
           branch1:
           if( true ){  // このif文の名前が、branch1になる
           branch2:
               if( true ){  // このif文の名前がbranch2になる
                       break branch1;
               }
               文A;
           }

          この例だと、文Aは実行されません。

       8. return

          メソッドの実行を中断し、呼び出し元に戻ります。
           return 式;

          式に、メソッドの返り値と同じ型の値を指定することによって、メソッド
          の 返り値とすることができます。

       9. goto

          gotoは、予約語になっていますが、使うことはできません。




11. クラスとインターフェイス定義

     新しいクラスを定義するには、トップレベルでclassというキーワードを使いま
     す。 一般的には次の形です。

     (修飾子) class クラス名 (修飾子 修飾子への指定) ブロック

     「ブロック」の部分は、中括弧でくくったクラス定義の内容を書きます。
     括弧内は省略できます。 classの前には以下の修飾子を付けることができま
     す。複数指定可能です。

------------------------------------------------------------
        o final
          他のクラスによってextendsすることができなくなります。
        o abstract
          このクラスのインスタンスを作ることができなくなります。他のクラスの
          メソッドの返り値と して得るということになります。

        o public
          パッケージ外からアクセス(つまり、インスタンスを作る、extendsする、
          という ことができるわけです。そのために、ファイル名は、クラス名と
          一致している必要があります。
------------------------------------------------------------

      public final class hoge {
          int member_int;
          内容...
      }
      abstract class foo{
          int member_int;
      }

     classの後ろには次の修飾子を付けることができます。
        o extends スーパークラス
        o emplements インターフェース,インターフェース...
      class CompressImputStream extends InputStream
      {
          public int setMode(int mode ){
              内容...
          }
      }
      public class MyApplet extends Applet implements Runnable,Serializable
      {
              内容...
      }

     ブロックの部分には、クラスのメソッドや、メンバー変数などを記述します。

	 * インターフェース

	 クラスと似たものに、インターフェースがあります。インターフェースは、
	 変数やメソッドの宣言だけを含みます。変数は、すべてpublic finalとして
	 宣言されます。それぞれのクラスは、インターフェースをimplementsすることに
	 よって、そのインターフェースに規定されているメソッドを実装していることを
	 保証します。クラスの、外部からの見えかただけを規定するわけです。
	 複数のインターフェースをimplementsすることができます。
	 インターフェイスの定義は次のようにします。

	 public/abstract interface 名前 [ extends インターフェース名] ブロック

	 複数のインターフェースをextendsすることができます。
	 いろいろなクラスから共通に使うような変数を固めて定義したりするためにも
	 使えます。インターフェースは大規模なプログラムを開発することを容易にする
	 ことが目標なので、ゲームプログラムにおいてはそれほど使う機会はないかも
	 しれません。

     * クラス内クラス

     JDK1.1附属のjavacからコンパイル可能になった文法で、 クラスのほぼどのよ
     うな所でも新しいクラスを作ることができます。この仕様は コンパイラの機能
     拡張によってなされていて、バイナリの仕様は変更されていません。 クラス内
     クラスの名前は、そのクラス外には見えないので、 クラス内クラスを使うこと
     によって、一般的な名前のクラス(例："record"など) を使うことができるよう
     になります。

     例:
------------------------------------------------------------
class MyClass
{
	class record
	{
		private int type;
		private String name;
		record(int tp,String nm){       // recordクラスのコンストラクタ
			type = tp;
			name = nm;
		}
	}
	record records[] = new record[100];

	MyClass()               // MyClassクラスのコンストラクタ
	{
	}
}
------------------------------------------------------------

	


12. メソッドとコンストラクタ

     メソッドの定義は次のようにします。

     修飾子 型指定 メソッド名( パラメータ列 ) ブロック

     修飾子は以下のものがあります。nativeについては省略します。
--------------------------------------------------------
        o abstract
          メソッドをabstract指定するためには、このメソッドを含むクラスを
          abstract宣言する必要があります。さらに、そのクラスをextends するク
          ラスの中で、このメソッドの実体を定義してやる必要があります。
		  メソッドをabstract指定するということは、メソッドの処理の中身を
		  サブクラスに任せることになるので、共通の機能を実現する異なるクラス
		  の「容れもの」となるクラスを作ることができます。

        o static
          static指定したメソッドは、そのクラスのどのインスタンスからでも共通
          に アクセスされます。static指定の変数にアクセスするために使えばよ
          いでしょう。
        o final
          final指定したメソッドは、サブクラスでオーバーライド(同じ引数、返り
          値の 型指定と名前で、違う内容に作りかえること。Appletプログラミン
          グでのpaint メソッドのように。)できなくなります。
        o synchronized
          この指定をしたメソッドは、別のスレッドによって同時に実行されること
          はなくなります。
        o public/private/protected
          アクセス指定です。変数宣言の所で説明した通りです。
---------------------------------------------------------



13. 例外とエラー

     プログラムの実行中に予期しない状態が発生した場合、通常の処理を中断して
     エラー 処理などの特別なプログラムを実行したい時があります。それを実現す
     るのがtry とcatchです。一般的には次のようにします。

     try{
         通常の処理
     } catch( 反応したい例外 ){
         例外処理
     } catch( 反応したい例外 ){
     } finally {
         必ずやっておかなければならないこと
     }

     プログラムの中で意図的に例外を発生させることもできます。その場合には
     throw( Throwable)を使います。例えば次のようにすれば、
	 ある例外をcatchしながら、その呼びだし元のクラスにも例外を飛ばすことができます。
	try{
	}catch( InterruptedException e ){
		throw( e );
	}



14. パッケージ

	ひとかたまりの機能を実現するクラス群をまとめてパッケージとする
	ことができます。大規模なプログラムを開発するときには必須の機能です。

	あるクラスをパッケージに含めるには次のようにします。
------------------------------
package mypackage;

public class myClass
{
	......
}
------------------------------
	クラスをpublic宣言すると、他のパッケージからextendsすることができる
	ようになります。
	同じパッケージに指定したクラス群は、そのパッケージの名前をつけた
	ディレクトリに、パッケージの階層構造と同じ構造にして保存しておく
	必要があります。
	例：
	java.awt.Button                ..../JDK/classes/java/awt/Button.class
	java.awt.image.PixelGrabber    ..../JDK/classes/java/awt/image/PixelGrabber
	
	

15. import

	ソースプログラムの中では、様々なクラスを使いますが、本来はそれぞれの
	クラスは、次のように「省略なし」で指定する必要があります。

------------------------------
public class myApplet extends java.applet.Applet
{
	java.lang.String message;
	java.awt.Button b;
	...
}
------------------------------
	しかしそれでは繁雑になるので、ソースコードの冒頭でそれぞれのクラスをimport
	することにより、コード量を減らすことができます。
------------------------------
import java.applet.Applet;
import java.awt.*;
public class myApplet Applet
{
	String message;
	Button b;
	...
}
------------------------------
	java.langはデフォルトでimportされているので、完全に省略してしまうことができ
	ます。この例でのjava.applet.Appletのように単一のクラスをimportすること
	以外にも、java.awt.* というように、パッケージ内のpublicクラスをすべて
	importすることができます。

	(注意)*という記号が有効なのは、1段階までです。

import java.*;

	という表記をしても、java.awtの下のクラスは、importされません。





************************************************************************

クラスライブラリ(API)

このリファレンスでは、JDK1.1のコアAPI(どんな実行環境でも使えることが保 障さ
れているAPI)をベースに解説します。JDK1.0.2のライブラリに含まれていない もの
には、(Not available on 1.0.2マーク)をつけてあります。 (以下のHTMLでは、アス
タリスクをつけていきます。) パッケージはアルファベット順で、その中のクラスも
アルファベット順です。 それぞれのクラスのよく使うメソッドを紹介しています。

java.applet

     このパッケージには、アプレットの実行に関連する機能が詰まっています。 ア
     プレットプログラミングとは、つまりこのパッケージにあるクラスを使って プ
     ログラミングすることだと言えます。

     インターフェイス

        o AppletContext
          AppletViewerやその他、アプレットを下位の部品として使うような アプ
          リケーションを作るときに使うインターフェイスです。ゲームを作る分に
          は使う ことはないでしょう。
        o AppletStub
          これもAppletViewerなどが使うものです。普段は使うことはあ りませ
          ん。
        o AudioClip
          アプレットにオーディオを演奏させる時に使います。重要なメソッドとし
          ては
             + loop() 繰り返して演奏させます。
             + play() 一回だけ演奏させます。
             + stop() 演奏中の音があると、止めます。
               重ねてplayしても前に鳴っていた音は消えず、重ねて演奏されま
               す。

     クラス

        o Applet extends Panel
          アプレットの基本クラスです。
          よく使うメソッド
             + destroy() このメソッドを実行すると、アプレットが使用している
               資源を解放します。
             + getAudioClip(URL),getAudioClip(URL,String) URLを指定して、ア
               プレットで使う AudioClipをサーバから取ってきます。
               例： getAudioClip( getCodeBase(), "./bang.au");
             + getCodeBase() getAudioClipや getImageをするときに便利です。ア
               プレットのクラスそのもの URLを求めます。getDocumentBaseという
               のもあり ます。
             + getImage(URL),getImage(URL,String) アプレットで使う画像のファ
               イルを読みこんで展開し、Imageク ラスを得ることができます。
             + getParameter(String) <applet>タグを含むHTMLに書かれて
			   いる<param>タグの内容を 名前で読みだします。
             + init() アプレットを初期化するコードをこのメソッドの中に書きま
               す。
             + play(URL),play(URL,String) AudioClipを演奏します。
             + resize(Demension),resize(int,int) アプレットのサイズを変更し
               ます。
             + start() アプレットが初期化(init)された後や、他のページから戻
               って きたときなどに呼びだされます。
             + stop() ブラウザ上でアプレット以外のページに移動したときなどに
               呼びだされます。 もちろんappletviewerを終了させる時にも呼びだ
               されます。

java.awt

     Javaでグラフィカルなユーザインターフェース(GUI)を実現するためのAPI群で
     す。 全てのアーキテクチャに一般化できる機能が凝縮されています。JDK1.1で
     は、 大規模なアプリケーションも容易に開発できるように拡張されています。

     インターフェイス

        o Adjustable
		囲が決まっている、連続的な数値を値として持つようなオブジェクト(典型的
		には、Scrollbarなど)は、これをimplementsします。
        o EventSource
		他のオブジェクトによって使われるようなイベントを発生するような
		オブジェクト。
        o ItemSelectable
		0個以上の項目を選択できるようなオブジェクト。
        o LayoutManager
		Containerをレイアウトするクラスのためのインターフェイス。
        o LayoutManager2
		レイアウトに束縛されるようなContainerをレイアウトするクラスのための
		インターフェイス。
        o MenuContainer
		メニューに関係するすべてのクラスは、これをimplementsします。
        o PrintGraphics
		印刷のためのグラフィックスコンテキストを提供するインターフェイス。
        o Shape
		ある図形を表現するオブジェクトのためのインターフェイス。

     クラス

        o AWTEvent
          awtイベントの基本になるクラスです。
        o BorderLayout
          "North","South","East","West","Center"のいずれかを指定して 部品類
          を整列させるレイアウタです。
        o Button
          名前のついたボタンを実現します。
          例：add( new Button("OK!") );
        o Canvas
          キャンバス、その名のとおり、この上に絵を描くことができます。 この
          クラスをextendsして、面白い効果を持つボタン などを作ることができま
          す。extendsしたクラスでは、 paint(Graphics)メソッドを書く(オーバー
          ライド)する ことによって、好きな絵をかくことができます。 例：

          class FunnyButton extends Canvas
          {
             public void paint(Graphics g){
                 ....
             }
          }

        o CardLayout
          常には1枚のカードしか見えないようなUIを実現する ためのレイアウタで
          す。
        o Checkbox
          チェックされているかそうでないかという、 booleanの値を持つGUI部
          品。
        o CheckboxGroup
          CheckBoxをまとめて管理する。
        o CheckboxMenuItem
          メニューの中にある選択肢を表示するチェックボックス。
        o Choice
          クリックするとポップアップするメニュー。ドラッグして選ぶと、 現在
          選んでいる項目が、メニューのタイトルになる。
        o Color
          RGBを使って簡単に色を作ったりできる。 例： g.setColor( new
          Color(100,100,100) );
        o Component
          awtの基本的なクラス。awt内の他の多くのGUI部品は、このクラスを
          extendsしている。
        o Container
          他のawtコンポーネントを含むことができるコンポーネント。 例：
          myContainer.add( new Button(...
        o Cursor
          マウスカーソルを設定するためのクラス。
        o Dialog
          ユーザからの入力を要求するウインドウ。
        o Dimension
          幅と高さを一括管理できるクラス。多くのクラスのメソッドの引数になっ
          ています。
        o Event
          プラットフォームに依存しないGUIイベント処理を実現するためのクラ
          ス。 idというフィールド変数を持っていて、その値を見て 処理を振りわ
          けたりする。
        o EventQueue*
          複数のイベントを列にして管理しやすくするクラス。JDK1.1では、 大規
          模なアプリケーションの作成も容易にするために、Eventの管理方法 が拡
          張されています。
        o FileDialog
          アプリケーションにおいてファイルを選択する処理はいつも似たようなも
          の になる。その処理を一般化して使えるようにしたクラス。ファイルを
          選ぶまで はブロックします。
        o FlowLayout
          左から右へコンポーネントを並べるレイアウタ。
        o Font
          フォントを操作する。
        o FontMetrics
          幅や高さなど、フォントに関する情報を引きだす。
        o Frame
          タイトルつきのウインドウ。次のようにすれば新たなウインドウを出すこ
          とが できます。
          例：

          Frame f = new Frame("Title");
          f.show();

        o Graphics
          CanvasやImage、その他にも いろいろなオブジェクトに対してのさまざま
          な描画を実現する。
        o GridBagConstraints
          GridBagLayoutのお助けクラス。
        o GridBagLayout
          コンポーネントを複雑に配置するためのレイアウタ。コンポーネントの
          サイズは同じでなくてもよく、相当に柔軟な配置ができる。
        o GridLayout
          コンポーネントをマス目様に配置するレイアウタ。
        o Image
          Imageは直接にインスタンス化(new)することはできません。 createImage
          やgetImageで得るのが普通。
          例：

          Image myimg = getImage( getDocumentBase() , "hoge.gif" );
          Image ofscr = createImage( 100,100 );  // オフスクリーンイメージを作る
          Graphics ofscrg = ofscr.getGraphics(); // 以降ofscrgを使って描画する

        o Insets

          Containerの上下左右に挿入される空白のサイズを管理する。 新しくウイ
          ンドウを開いてその「中身の」本当の大きさを得るには次の ようにす
          る。
          例：

          Frame f = new Frame("title");
          f.resize(200,200);    // resizeを忘れると大きすぎるウインドウができる
          f.show();             // 先にshowすること
          Insets ins = f.insets(); // これでタイトルバーや枠の太さが求められる

        o Label
          読むことはできるが変更できないラベルをあらわすコンポーネント。 チ
          ェックボックスの横などに表示したりする。
        o List
          スクロールする選択メニュー。
        o MediaTracker
          画像や音声をロードする時に、それが終了するまで待ったり、状況を 調
          べたりするクラス。例えば画像の場合は次のようにして全てが ロードさ
          れ終わるまで待つことができる。 例：

          public void init()
          {
              MediaTracker tracker;
              Image img;
              tracker = new MediaTracker(this);
              img = getImage( getDocumentBase() , "hoge.gif");
              tracker.addImage(img , 0 );
              tracker.waitForAll(); // ロードが終わるまでinit()は終わらない
          }

        o Menu
          MenuBarの部品。
        o MenuBar
          メニューバー。メニューバーは、動作環境によって異なるが、それぞれに
          応じた 形式のメニューバーになる。
        o MenuComponent
          メニュー関係のクラスは、すべてこのクラスをextendsしている。
        o MenuItem
          メニューの選択項目になる文字列を内容とする一つの項目。
        o MenuShortcut*
          JDK1.1では、より一般的なアプリケーションを作成できるように、 メニ
          ューをキーボード操作できるようになったが、それを実現するための ク
          ラス。java.awt.Eventをextendsしている。
        o Panel
          Containerの一種で、一般的な機能を持つコンテナを 実現する。アプレッ
          トをいくつかのGUI群にわけたい時などは Panelを群の数だけ作ってそこ
          に細かいGUI部品を置く というようにすることが多い。
        o Point
          x,yという2つの値をあらわすクラス。 Pointが点の「位置」をあらわすの
          に対して、Dimension は、「幅と高さ」をあらわすことに注意。同じint
          の2値だが、 わざわざ意味を分けているのには目的がある。
        o Polygon
          複数の点の位置の配列で初期化される多角形をあらわす。 Graphicsクラ
          スのdrawPolygonというメソッドに 渡してポリゴンを描画することができ
          る。
        o PopupMenu*
          マウスを操作した場所で、その場に応じたメニューを出す。Netscapeの
          右クリックのような感じです。
        o PrintJob*
          プリンタを操作するためのクラス。Toolkitを使って得る。
        o Rectangle
          四角形をあらわす。左上の点と幅、高さをもつ。
        o ScrollPane*
          JDK1.1以前は、スクロールの処理が意外にややこしい上に、 システムの
          オーバーヘッドが大きく、パフォーマンス的も低かった ために、
          Containerクラスをextendsしている 新しいクラスが実装されました。他
          のContainerのように、 addができます。
        o Scrollbar
          単純なスクロールバーを実現します。JDK1.1以降では、ほぼ ScrollPane
          を使うという方向になっていくでしょうが。
        o SystemColor*
          Javaアプレット/アプリケーション以外の動作中のアプリケーションや、
          システム自体と色を共有するためのクラスです。GUIのそれぞれの部分ご
          との 色を取りだしたりすることによって、色の統一感があるGUIを構築す
          ることが できます。
        o TextArea
          複数行にまたがるテキスト入力エリアを設けます。変更ができないように
          すれば、アプリケーションの起動時にユーザに読ませる注意書きなどにも
          使えます。
        o TextComponent
          テキストを編集するようなクラス (TextArea,TextField) はこのクラスを
          extendsします。領域選択やカーソル移動 など、便利で一般的な機能を持
          っているからです。
        o TextField
          TextAreaと異なり、1行の入力フィールドを用意します。
        o Toolkit
          awtの中の抽象クラス(ImageやGraphics) を、実際の動作環境に応じたも
          のに結びつけます。Toolkit を得るには、コンポーネントをextendsして
          いるクラスの中で getToolkit()というメソッドを使います。
          例：

          import java.awt.*;
          public class myAplt extends java.applet.Applet
          {
              Toolkit tk;
              Image img;
              public void init(){
                  tk = getToolkit();
                  img = tk.getImage( "aho.gif");
              }
              public void paint(Graphics g){
                 g.drawImage( img ,0,0,this);
              }
          }

          ToolkitにはcreateImageという、 プログラム的に画像を作りだすメソッ
          ドがあって、それが使いたいために 上で示したような方法を取ることも
          多いです。
        o Window
          普段はほとんど使わないでしょう。APIマニュアルには、ポップアップメ
          ニューを作る ときに使えるということが書いてありますが、ウインドウ
          を作るのであれば Frameクラスを使うべきです。

     例外

        o AWTException
          awtの中で例外的な状況が発生した場合に投げられます。
        o IllegalComponentStateException*
          あるコンポーネントに、処理を要求(つまりメソッド呼びだし)した時に、
          たまたまそのコンポーネントが要求を処理できない状態であった場合に
          発生します。

     エラー

        o AWTError
          awt内部のエラーです。この原因はなかなかつきとめることができませ
          ん。 動作環境によって様々な原因がありえます。どうしてもこのエラー
          に苦しめられ るような場合は、あきらめて少し違う他のやりかたにする
          と直ったりします。

java.awt.datatransfer*

     アプリケーション同士の情報のやりとりを実現するためのAPI群です。

	  インターフェイス

		 o ClipboardOwner*
		   クリップボードに情報を渡すことができるオブジェクトは、これを
		   implementsします。
		 o Transferable*
		   実際にクリップボードとの間で情報をやりとりするために使われるクラス
		   はこれをimplementsします。

	  クラス

		 o Clipboard*
		   カット/コピー/ペーストといった、コンポーネント間あるいは他のアプリ
		   ケーション との間で一般的な情報のやりとりをするための操作を実現し
		   ます。 情報として、内容とその名前と所有者(所有コンポーネント)を持
		   っています。
		 o DataFlavor*
		   クリップボードとやりとりする情報がどのようなタイプのものであるかを
		   管理・操作します。
		 o StringSelection*
		   クリップボードとのやりとりで、単純な文字列(プレインテキスト)をやり
		   とり する単純なやりかたを実現します。

	  例外

		 o UnsupportedFlavorException*
		   当該DataFlovorが、要求されたデータに対応していない場合 に発生しま
		   す。

java.awt.event*

	  JDK1.1では、大規模なアプリケーションの開発を容易にするために、まずイベ
	  ント関連 の仕様が拡張されました。JDK1.0形式のイベント処理の方法から、
	  JDK1.1以降の方法へと変更する方法については、第4章の1節、17で扱っています。

	  インターフェイス

		 o ActionListener*
		   Button,List,MenuItem,TextField,Checkbox,Choiceなどが発生する
		   イベントを処理するクラスのためのインターフェイス。
		 o AdjustmentListener*
		   Scrollbarなどが発生するイベントを処理するクラスのためのイン
		   ターフェイス。
		 o ComponentListener*
		   Dialog,Frameなどが移動したり、リサイズされたりといったイベントを
		   処理するクラスのためのインターフェイス。
		 o FocusListener*
		   コンポーネントがフォーカスを得たり、失なったり、といったイベントを
		   処理するクラスのためのインターフェイス。
		 o ItemListener*
		   Checkbox,Choiceなど、項目の状態自体が変化した、というイベントを
	       処理するクラスのためのインターフェイス。
		 o KeyListener*
		   キーボードに関連するイベントを処理するクラスのためのインター
		   フェイス。
		 o MouseListener*
		   マウスのボタンに関するイベントを処理するクラスのための
		   インターフェイス。
		 o MouseMotionListener*
		   マウスの動きに関するイベントを処理するクラスのためのインター
		   フェイス。
		 o WindowListener *
		   Dialog,Frameなどが発生する、ウインドウの開け閉めに関するイベントを
           処理するクラスのためのインターフェイス。

	  クラス

		 o ActionEvent*
		   ActionListenerが受けとるイベント。Button,List,MenuItem,TextField,
		   Checkbox,Choiceなどが発生。
		 o AdjustmentEvent*
		   AdjustmentListenerが受けとるイベント。Scrollbarが発生。
		 o ComponentAdapter*
		   空メソッドをプログラム中でたくさん定義するのは繁雑なので、
		   それを回避するために、空のメソッドを定義してくれるクラス。
		   このクラスをextendsすれば、とりあえず必要ない処理を書かなくても
		   よくなります。 ComponentListener用のクラス。
		 o ComponentEvent*
		   ComponentListenerが受けとるイベント。Dialog,Frameなどが発生。
		 o FocusAdapter*
		   FocusListenerのクラスのプログラムをシンプルにするためのクラス。
		 o FocusEvent*
		   FocusListenerが受けとるイベント。あらゆるコンポーネントが発生する
			イベント。
		 o InputEvent*
		   コンポーネントに対する入力の基本クラス。
		 o ItemEvent*
		   ItemListenerが受けとるイベント。Checkbox,Choiceなどが発生。
		 o KeyAdapter*
		   KeyListenerのクラスのプログラムをシンプルにするためのクラス。
		 o KeyEvent*
		   KeyListenerが受けとるイベント。あらゆるコンポーネントが発生する
		   可能性があります。
		 o MouseAdapter*
	       MouseListenerのクラスのプログラムをシンプルにするためのクラス。
		 o MouseEvent*
		   MouseListenerが受けとるイベント。Canvas,Dialog,Frame,Panel,Window
		   などが発生。
		 o MouseMotionAdapter*
		   MouseMotinListenerのクラスのプログラムをシンプルにするためのクラス。
		 o PaintEvent*
		   コンポーネントの描画イベント。このイベントは、従来通りのプログラム
		   をすればよく、Listenerはありません。
		 o WindowAdapter*
		   WindowListenerのクラスのプログラムをシンプルにするためのクラス。
		 o WindowEvent*
		   WindowListenerが受けとるイベント。DialogやFrameが発生。

java.awt.image

	  awtで画像を扱う時に一歩ふみこんだ処理をするためのパッケージです。 画像
	  処理をする時には必需品です。

	  インターフェイス

		 o ImageConsumer
		   いわばImageProducerのしたうけとなるインターフェイスです。
		   ImageProducerをimplementsしているクラスは、 その内部で情報を得るた
		   めにImageConsumerで定義されている メソッドを使います。
		 o ImageObserver
		   イメージは非同期にロードされメモリ上に生成されていきますが、その
		   状況を調べるためのインターフェイスです。
		 o ImageProducer
		   Imageをあたらしく作りだせる能力を持つということを あらわすインター
		   フェースです。このインターフェイスを implementsしているクラスは、
		   たとえばToolkit のメソッドであるcreateImage(ImageProducer)の 引数
		   として与えられることができます。どのImageも、内部に その画像を生成
		   するためのImageProducerを必要とします。

	  クラス

		 o AverageScaleFilter*
		   単純なスムージングアルゴリズムを使って画像を拡大縮小します。 従来
		   はただ間延びさせるだけでした。
		 o ColorModel
		   Javaでは色はRGBAと呼ばれるモデルで統一されていますが、Java以外から
		   ピクセルのデータを読みだす場合はまずJavaの形式に変換しなければなり
		   ませ ん。その処理を助けます。
		 o CropImageFilter
		   イメージの部分的な領域を切りだします。
		 o DirectColorModel
		   ピクセル値から色へ直接的に変換します。
		 o FilteredImageSource
		   ある特定のフィルタをかけるようなImageProducerです。
		 o ImageFilter
		   新たにフィルタを作る場合はこのクラスをextendsし、それぞれ のメソッ
		   ドをオーバーライドします。そうすることによって ImageConsumerから
		   ImageProducerへの情報の 渡しかたを変え、フィルタをかけるのです。
		 o IndexColorModel
		   それぞれの色を番号で指定するようなカラーモデルです。ある色を透明色
		   に指定 することもできます。
		 o MemoryImageSource
		   int型の配列から新しいImageを作りだします。 非常にわかりやすいサン
		   プルプログラムが、APIマニュアルの同じ項に掲載さ れています。
		 o PixelGrabber
		   Imageからint型の配列へ情報を取りだします。 ちょうど上記の、
		   MemoryImageSourceの逆の処理になります。
		 o RGBImageFilter
		   標準のRGBカラーモデルを使った単純なフィルタを作るのを助けるクラス
		   です。 これもまたabstractクラスで、filterRGBという メソッドを実装
		   することで簡単にフィルタを作成できます。
		 o ReplicateScaleFilter*
		   最も単純な方法で画像を拡大縮小します。

java.awt.peer

	  動作環境に依存する部分とJavaを結びつけます。本書の範囲を越えているので
	  省略します。

java.io

	  Javaの国際化にともなって、従来のInputStreamやOutputStream に対応する
	  Unicodeストリームを扱う、Reader、Writerが 用意されました。

	  インターフェイス

		o DataInput
		  マシンに依存しない形で情報をストリームから入力するためのインターフ
		  ェイス。 Javaにおける様々な型の変数へ、直接読みこむことができる。
		o DataOutput
	      DataInputの逆、出力するためのインターフェイス。
	    o Externalizable*
	      VM外部から読みこんだり、VM外部に保存したりできるクラスのための
          インターフェイス。
        o FilenameFilter
          名前で指定するファイル名がディレクトリに存在するかどうかを調べる。
        o ObjectInput*
          Javaのオブジェクトをストリームから読みこむためのインターフェイス。
        o ObjectInputValidation*
		  ストリームから読みこんだオブジェクトを有効にします。
        o ObjectOutput*
          Javaのオブジェクトをストリームに書きだすためのインターフェイス。
        o Serializable*
          JDK1.1から、オブジェクトをバイト列にして(シリアライズするという)送
          信したり 受信したりするAPIが増えましたが、そのようなことが可能であ
          るクラスを作るには、 そのクラスはSerializableをimplementsしなけれ
          ばなり ません。

     クラス

        o BufferedInputStream
          読みこみをバッファリングしてくれます。それによって読みこみのパフォ
          ーマンスが 上昇します。JDK1.0.2では、ブロッキングしないというバグ
          がありました。
        o BufferedOutputStream
          書きこみをバッファリングします。書きこみのパフォーマンスが上昇しま
          す。
        o BufferedReader*
          バイト列ではなく、Unicodeの文字列を読みこみます。Javaの国際化にと
          もなって 生まれました。
        o BufferedWriter*
          Unicodeの文字列を書きこみます。
        o ByteArrayInputStream
          すでにあるバイト列を材料にして、そのバイト列のデータが入力のデータ
          に なっているようなストリームを作りだします。ストリーム関連のルー
          チンのデバッグ に使えます。read(),read(byte[],int,int)など、ストリ
          ームらしい ルーチンがそのまま使えます。
        o ByteArrayOutputStream
          バイト列に対して出力します。ひとしきり出力したら、 toStringや、
          toByteArrayなどのメソッドを使って データを得ます。
        o ByteToCharConverter*
          Unicode以外の文字フォーマット(JISやEUCなどでも)からUnicodeへの変換
          を 行ないます。
        o CharArrayReader*
          Char型の配列を基にして、Readerを作ります。
        o CharArrayWriter*
          Charの配列へデータを出力します。
        o CharToByteConverter*
          Unicode文字を他の文字コード(日本語だとJISやEUCなど)へ変換します。
        o DataInputStream
          Javaの基本型を直接にストリームから読みこむことができる便利な スト
          リームです。ネットワーク環境においても、書きこみと読みこみ が双方
          このメソッドを使うことによって、バイトオーダの異なる アーキテクチ
          ャ間でも安全に情報をやりとりできます。
        o DataOutputStream
          DataInputStreamと対をなす出力です。
        o File
          このクラスは、Javaの中での一般的なファイル名(絶対または相対パスも
          含む) から、それぞれの動作環境に対応したファイル名への変換を行ない
          ます。 JDK1.1においてはまだ完全に実装されてはいません。使う時は調
          査してから にしてください。
        o FileDescriptor
          標準出力や標準入力などをファイルのように扱うためのクラスです。 フ
          ァイルへの出力を標準出力に振りかえたりすることができます。
        o FileInputStream
          ファイルからの入力です。ブラウザ上で動作しているアプレットからは使
          えません。 appletviewerを使う場合でも、propertiesの項目で設定が必
          要です。
        o FileOutputStream
          ファイルからの出力です。FileInputStreamと同じく、アプレットで 使う
          時は注意が必要です。
        o FileReader*
          ファイルからUnicode文字列を読みこみます。アプレットから使う時は注
          意が 必要です。(FileInputStreamの項目を参照)
        o FileWriter*
          ファイルへUnicode文字列を書きこみます。アプレットから使う時は注意
          が必要 です。
        o FilterInputStream
          InputSreamの上にかぶせることによって、InputStream の機能を拡張しま
          す。DataInputStreamや、BufferedInputStream などがこのクラスを
          extendsしています。自分で独自の便利なス トリームを作りたい場合はこ
          のクラスをextendsし、それぞれの メソッドをオーバーライドします。
        o FilterOutputStream
          FilterInputStreamと対をなす出力です。
        o FilterReader*
          Readerにかぶせることによってより高機能なReader を作ります。ちょう
          どInputStreamに対する FilterInputStreamの関係と同じです。日本語で
          言うなら、 文節をくぎって入力するとか、段落とかカギカッコに対応す
          る、全部カタカナ にするなどといった拡張が考えられます。
        o FilterWriter*
          Writerにかぶせることによってより高機能な Writerを実現します。
          FilterReaderと対をなす出 力です。
        o InputStream
          入力ストリームをあらわします。 ストリーム入力クラスはこのクラスを
          extendsします。abstract クラスです。このクラスで、基本的な読みこみ
          メソッドである
             + int read(int) 1文字読みこみます。返り値は0から255でエラーの場
               合は-1.
             + int read(byte[]) byteの配列に、配列の長さだけ読みこみます。
             + int read(byte[],int ofs,int len) byte[]の配列に、始めの位置と
               長さを指定して読みこみます。
             + close()ストリームを閉じます。
          などといったメソッドが実装されているのですが、わたしたちが使う段階
          では、 もっと上位のストリームクラスを使うので、オーバーライドされ
          た これらのメソッドを使うことが多いはずです。その場合でも上記のメ
          ソッドは基本的に 同じ使いかたができるようになっています。これらの
          メソッドは、実際に読みこみが終わるまで ブロック(ずっと待つ)しま
          す。
        o InputStreamReader*
          普通のストリームから、バイト列をUnicode文字列へ変換しながら読みこ
          みます。 このクラスは内部でByteToCharConverterを使います。
        o LineNumberInputStream
          JDK1.1においては、このクラスは「古めかしい」クラスであると宣言され
          ています。 行を数えながら入力するストリームです。JDK1.1以降では、
          次のLineNumberReader を使えというように指示されています。
        o LineNumberReader*
          行を数えながらUnicode文字列の入力をします。LineNumberInputStreamに
          置きかえられました。
        o ObjectInputStream*
          シリアライズされたJavaオブジェクトを読みだしてオブジェクトに戻しま
          す。 RMI(遠隔メソッド呼びだし)で使います。 ストリームからオブジェ
          クトを読みだすには、readObjectを 使います。
        o ObjectOutputStream*
          オブジェクトをシリアライズしてストリームに出力します。Serializable
          インターフェイスをimplementsしているクラスだけがこのクラスの
          writeObjectの引数として渡されることができます。
        o ObjectStreamClass*
          ストリームにできるクラスを表現します。このクラスは、ストリームにで
          きるクラスの名前と、 その番号を保持します。
        o OutputStream
          InputStreamと対をなす出力です。よく使うメソッドを説明します。
             + write(int) 一文字書きこみます。
             + write(byte[]) byteの配列をその長さだけ書きこみます。
             + write(byte[],int ofs,int len) byteの配列の指定した位置から 指
               定した長さだけ書きこみます。
             + close() ストリームを閉じます。
          これらのメソッドは、実際に書きこみが終了するまでブロック(ずっと待
          つ)し ます。
        o OutputStreamWriter*
          InputStreamReaderと対をなす出力です。 write(char[],int ofs,int
          len)というメソッドを使って Unicodeの文字列を書きこむと、それが
          CharToByteConverterに 通され、別な文字フォーマットのバイト列として
          出力されます。
        o PipedInputStream
          PipedOutputStreamにつないで使います。 スレッド間の情報のやりとりに
          使うことが多いです。複数のスレッドが錯綜す るようなプログラムの場
          合、ストリームであることの特徴を生かして、 動作を同期させるために
          使うことができます。
        o PipedOutputStream
          PipedInputStreamとつないで使います。
        o PipedReader*
          Unicode文字列版のPipedInputStreamです。
        o PipedWriter*
          Unicode文字列版のPipedOutputStreamです。
        o PrintStream
          JDK1.1においては、このクラスは「古めかしい」ものとして宣言されてい
          ます。 デバッグのためと、従来との互換性を保つために残されているだ
          けです。 このかわりに、PrintWriterを使います。よく使う(使った)メソ
          ッドは 次のようなものがあります。
             + print(何でも) 引数のオブジェクトを文字列の形にしてストリーム
               に出力します。
             + println(何でも) printと同じですが改行文 字が付加されます。
          pintlnが呼びだされるまではブロックします。
        o PrintWriter*
          Unicodeに対応しています。 PrintStreamで実現されていたメソッドはす
          べて移植されています。 PrintStreamと同じように使えます。 printlnが
          呼びだされるまではブロックします。
        o PushbackInputStream
          ストリームを使っているとデータを先読みしたい場合がよく出てきます。
          例えば、 一行の長さを先に知りたいとか、実数か整数かを判別したいと
          かといった場合です。 ストリームは通常一方向の流れなのでそういう場
          合困るのですが、 このクラスを使うと、データを戻す(プッシュバック)
          ことができます。つまり、先に読んだデータを もう一度戻すことによっ
          て、先読みを実現するわけです。そのときに使う メソッドは：
             + unread(int) 一文字戻します。
             + unread(byte[]) byteの配列の長さ分だけ戻します。
             + unread(byte[],int ofs,int len) byteの配列の 始めの位置と長さ
               を指定して戻します。
          その性質と必要上、PushbackOutputStreamはありません。
        o PushbackReader*
          Unicode文字単位のプッシュバックをするクラスです。
             + unread(int)一文字を戻します。
             + unread(char[]) char配列の長さだけ戻します。
             + unread(char[],int ofs,int len) char配列中の位置の長さを指定し
               て 戻します。
        o RandomAccessFile
          好きな位置をアクセスできるファイルを開きます。開くにはコンストラク
          タでファイル名または Fileクラスを指定します。ファイルにアクセスす
          るので、アプレットで使う 時には注意が必要です。
             + RandomAccessFile(File,String mode) Fileを指定します。
             + RandomAccessFile(String,String mode) ファイル名を指定します。
          modeには、"r"(読みこみのみ) または"rw"(読み書きできる)を指定しま
          す。 アクセスするには次のメソッドをよく使います。
             + seek(long) ファイルの指定した位置にアクセスポイントを移動しま
               す。以降の 読み書きはここから始まります。
             + read(),read(byte[]),read(byte[],int,int),readInt(),....
               InputStreamやDataInputStreamで実現されている メソッド群が揃え
               られています。
             + write(int),write(byte[]),write(byte[],int,int),writeInt(int),....
               など、OutputStreamやDataOutputStreamで実現されている メソッド
               群が揃えられています。
             + close()オープンしているファイルを閉じます。
        o Reader*
          Unicode文字列のストリームを読みこむクラスがextendsする abstract ク
          ラスです。自分でUnicode対応の別なストリームクラスを作りたい時はこ
          の クラスをextendsして、メソッドを実装します。
        o SequenceInputStream
          複数のストリームを連続して扱いたい時に使うクラスです。アプレットで
          はあ まり必要ではありませんが、アプリケーションで、引数として与え
          られた多く のファイルを連続で統一的に処理したい場合は多いもので
          す。ある一つの ストリームが終わりになると、次のストリームにスイッ
          チします。サンプルプ ログラムを示します。実行してみると働きは一目
          瞭然です。

          import java.util.*;
          import java.io.*;
          class hoge {
              public static void main(String args[] ){
                  try{
                      FileInputStream f1 = new FileInputStream("aho.txt");
                      FileInputStream f2 = new FileInputStream("hoge.txt");
                      Vector v = new Vector();   // まずVectorを作る
                      v.addElement( f1 );
                      v.addElement( f2 );
                      v.addElement( System.in ); // こんなのを加えてもよい。
                      Enumeration enum = v.elements();
                      SequenceInputStream sin = new SequenceInputStream( enum );
                      while(true) System.out.print( (char) sin.read() );
                  }catch( Throwable t ){  System.out.println( t );   }
              }
          }

        o StreamTokenizer
          ストリームからの入力を、トークンごとに切りわける助けをするクラスで
          す。
        o StringBufferInputStream
          JDK1.1においては、このクラスは「古めかしい」と宣言されています。こ
          の代 わりに、次項のStringReaderを使うべきだとされています。 文字列
          をストリームとして使えるようにします。
        o StringReader*
          Unicode文字列(String)を情報源とするストリームを作ります。
        o StringWriter*
          Unicode文字列に出力するストリームです。
        o Writer*
          Readerと対をなす出力です。Unicode文字列単位の出力を実現し ます。
          abstractクラスなので、このクラスをextends するには、少なくても
          write(char[],int,int)とflush()とclose() を実装しなくてはなりませ
          ん。

     例外

        o CharConversionException*
          文字列を変換するときの例外です。
        o ConversionBufferFullException*
          変換する時に使うバッファが足りなくなりました。
        o EOFException
          入力の最中に、ファイルの終わりに達っしてしまいました。
        o FileNotFoundException
          ファイルが見つかりませんでした。
        o IOException
          入出力をしようとした時、もしくは最中に例外が発生しました。 他の
          java.io例外の基礎になる例外。
        o InterruptedIOException
          入出力に割りこみがかけられました。
        o InvalidClassException*
          オブジェクトをシリアライズする時に問題が発生しました。
        o InvalidObjectException*
          クラスがシリアライズされることを禁止している時にシリアライズしよう
          としました。
        o MalformedInputException*
          入力の文字フォーマットがおかしい。
        o NotActiveException*
          シリアライズの機能が働かなくなっています。
        o NotSerializableException*
          シリアライズしようとしているクラスがSerializableインター フェイス
          をimplementsしていない。
        o ObjectStreamException*
          シリアライズ関連の例外の基礎になる例外。
        o OptionalDataException*
          readObjectが発生する例外。
        o StreamCorruptedException*
          オブジェクトストリームの一貫性検査にひっかかりました。
        o SyncFailedException*
          ストリームをsyncしようとした時の例外です。
        o UTFDataFormatException
          DataInputStreamのreadUTF()が投げます。
        o UnknownCharacterException*
          文字コードが異常です。
        o UnsupportedEncodingException*
          要求されている文字フォーマットはサポートされていません。
        o WriteAbortedException*
          他のシリアライズ関連の例外が書きこみ中に発生している時に読みこんで
          いる場合、投げられます。

java.lang

     Javaの基本となるクラス群です。ともかくもこのパッケージがないと始まりま
     せん。 ということで、このパッケージだけはimportしなくてもよいようになっ
     ています。

     インターフェイス

        o Cloneable
		Cloneableなオブジェクトは、コピーしたりclone()したりすることができ
		ます。
        o Runnable
		Threadのサブクラスを作らずに、スレッドを作ることができます。
	 	public void run()をオーバーライドし、そのメソッドの中にスレッドとして
		実行させたいコードを書きます。Thread.sleep()することを忘れずに！

     クラス

        o Bignum*
		桁数が可変な数です。非常に大きな値を扱うことができます。
        o Boolean
		基本型booleanのラッパークラス。メソッドに対してbooleanへの参照を
		渡したい時に使います。
        o Byte*
		基本型byteのラッパークラス。
        o Character
		基本型charのラッパークラス。
        o Class
		VM上に存在するクラスの実行時表現を保管しているクラスです。それぞれの
		クラスの名前その他の情報を得たい時に使えます。
        o ClassLoader
		ファイルやネットワークからVMにクラスをロードする時に、ロードする方法
		を定義するクラスです。
        o Compiler
		コンパイラ。
        o Double
		基本型doubleのラッパークラス。
        o Float
		基本型floatのラッパークラス。
        o Integer
		基本型intのラッパークラス。
        o Long
		基本型longのラッパークラス。
		o Math
		標準数学ライブラリ。すべてのメソッドや変数がstaticなので、インスタンス
		を作ることはできません。ゲームプログラムでよく使うメソッドを挙げます。
		* Math.abs(x)  絶対値を求めます。どんな型でも使えます。
		* double Math.sin(double)  sinを求めます。引数はradで、返り値は-1から1.
		* double Math.cos(double)	cosを求めます。
		* double Math.atan(double)	アークタンジェント。返り値は±π/2です。
		* Math.min(a,b)	小さい方を返します。どんな型でも使えます。
		* Math.max(a,b)	大きい方を返します。
		* double Math.sqrt(double)	平方根を返します。
		* double Math.tan(double)	タンジェントを返します。引数はラジアンです。
		* double Math.random()		0.0から1.0の間の乱数を返します。
		o Number
		数値をあらわす全てのクラスのスーパークラスです。
        o Object
		すべてのクラスのスーパークラスです。クラスの定義の時にextends Objectを
		省略すると、自動的にextendsします。
        o Process
		Javaから起動している他のプロセスに関する情報や、標準出力/標準入力など
		を得ることができます。他のプロセスは、java.lang.Runtime.exec()を使って
		起動することができます。
        o Runtime
		JavaのVMの動作状況に関する情報を得たり、操作したりします。
		* Runtime.exec(String,String[]) 他のプロセスを引数つきで起動する
		* Runtime.exit(int) システムを終了する
		* Runtime.freeMemory() 空きメモリ量を得る
		* Runtime.totalMemory() 全使用メモリ量を得る
		* pRuntime.gc() ガベージコレクタを起動する
        o SecurityManager
		VMにクラスがロードされる時にチェックを行ないます。
        o Short*
		基本型shortのラッパークラス。
        o String
		文字列型。よく使うコンストラクタ・メソッドには次のようなものが
		あります。
		* String(byte[])		バイト列から文字列を作る
		* String(byte[],int ofs,int len) バイト列の指定した位置から文字列を作る
		* String(byte[],int HB,int ofs , int len ) (JDK1.0のみ)
		* String(char[])		char型の配列から文字列を作る
		char charAt( int index) (index-1)文字目の文字を返します。
		* void getChars(int srcBgn,int srcEnd,char carray[],int begin)
		文字列から、char型の配列を取りだします。
		* void getBytes( int srcBgn,int srcEnd, byte barray[] , int begin)
		文字列から、byte型の配列を取りだします。(1.0のみ)
		* byte[] getBytes() 文字列から配列を取りだすのには、これが最も
		便利でしょう。このメソッドを呼びだす前にnew byte[..]しておく必要は
		ありません。
		* int indexOf(int ch)指定した文字が最初に現れる位置を返します。
		* int lastIndexOf( int ch ) 最後に現れる位置を返します。
		* String substring( int begin,int end ) 部分的な文字列を返します。
		* String toLowerCase() 全て小文字にします。

		* Stringを使う時には、
		*StringIndexOutOfBoundsException に気をつけましょう。
	
        o StringBuffer
		Javaでは文字列を足し算できますが、それを実現するためのクラスです。
		コンパイラが活用する程度で、直接に使うことはないでしょう。
        o System
		VMが動作している環境に依存しない、システム機能を提供します。
		よく使う変数、メソッド：
		* System.out   標準出力
		* System.in    標準入力
		* System.err   標準エラー出力
		* System.arraycopy(Object src,int sbgn,Object dest,int dbgn, int len)
		高速配列コピー。ArrayIndexOutOfBoundsException,ArrayStoreException.
		* System.currentTimeMillis() ミリ秒単位で現在の時間を調べます。重宝。
		* System.exit(int code);		Java VM全体の実行を終了します。
		* System.gc()  ガベージコレクタを実行します。
		* System.getProperty(String name) システムの設定を得ます。
		o Thread
		複数同時に実行されうる、一連の処理の流れです。スレッドを新しく作るには
		* Thread( Runnable )のようにします。
		* Thread.sleep(long millisec)	ミリ秒を指定して、その間他のスレッドを
		実行します。
		* start()		起動します。
		* stop()		止めます。
		* run()		それぞれのスレッドの実体です。
		* interrupt() 割りこみます。
        o ThreadGroup
		スレッドをグループ化します。
        o Throwable
		例外やエラーなど、throwできるオブジェクトはすべて、このクラス
		をextendsします。
		* printStackTrace()    スタックの状態を表示します。
        o Void*
		基本型voidを意味するクラスへの参照を作ることができます。

     例外

        o ArithmeticException
		0で割り算しました。
        o ArrayIndexOutOfBoundsException
		配列の要素番号の範囲を越えました。
        o ArrayStoreException
		配列に、間違った型のオブジェクトを保存しようとしました。
        o ClassCastException
		キャストできない型にキャストしようとしました。
        o ClassNotFoundException
		クラスが見つからなかった(ので、読みこめませんでした。)
        o CloneNotSupportedException
		そのクラスは、clone()することができませんでした。
        o Exception
		普通のプログラムによってtry〜catchされるべき例外です。(Errorは、
		try〜catchされるべきだとは指示されていません。)
        o IllegalAccessException
		メソッドが見つかりません。
        o IllegalArgumentException
		引数が異常です。
        o IllegalMonitorStateException
		モニタが有効でない時に使用しようとしました。
        o IllegalStateException*
		メソッドを、使用するべき時でないのに使用しようとしました。
        o IllegalThreadStateException
		スレッドに対する特定の操作が使用できない時に、使用しようとしました。
        o IndexOutOfBoundsException
		配列その他の、インデクスが範囲を越えました。
        o InstantiationException
		abstractクラスやインターフェイスをインスタンス化しようとしました。
        o InterruptedException
		スレッドに対して割りこみが発生しました。
        o NegativeArraySizeException
		配列のサイズが負です。
        o NoSuchFieldException*
		指定された名前の変数は、このクラスには存在しません。
        o NoSuchMethodException
		指定された名前のメソッドは、このクラスには存在しません。
        o NullPointerException
		ヌル参照に対してアクセスしようとしました。
        o NumberFormatException
		文字列から数値に変換できない形式の文字列でした。
        o RuntimeException
		Java VMの実行中に起こる可能性のある例外のスーパークラス。
        o SecurityException
		セキュリティ違反。
        o StringIndexOutOfBoundsException
		文字列の文字数の範囲を越えた操作が行なわれました。

     エラー

        o AbstractMethodError
		abstractなメソッドを呼びだそうとしました。
        o ClassCircularityError
		クラスを初期化する時に、再帰的な構造になっていることがわかりました。
        o ClassFormatError
		読みこもうとしているクラスの形式がおかしい。
        o Error
		実行中に、本来起こるべきでない事が起こったことを意味する例外です。
		普通のプログラムは、Errorをtry〜catchしようとしてはいけません。
        o ExceptionInInitializerError*
		イニシャライザでエラーが発生しました。
        o IllegalAccessError
		アクセス例外
        o IncompatibleClassChangeError
		互換性のないクラス変更が発生した。
        o InstantiationError
		インタプリタが、abstractなクラスまたはinterfaceをインスタンス化し
		ようとした。
        o InternalError
		内部エラー。
        o LinkageError
		他のクラスに依存性があるクラス群の互換性がなくなった。
        o NoClassDefFoundError
		クラスがみつからなかった。
        o NoSuchFieldError
		特定のフィールド(変数)がみつからなかった。
        o NoSuchMethodError
		特定のメソッドが見つからなかった。
        o OutOfMemoryError
		メモリ不足
        o StackOverflowError
		スタック溢れ
        o ThreadDeath
		thread.stop()が呼びだされた。
        o UnknownError
		不明な、しかし重大なエラーが発生した。
        o UnsatisfiedLinkError
		不良なリンク。
        o VerifyError
		クラスの内容チェック時エラー。
        o VirtualMachineError
		仮想マシン(VM)が壊れているか、資源を使い果した。

java.lang.reflect*

	クラスやメソッド自体を扱うためのパッケージです。配列オブジェクトの
	インスタンスを直接作ったり、クラスからメソッドを抽出したりできます。
	プログラムが実行中に変化していくような効果を出せます。敵のアルゴリズム
	が変化していくとか、ゲームにも応用ができそうです。Methodクラスにいたっ
	ては、Cでいう関数ポインタのように使えます。

     インターフェイス

        o Member*
		あるクラスのメンバー(変数あるいはメソッド)またはコンストラクタであ
		るということを規定するインターフェース。

     クラス

        o Array*
		配列オブジェクト自体を操作します。例えば次のふたつのコードは同じ
		意味です。
		1) String sa[] = new String[20];
		2) String sa[] = Array.newInstance( new String().getClass(), 20 )

        o Constructor*
		それぞれのクラスのコンストラクタを表します。Constructorのインスタンス
		からは、引数や修飾子など、色々な情報が引きだせます。インスタンスを
		作ることもできます。(newInstance)
		1) Class cl = new String().getClass();
		2) Constructor ccc[] = cl.getConstructors();
		3) Class ptypes[] = ccc[0].getParameterTypes();
        o Field*
		それぞれのクラスのフィールド変数をあらわします。使いかたはConstructor
		とほぼ同じです。
        o Method*
		それぞれのクラスのメソッドをあらわします。
        o Modifier*
		それぞれのクラスやフィールド、メソッド、などの修飾子を識別するため
		のメソッドを含んでいます。
		例えば、Stringクラスがfinalかどうかは、次のように
		して調べることができます。
		1) Class cl = new String().getClass();
		2) boolean fflg = Modifier.isFinal( cl.getModifiers() );
	

     例外

        o InvocationTargetException*
		メソッド呼びだしの対象オブジェクトが、違法なものだった。


java.net

     ネットワーク機能を実現するパッケージです。JDK1.1では例外が細かく 分けら
     れたのと、マルチキャストが可能になったこと、Socket クラスがfinalではな
     くなったことが重要な変化でしょうか。

     インターフェイス

        o ContentHandlerFactory
		適切なContentHandlerを呼びだしてURLConnectionからの入力を
		変換する助けをします。

        o FileNameMap*
		ファイル名と、MIMEタイプの間のシンプルな対応付けをするための
		インターフェース。

        o SocketImplFactory
		SocketImplのインスタンスを様々な方法で作るためのインターフェース。

        o URLStreamHandlerFactory
		URLクラスは、プロトコルの種類によって様々なURLStreamHandlerを作成するが、
		そのために使用されます。

     クラス

        o ContentHandler
		URLConnectionからの入力をオブジェクトに変換するためのクラス。

        o DatagramPacket
		パケットの長さ、内容、IPアドレス、ポートの番号を備えたパケット。
	
        o DatagramSocket
		情報の欠損が生じるかもしれないデータグラムパケットの通信路を表します。
		* DatagramSocket( in port ) コンストラクタ
		* void send( DatagramPacket p )		送信
		* void receive( DatagramPacket p )	受信
		* void close()		閉じる

        o DatagramSocketImpl*
		データグラムソケットとマルチキャストソケットの実装のための
		基本クラス。

        o HttpURLConnection*
		HTTPの特徴に対応したURLConnection。

        o InetAddress
		一つのインターネットアドレス(IPアドレス)を表すクラス。
		* byte[] getAddress()  4バイトのIPアドレスを、ネットワークバイト
		オーダで得ます。
		* InetAddress.getByName(String) ホスト名からIPアドレスを得ます。

        o MulticastSocket*
		IP上でマルチキャストメッセージを送ったり受けとったりします。現在は、
		アプレットからは、このソケットを使えません。
		* MulticastSocket( int port )		コンストラクタ。
		* send( DatagramPacket, byte ttl)  送信します。
		
        o ServerSocket
		サーバーのソケットを表すクラス。
		* ServerSocket( int port )	コンストラクタ。

        o Socket
		クライアントのソケットを表すクラス。実際のソケット操作には、SocketImpl
		クラスを使っています。
		* Socket(String hostname , int port ) ソケットを作成します。
		クライアントからソケットを開いて、入出力を開始するには次の手順を
		踏みます。
		1) Socket so = new Socket( hostname , port );
		2) OutputStream out = so.getOutputStream();
		3) InputStream in = so.getInputStream();
		4) .....処理
		5) so.close();

        o SocketImpl
		Socket,ServerSocketの実際の操作は、このクラスによって行なわれます。

        o URL
		WWW上の資源を一意に特定できるオブジェクトです。定数であり、一旦作成
		されると、変更はできません。
		* URL(String urlstring) (MalformedURLException) コンストラクタ。 
		* Object getContent() (IOEx)  URLで指定される情報の種類に応じて、
		Imageなどのオブジェクトに変換します。
		* URLConnection openConnection() (IOEx)
		URLクラスを使って、あるサイトの情報を得るには、次の手順を踏みます。
		1) URL url = new URL(...);
		2) URLConnection uc = url.openConnection();
		3) uc.setDoInput();   // 出力する場合はuc.setDoOutput()
		4) InputStream in = uc.getInputStream();
		5) in.close();

        o URLConnection
		URLによって示されるオブジェクトへのアクティブな接続を表します。
		* getContent() URLによって示されるオブジェクトの内容を得ます。

        o URLEncoder
		普通の文字列を、 x-www-form-urlencodedフォーマットに変換します。
		* String URLEncoder.encode( String )   変換します。
		
        o URLStreamHandler
		URLのストリームを開くためのabstractクラス。

     例外

        o BindException*
		ポートが使用中であるとか、アドレスがおかしい、という理由により、バインド
		できなかった。
        o ConnectException*
		リモートのアドレスとポートに接続できなかった。相手のポートはlistenされて
		いなかった。
        o MalformedURLException
		URLの表記に誤りがあった。 new URL( String..)する時に発生します。引数の
		文字列をチェックしましょう。
        o NoRouteToHostException*
		接続先までの間にあるルータが落ちているか、もしくは、ファイアウォールに
		よって接続が拒否されたため、到達できなかった。
        o ProtocolException
		プロトコル例外。Socketクラスで発生。
        o SocketException
		ソケットを使おうとした時に何らかたの例外が生じた。
        o UnknownHostException
		アドレスからIPアドレスを得ることができなかった。
        o UnknownServiceException
		不明なサービスを使用しようとした。

java.rmi*

     オブジェクトシリアライズを基盤とする、「遠隔メソッド呼びだし」を実現す
     る パッケージです。他のバーチャルマシンに存在するオブジェクトのメソッド
     を、 その「代理」を介することによって呼びだします。そのためにはサーバー
     に 関連する情報を登録しておく必要があります。それらのことをするためには
     別の java.rmi.registryや、java.rmi.serverなどといった パッケージを使う
     必要があります。

     インターフェイス

        o Remote*
		オブジェクトが、リモートに存在することを指示するインターフェース。
		リモートオブジェクトは、すべてこのインターフェースをimplementsしなけれ
		ばなりません。

     クラス

        o Naming*
		URLによって示されるリモートオブジェクトへの参照を得るために使われます。
        o RMISecurityManager*
		リモートからロードされるスタブクラスは、RMISecurityManagerを通さない
		限りはロードされません。クライアントのmain()メソッドに、
		System.setSecurityManager( new RMISecurityManager());
		の一行を加えればOKです。


     例外

        o AccessException*
		リモートオブジェクトのアクセス例外。
        o AlreadyBoundException*
		リモートオブジェクトがすでにバインドされていた。
        o ConnectException*
		クライアント->サーバの接続に関する例外。
        o ConnectIOException*
		クライアント->サーバの接続に関する例外。
        o MarshalException*
		シリアライズ時の例外
        o NoSuchObjectException*
		そのようなオブジェクトはない。
        o NotBoundException*
		lookup()した時に名前がバインドされていなかった。
        o RMISecurityException*
		セキュリティチェックにひっかかった。
        o RemoteException*
		RMIレジストリに接続できなかった。
        o ServerError*
		サーバーエラー。
        o ServerException*
		サーバーで未知の例外が発生した。
        o ServerRuntimeException*
		サーバーの実行時エラー。
        o StubNotFoundException*
		スタブクラスが見つからない。
        o UnexpectedException*
		予期せぬ例外。
        o UnknownHostException*
		ホスト名からアドレスを辿れない。
        o UnknownServiceException*
		未知のサービスを使用しようとした。
        o UnmarshalException*
		シリアライズ時の例外

java.rmi.dgc*

     ネットワーク上にはたくさんのJavaバーチャルマシンが存在しますが、それら
     を 統一的なIDで管理し、ガベージ・コレクション(メモりのごみあつめ)をする
     ためのパッケージです。サーバ側で操作します。RMIを使うだけなら、通常は
     このパッケージは使いません。説明は省略します。

     インターフェイス

        o DGC*

     クラス

        o Lease*
        o VMID*

java.rmi.registry*

     ネットワークを介してJavaのアプリケーションサーバーと接続するには、 レジ
     ストリに登録しておく必要があります。このパッケージは登録とオブジェ クト
     探しの処理をするために使われます。RMIを使うだけなら、このパッケージは使
     いません。説明は省略します。

     インターフェイス

        o Registry*
        o RegistryHandler*

     クラス

        o LocateRegistry*

java.rmi.server*

     RMIのアプリケーションサーバーを作る時に使います。

     インターフェイス

        o LoaderHandler*
		RMIクラスローダを扱うためのインターフェース。
        o RMIFailureHandler*
		サーバ・クライアントの接続ができなかったときの動作を規定するための
		インターフェース。
        o RemoteCall*
		リモートオブジェクトの呼びだしを実装するためのインターフェース。
        o RemoteRef*
		リモートオブジェクトへの参照を表します。
        o ServerRef*
		リモートオブジェクトのサーバ側の参照を表します。
        o Skeleton*
		rmicによって作られるスケルトンクラスは、すべてこのインターフェースを
		impelementsします。サーバ側のスケルトンは、リモートオブジェクトへの
		呼びだしを実際に送信します。
        o Unreferenced*
		リモートオブジェクトへの参照がなくなったときに、その通知を受けとる
		ことができるように、リモートオブジェクトは、このインターフェースを
		implementsしておくべきです。

     クラス

        o LogStream*
		RMIを使ったシステムのデバッグに使います。
        o ObjID*
		VM内で、時間を経ても一意にオブジェクトを特定できるIDです。
        o Operation*
		Javaのメソッドの記述を保持します。
        o RMIClassLoader*
		ネットワークを通じてクラスをロードする機構を提供します。
        o RMISocketFactory*
		RMI呼びだしを実現するための、クライアント・サーバー接続を実現するために
		使われます。
        o RemoteObject*
		リモートオブジェクトが、java.lang.Objectのような振舞いができるように
		するためのクラスです。
        o RemoteServer*
		リモート参照を提供するための枠組を提供します。サーバーを実装するには、
		このクラスをextendsします。
        o RemoteStub*
		クライアントのスタブクラスの一般的なスーパークラスです。スタブとは、
		リモートオブジェクトと全く同一な代理です。
        o UID*
		あるホスト上で唯一なIDを作ります。唯一にするために、時間の情報
		が使われます。
        o UnicastRemoteObject*
		サーバが行きている間だけ有効な、ただひとつしかないリモートオブジェクト
		を定義します。
				

     例外

        o ExportException*
		exportできなかった。
        o ServerCloneException*
		サーバが多重化しています。
        o ServerNotActiveException*
		サーバがアクティブではありません。
        o SkeletonMismatchException*
		スケルトンとリモートオブジェクトの対応がとれていません。
        o SkeletonNotFoundException*
		スケルトンクラスが見つかりません。
        o SocketSecurityException *
		セキュリティ例外。

java.security*

     このパッケージは、パスワードや企業の情報管理など、より高度な セキュリテ
     ィ機能が必要なアプリケーションを開発するために使われます。 JDK1.1のベー
     タ版ではまだ実装が不完全です。このパッケージの内容は、	
     本書の内容からは外れているため、説明を省略します。

     インターフェイス

        o Certificate*
        o KeyParams*
        o Principal*

     クラス

        o DigestInputStream*
        o DigestOutputStream*
        o Identity*
        o IdentityScope*
        o Key*
        o KeyPair*
        o MessageDigest*
        o PrivateKey*
        o Provider*
        o PublicKey*
        o SecureRandom*
        o Security*
        o Signature*
        o Signer*

     例外

        o DigestException*
        o InvalidKeyException*
        o InvalidParameterException*
        o KeyException*
        o KeyManagementException*
        o NoSuchAlgorithmException*
        o NoSuchProviderException*
        o ProviderException*
        o SignatureException *

java.security.acl*

     java.securityと同様の理由で、省略します。

     インターフェイス

        o Acl*
        o AclEntry*
        o Group*
        o Owner*
        o Permission*

     クラス

     例外

        o AclNotFoundException*
        o LastOwnerException*
        o NotOwnerException *

java.security.interfaces*

     java.securityと同様の理由で、省略します。

     インターフェイス

        o DSAKey*
        o DSAParams*
        o DSAPublicKey*

java.sql*

     javaアプリケーション/アプレットが、非常に有用なデータベースアクセス端末
     になりうる ことが研究によって明らかになってきたことから開発されたパッケ
     ージです。メソッド 一発でSQLのデータベースサーバにアクセスすることがで
     きます。これを使えば ゲームも作ることができるかもしれませんが、サーバの
     管理やプロトコルなどの 説明が必要でそれは本書の範囲を越えてしまいます。
     したがって説明は省略します。

     インターフェイス

        o CallableStatement*
        o Connection*
        o DatabaseMetaData*
        o Driver*
        o PreparedStatement*
        o ResultSet*
        o ResultSetMetaData*
        o Statement *

     クラス

        o Date*
        o DriverManager*
        o DriverPropertyInfo*
        o Time*
        o Timestamp*
        o Types*

     例外

        o DataTruncation*
        o SQLException*
        o SQLWarning *

java.text*

     国際化された文字列を扱うためのパッケージです。本書の内容と関連が薄い
	 ので、説明は省略します。

     インターフェイス

        o CharacterIterator*

     クラス

        o ChoiceFormat*
        o CollatedString*
        o Collation*
        o CollationElementIterator*
        o CollationKey*
        o DateFormat*
        o DateFormatData*
        o DecimalFormat*
        o Format*
        o FormatStatus*
        o MessageFormat*
        o NumberFormat*
        o NumberFormatData*
        o ParseStatus*
        o SimpleDateFormat*
        o SortKey*
        o StringCharacterIterator*
        o TableCollation*
        o TextBoundary*

     例外

        o FormatException*

java.util

     他のパッケージには区別できないような、それでいて必要なクラス群が 含まれ
     ています。JDK1.1では国際化やイベント関連でかなり拡張されました。

     インターフェイス

        o Enumeration
		一組の値を並べたり、数えたりするためのメソッドを定義するイン
		ターフェースです。
		* boolean hasMoreElements()  次の要素が存在するかどうかを調べます。
		* Object nextElement()		次の要素を取りだします。
        o EventListener*
		全てのイベントリスナは、このインターフェースをextendsします。
        o Observer
		このインターフェースをimplementsすると、Observerによって監視できる
		ようになります。

     クラス

        o BitSet
		一組のビットのセット。必要に応じてサイズは伸びていきます。
        o Calendar*
		Dateオブジェクトと、年や月、日をあらわすint値との間の変換を行ないます。
		変換はさまざまなフォーマットを指定することができます。HTML版のオン
		ラインマニュアルに詳しいので、そちらを参照してください。
        o Date
		ミリ秒の単位で、時間を管理します。
        o Dictionary
		Hashtableのスーパークラスです。
        o EventObject*
		イベントをあらわすオブジェクトです。java.awt.eventの下のイベント群も、
		すべてこのオブジェクトをextendsしています。
		o GregorianCalendar*
		Calenderをextendsしています。グレゴリアン暦を使用してDateから変換します。
        o Hashtable
		便利なハッシュ・テーブルです。巨大な文字列の配列同士の比較をする場合
		などには、一旦ハッシュテーブルを作ると高速に処理することができます。
        o ListResourceBundle*
		言語間の特定の文字列の対応のリストを定義するクラスです。
        o Locale*
		国際化メソッドで使用する言語の名前です。
        o Observable
		Model-Viewパラダイムにおける、「観察されるデータ」は、このクラスを
		extendsします。データは自分自身が変化したことを、Observerで定義されて
		いるupdateメソッドを呼びだすことによって、知らせます。
        o Properties
		ストリームでセーブ/ロードできるハッシュテーブル。
        o PropertyResourceBundle*
		ストリームに保存したりロードしたりできるリソース。
        o Random
		乱数発生器。いつも同じ乱数列を発生させたい場合は、 new Random( 100);
		というように、long値を指定します。インスタンスが必要です。
		1) Random r = new Random(n);
		2) r.nextInt();   int値の最大値から最小値まで、負も含みます。
		
        o ResourceBundle*
		複数の言語に対応したプログラムを作りやすくするためのクラスです。言語に
		応じた一組のオブジェクトにアクセスします。
        o SimpleTimeZone*
		グレゴリアン暦に沿った単純なタイムゾーンを生成します。
        o Stack*
		LIFO(Last-In-First-Out)のスタックオブジェクトです。

        o StringTokenizer
		文字列をトークンに分解します。CGIのプログラムをする時などには重宝する
		でしょう。デフォルトでは " \n\r\t"をトークン分割文字とします。
		1) StringTokenizer st = new StringTokenizer( "this is a test" ," " );
		2) String next = st.nextToken() ....連続的にこのメソッドを呼びだします。

        o TimeZone*
		値域による時差をあらわします。

        o Vector
		必要に応じて長さが伸びる配列です。たくさんの要素を挿入するときは、
		setSize(int)を先に実行したほうが高速です。典型的な使用例：
		1) Vector v = new Vector();
		2) v.addElement( Object);
		3) Enumeration enm = v.elements();

     例外

        o EmptyStackException
		スタックが空なのにpopしようとした。
        o MissingResourceException*
		指定されたリソースが存在しない。
        o NoSuchElementException
		そのような要素は存在しない。
        o TooManyListenersException *
		イベントリスナが多すぎる。

java.util.zip*

     zipやgzipに代表される、情報を圧縮するためのパッケージです。
	 JDK1.1beta2の段階では、多少バグがあるようです。
	基本的には、
	1) GZIPInputStream gin = new GZIPInputStream( new FileInputStream(..));
	2) gin.write( byte[],...);
	というようにすれば、GZIP圧縮されたファイルを読みこむことができます。
	(しかし、バグがあるようで、正しく読みこめません。)
	というように使います。詳しいパッケージの説明は省略します。

     インターフェイス

        o Checksum*

     クラス

        o Adler32*
        o CRC32*
        o CheckedInputStream*
        o CheckedOutputStream*
        o Deflater*
        o DeflaterOutputStream*
        o GZIPInputStream*
        o GZIPOutputStream*
        o Inflater*
        o InflaterInputStream*
        o ZipEntry*
        o ZipFile*
        o ZipInputStream*
        o ZipOutputStream*

     例外

        o DataFormatException*
        o ZipException*

********************************************************************

エラーメッセージ





エラーの種類は、そのタイミングによって、コンパイルする時と、実行している時の
もの に分けることができます。コンパイルした時にエラーがなくても、実行中に何
らかの バグによって例外が発生するときは多くあります。コンパイル時のエラー
は、プログラム を書きかえて、一つも出なくなるまで根気よく試行錯誤してくださ
い。実行時のエラーは、「例外」または「エラー」と呼ばれるものです。
これらは、よく発生するものについては「ライブラリリファレンス」で説明しています
ので、よくわからない場合は、そちらを参照してください。



----------------------------------------------------------------------------

コンパイルする時のエラー

このエラーメッセージは、JDKの配布パッケージの中のlibディレクトリの中にある、
javac.propertiesというファイルを日本語化したものを、
http://www.sun.co.jp/smi.jp/tech/java/index.htmlから
取ってきて多少変更したものです。javac.propertiesを日本語版と入れかえると、
javacのエラー出力が日本語になります。そのためのファイルがCD-ROMに収められ
ています。以下のメッセージは、JDK1.1のjavacのものです。1.0.2から増えた分に
関しては、仮に筆者が訳しました。正式な版がSunから発表されることを願います。
文字列中に、%sが出てきますが、それらは、英語中の順番と一致させて、以下のよう
に読んでください。

例：

Your friend %s is very %s.  -> 君の友達の%sはたいへん%sです。
Your friend Nobita is very lazy.  -> 君の友達ののび太はたいへんぐうたらです。

----------------------------------------------------------------------------
* Internal error.
        内部エラー.
* Comment not terminated at end of input.
        コメントが閉じられていません.
* String not terminated at end of input.
        文字列がファイル末尾までに閉じられていません.
* String not terminated at end of line.
        文字列が行末までに閉じられていません.
* Invalid character constant.
        不当な文字定数です.
* Unbalanced parentheses.
        括弧が対応していません.
* Invalid escape character.
        不当なエスケープ文字です. JIS/SJISでプログラムを書いていると、発生する
		可能性があります。
* Invalid character in octal number.
	    8進数に使えない文字が含まれています.
* Invalid character in number.
        数値に使えない文字が含まれています.
* Invalid character in input.
        不当な入力文字が含まれています.全角の空白やセミコロンが含まれて
		いませんか？
* Invalid floating point format.
		浮動小数の表記が誤っています.
* Numeric overflow.
        数値がオーバーフローしました.
* Numeric underflow.
        数値がアンダーフローしました.
* '%s' expected.
		'%s'が必要です。 '%s'というのは、トークンのことです。以下、'%s'のような
		表現は、そこにエラーの原因となった文字列が入ります。
* Statement expected.
        文が必要です.
* Type expected.
        型を指定して下さい.
* Identifier expected.
        識別子を指定して下さい.
* 'class' or 'interface' keyword expected.
        'class' あるいは 'interface' を指定して下さい.
* Class or interface declaration expected.
        クラス定義またはインターフェース定義が必要です.
* Missing term.
        構文エラーです.
* 'else' without 'if'.
        'else' に対応する 'if' がありません. 中括弧の対応がおかしくないですか？
* 'catch' without 'try'.
        'catch' に対応する 'try' がありません.
* 'finally' without 'try'.
        'finally' に対応する 'try' がありません.
* 'try' without 'catch' or 'finally'.
        'try' に対応する 'catch' または 'finally' がありません.
* 'case' outside switch statement.
        'case' がswitch文の外で使用されています.
* 'default' outside switch statement.
        'default' がswitch文の外で使用されています.
* I/O error in %s.
        %sに対する入出力エラーが発生しました.
* Array index required.
        配列の添字が必要です.
* [] can only be applied to arrays. It can't be applied to %s.
        [] は配列のみに適用可能で、%sに適用することはできません.
* Can't specify array dimension in a declaration.
        宣言時に配列の次元数を指定することはできません.
* Can't specify array dimension in a type expression.
        型表記に配列の次元数を指定することはできません.
* Array constants can only be used in initializers.
        配列定数は初期化子にしか使用できません.
* Invalid initializer for type %s.
        %sに対して、不当な初期化子が指定されています.
* Invalid left hand side of assignment.
        代入に不当な左辺値が指定されています.
* Invalid arguments to %s.
        %sに対して、不当な引数が指定されています.
* Invalid cast from %s to %s.
        %sから%sへはキャストできません.
* Impossible for %s to be instance of %s.
        %sは%sのインスタンスでは有り得ません(型が一致しません).
* Invalid type expression.
        不当な型表記です.
* Only named classes can have 'extends' or 'implements' clauses.
     	名前がつけられているクラスだけしか、'extends'または 'implements'節を
		持つことはできません。(JDK1.1)
* Attempt to reference field %s in a %s.
	  フィールド%s(%sで定義)を参照できません.
* No variable %s defined in %s.
      変数%sは%sには定義されていません.
* Variable %s in %s not accessible from %s.
		変数'%s'(%sで定義されている)は内部型なので、%sからはアクセスできません。
		(JDK1.1)
* Inner type %s in %s not accessible from %s.
		'%s'(%sで定義されている)は内部型なので、'%s'からはアクセスできません。
		(JDK1.1)
* Can't make a static reference to nonstatic variable %s in %s.
		非staticな変数%s(%sで定義)を、staticに参照することはできません.        
* Can't make a static reference to inner class %s.
		内部クラス%sへのstaticな参照をすることはできません。(JDK1.1)
* Reference to %s is ambiguous. It is defined in %s and %s.
        %sへの参照はあいまいです(%sおよび%sで定義されています).
* Attempt to reference method %s in %s as an instance variable.
        メソッド%s(%sで定義)をインスタンス変数として参照しようとしています.
* Can't assign a value to a final variable: %s
        final変数に値を代入することはできません: %s
* Can't assign a second value to a blank final variable: %s
		空宣言されたfinal変数に2度目以降は値を代入することはできません:%s
		(JDK1.1)
* Attempt to assign a blank final %s variable in a loop. The initialization
		must occur exactly once.
		空宣言されたfinal変数%sをループの中で初期化することはできません。正確に
		一度だけしか初期化されてはいけません。(JDK1.1)
* Attempt to assign to a variable %s in a different method. From enclosing 
blocks, only final local variables are available.
		異なるメソッド注で変数%sに代入しようとしました。このブロックからは、
		finalなローカル変数しか使えません。
*  Attempt to use a non-final variable %s from a different method. From 
enclosing blocks, only final local variables are available.
		異なるメソッドからfinalでない変数%sを使おうとしました。このブロックから
		は、finalなローカル変数しか使えません。
* Access across scopes to the private member %s in %s is not implemented.  
The reference will succeed if the member is given package scope.
		スコープ境界を越えてのprivateメンバ%s(%sで定義)は実装されていません。
		参照は、packageスコープ以上でないと成功しません。
* Undefined variable: %s
        変数が未定義です: %s
* Undefined variable or package name: %s
		変数またはパッケージが未定義です: %s
* Undefined variable, class, or package name: %s
		変数またはクラスまたはパッケージが未定義です: %s
* Undefined variable or class name: %s
		変数またはクラスが未定義です: %s
* Variable %s may not have been initialized.
      	変数%sは初期化されない可能性があります.
* Blank final variable '%s' may not have been initialized. 
It must be assigned a value in an initializer, or in every constructor.
		空宣言されているfinal変数'%s'は初期化されない可能性があります。イニシャ
		ライザで初期化するか、すべてのコンストラクタで初期化してください。
* Can't reference %s before the superclass constructor has been called.
        スーパークラスのコンストラクタが呼ばれる前に%sを参照することはできません.
* Ambiguous class: %s and %s
        クラスがあいまいです: %sおよび%s
* Invalid argument to %s.
        %sに対し、不当な引数が指定されています.
* Invalid argument type %s for %s.
        不当な引数の型%sが%sに対して指定されています.
* 'length' applied to %s, which is not an array.
        配列ではない%sに対して、'length' が適用されています.
* Only constructors can invoke constructors.
        コンストラクタはコンストラクタ中からしか呼び出せません.
* Constructor invocation must be the first thing in a method.
        コンストラクタでは、まずはじめにコンストラクタを呼び出さなくてはい
		けません.
* Can't invoke a method on a %s.
        %sに対してメソッド呼び出しをすることはできません.
* Method %s not found in %s.
        メソッド%sは%sには定義されていません.
* Method %s in %s is not accessible from %s.
        メソッド%s(%sで定義)は%sからアクセスできません.
* Can't make static reference to method %s in %s.
        メソッド%s(%sで定義)を、staticに参照することはできません.
* Can't access protected method %s in %s. %s is not a subclass of the 
current class.
        protected宣言されたメソッド%s(%sで定義)を、サブクラスでないクラス(%s)
		から参照することはできません.
* Can't access protected field %s in %s. %s is not a subclass of the current
class.
        protected宣言されたフィールド%s(%sで定義)を、サブクラスでないクラス
		(%s)から参照することはできません.
* Can't access protected inner type %s in %s. %s is not a subclass of the 
current class.
		内部型の%s(%sで定義)はprotectedなのでアクセスできません。%sはカレント
		クラスのサブクラスではありません。
* Reference to variable %s in %s as if it were a method.
        変数%s(%sで定義)をメソッドとして参照しようとしています.
* Reference to method %s in %s as if it were a variable.
		メソッド%s(%sで定義)を変数のように参照しようとしています。
* Note: %s has been deprecated.  Please consult the documentation for a 
better alternative.
		%sは使わないでください。よりよい代替の方法をドキュメントを読んで調べて
		ください。
* Note: The method %s in %s has been deprecated.  Please consult the 
documentation for a better alternative.
		メソッド%s(%sで定義)は使わないでください。よりよい代替の方法をドキュ
		メントを読んで調べてください。
* Note: The constructor %s has been deprecated.  Please consult the 
documentation for a better alternative.
		コンストラクタ%s(%sで定義)は使わないでください。よりよい代替の方法を
		ドキュメントを読んで調べてください。
* Note: The variable %s in %s has been deprecated.  Please consult the
documentation for a better alternative.
		変数%s(%sで定義)は使わないでください。よりよい代替の方法をドキュメント
		を読んで調べてください。
* Invalid array dimension.
        不当な配列次元数です.
* Constructor is ambiguous: %s, %s
        コンストラクタがあいまいです: %s,%s
* Incompatible type for %s. Explicit cast needed to convert %s to %s.
        型%sは非互換です. %sから%sに変換するには明示的なキャストが必要です.
* Incompatible type for %s. Can't convert %s to %s.
        型%sは非互換です. %sから%sに変換することはできません.
* Invalid term.
        不当な語句です.
* %s must be declared abstract. It does not define %s from %s.
        %sは%s(%sより由来)を定義していないため、abstract宣言する必要があります.
* %s must be declared abstract and not final. It does not define %s from %s.
        %sは%s(%sより由来)を定義していないため、abstract宣言する必要があり、
		かつ、final宣言してはいけません.
* %s is an interface. It can't be instantiated.
        %sはインターフェースなので、インスタンス化できません.
* Can't directly invoke abstract method %s in %s.
        abstract宣言されたメソッド%s(%sで定義)を直接呼び出すことはできません.
* No method matching %s found in %s.
        %sに対応するメソッドは%sには見つかりません.
* No constructor matching %s found in %s.
        %sに対応するコンストラクタは%sには見つかりません.
* Wrong number of arguments in %s.
		%sでの引数の数がおかしい。
* Can't make forward reference to %s in %s.
        %s(%s)に対して、前方参照することはできません.
* Array dimension missing.
        配列の次元数が必要です.
* %s is an abstract class. It can't be instantiated.
        %sは抽象クラスなので、インスタンス化できません.
* No label definition found for %s.
        ラベルが未定義です: %s.
* 'break' must be in loop or switch.
        'break' はループ中かswitch文中でしか使えません.
* 'continue' must be in loop.
        'continue' はループ中でしか使えません.
* Invalid declaration.
        不当な宣言です.
* 'return' with value from %s.
        %sからのretun文に値を指定することはできません.
* 'return' without value from %s.
        %sからのreturn文には値を指定しなくてはいけません.
* 'return' inside static initializer.
        staticイニシャライザ中にはreturn文は記述できません.
* Invalid label.
        不当なラベルです.
* Return required at end of %s.
        %sの最後にreturn文が必要です.
* Duplicate case label: %s
        caseラベル%sが多重定義されています.
* Case label %s too large for 'switch' on %s
        caseラベル%sは%sでのswitch文の範囲を越えています.
* Constant expression required.
        定数式を指定して下さい.
* Duplicate 'default' label.
        defaultラベルが複数指定されています.
* '%s' not supported.
        %sはサポートされていません.
* 'return' with value from constructor: %s
        コンストラクタ%sに値をともなったreturn文が指定されています.
* Only one package declaration allowed.
        package文は一つだけしか記述できません.
* Class %s already defined in %s.
        クラス%sは%s中ですでに定義されています.
* Class name %s clashes with imported class %s.
        クラス名%sはインポートされたクラス%sと衝突します.
* Final methods can't be overriden. Method %s is final in %s.
        メソッド%sは%sでfinal宣言されているため、再定義できません.
* Method redefined with different return type: %s was %s
        メソッドを違う型で再定義することはできません: %sと%s
* Static methods can't be overridden. Method %s is static in %s.
        メソッド%sは%sでstatic宣言されているため、再定義できません.
* Instance methods can't be overridden by a static method.Method %s is an
instance method in %s.
        メソッド%sは%sでインスタンスメソッドとして定義されているため、
		staticメソッドとしては再定義できません.
* Methods can't be overridden to be more private. Method %s is public in %s.
        メソッドの公開範囲を狭めて再定義することはできません.
		%sは%sでpublic宣言されています.
* Methods can't be overridden to be more private. Method %s is protected in %s.
        メソッドの公開範囲を狭めて再定義することはできません.
		%sは%sでprotected宣言されています.
* Methods can't be overridden to be more private. Method %s is not private in %s.
        メソッドの公開範囲を狭めて再定義することはできません.
		%sは%sでprivate宣言されていません.
* Interfaces can't have constructors.
        インターフェースにはコンストラクタを定義できません.
* Constructors can't be native, abstract, static, synchronized, or final: %s
        コンストラクタをnative宣言, abstract宣言, static宣言, synchronized宣言,
		あるいは final宣言することはできません: %s
* Interfaces can't have static initializers.
        インターフェースにはstaticイニシャライザを定義できません.
* Interface methods can't be native, static, synchronized, final, private,
		or protected : %s
        インターフェースのメソッドはnative宣言, static宣言, synchronized宣言,
		final宣言, private宣言, あるいは protected宣言できません: %s
* Interface fields can't be private or protected: %s
        インターフェースのフィールドはprivate宣言あるいはprotected宣言でき
		ません: %s
* Method %s can't be transient. Only variables can be transient.
        メソッドはtransient宣言できません: %s
* Method %s can't be volatile. Only variables can be volatile.
        メソッドはvolatile宣言できません: %s
* Static methods can't be abstract: %s
        staticメソッドはabstract宣言できません: %s
* Abstract and native methods can't have a body: %s
        abstract宣言あるいはnative宣言されたメソッドにはメソッド本体を定義
		できません: %s
* Variables can't be synchronized, abstract or native: %s
        変数はsynchronized宣言, abstract宣言あるいはnative宣言できません: %s
* Inner classes can't be volatile, transient, native, or synchronized: %s
		内部クラスは、volatile,transiend,native,synchronizedのいずれも指定でき
		ません。
* Transient variables can't be members of interfaces: %s
        transient宣言された変数はfinal宣言あるいはstatic宣言できません: %s
		transient宣言された変数はインターフェースのメンバになり得ません(筆者注)
* Volatile variables can't be final or members of interfaces: %s
		volatile指定された変数は、final指定できない上に、インターフェースの
		メンバにもなり得ません。: %s
* This final variable must be initialized: %s
        final宣言した変数は初期化する必要があります: %s
* Duplicate method declaration: %s
        メソッド定義が重複しています: %s
* Methods can't be redefined with a different return type: %s was %s
        メソッドを異なる型で再定義することはできません: %sは%s型として
		定義されています
* Duplicate variable declaration: %s was %s
        変数定義が重複しています: %sは%s型として定義されています
* Duplicate inner class declaration: %s is already defined in this scope.
		内部クラスの宣言が重複しています。 %s はスコープ内ですでに宣言されてい
		ます。
* Superclass of %s can't be an interface: %s
        クラス%sのスーパークラスとしてインターフェースを指定することは
		できません: %s
* Can't access %s. Only public classes and interfaces in other packages
		can be accessed.
        %sがアクセスできません. 他のパッケージのpublic宣言されたクラスまたは
		インターフェースのみをアクセスすることができます.
* Repeated modifier.
        修飾子が繰り返されています.
* Inconsistent member declaration. At most one of public, private, or
protected may be specified.
		アクセス制御の修飾子の一貫性がありません。public,private,protectedの
		いずれか一つを指定してください。
* Can't subclass final classes: %s
        クラス%sはfinal宣言されているため、サブクラスを定義できません.
* Can't subclass interfaces: %s
        インターフェース%sのサブクラスは定義できません.
* Cyclic class inheritance.
        クラスの継承関係がループしています.
* Cyclic class inheritance:  A subclass cannot enclose a superclass.
		クラスの継承関係がループしています.サブクラスは、スーパークラスを含む
		ことはできません。
* Cyclic interface inheritance.
        インターフェースの継承関係がループしています.
* Cyclic class inheritance or scoping.
		インターフェースの継承関係がループしているか、スコープがループし
		ています。
* %s must be an interface.
        %sはインターフェースでなくてはいけません.
* Interfaces can't be final: %s
        インターフェースはfinal宣言できません: %s
* An interface can't implement anything; it can only extend other interfaces.
        インターフェースはなにも実装することはできません. extendsを使って下さい.
* Multiple inheritance is not supported.
        多重継承はサポートしていません.
* Interface %s repeated.
        インターフェース%sが繰り返されています.
* Invalid class file format: %s, %s
        不当なクラスフォーマットです: %s,%s
* Method %s requires a method body. Otherwise declare it as abstract.
        abstract宣言されていないメソッド%sの定義には本体が必要です.
* Constructor %s requires a method body.
        コンストラクタ%sの定義には本体が必要です.
* Instance variables can't be void: %s
        変数はvoid型として定義できません: %s
* Invalid method declaration; return type required.
        メソッド宣言には返却値型の指定が必要です.
* Superclass %s of %s not found.
        クラス%s(%sのスーパークラス)が見つかりません.
* Interface %s of %s not found.
        インターフェース%s(%sで実装)が見つかりません.
* Class %s can't be declared both abstract and final.
        クラスをabstract宣言すると同時にfinal宣言することはできません: %s
* Argument can't have type void: %s
        引数はvoid型にはできません: %s
* Invalid expression statement.
        不当な式が指定されています.
* catch not reached.
        catchに到達しません. 
* Statement not reached.
        文に到達しません.文の直前にreturnがあったりしませんか？
* Arithmetic exception.
        算術演算が不当です.
* Public %s must be defined in a file called "%s".
        public宣言された型%sを記述するソースファイル名は "%s"でなくては
		いけません.
* %s is defined in %s. Because it is used outside of its source file, 
it should be defined in a file called "%s".
		%sは%sで定義されています。ソースファイルの外で使われているので、
		"%s"というファイルの中で定義されている必要があります。
* Possible loss of precision. Use an explicit cast to convert %s to %s.
        精度が失われます. %sから%sに明示的にキャストしてください.
* Variable '%s' is used twice in the argument list of this method.
        変数%sはこのメソッドの引数列に二度用いられています.
* Variable '%s' is already defined in this method.
        変数%sはメソッド中ですでに定義されています.
* Local class '%s' is already defined in this method.
		ローカルクラス %sは、すでにこのメソッド内で定義されています。
* The class name '%s' is already defined in this scope.  An inner class may 
not have the same simple name as any of its enclosing classes.
		クラス%sは、すでにこのスコープ内で定義されています。 内部クラスは、
		そのクラスが含んでいるすべてのクラスと同じシンプルな名前を持つことは
		できません。
* Variable '%s' is inherited in %s, and hides a variable of the same name in %s.
 An explicit 'this' qualifier must be used to select the desired instance.
		変数%sは、%sで継承されていますが、それは%s内の同じ名前の変数を隠してし
		まいます。望む継承を選択するには、明示的にthisという修飾子を使わなけれ
		ばなりません。
* Variable '%s' is inherited in %s, and hides a local variable of the same name.
 An explicit 'this' qualifier must be used to select the variable, or the local
must be renamed.
		変数%sは%sで継承されていますが、それは同じ名前のローカル変数を隠してしま
		います。望む継承を選択するには、明示的にthisという修飾子を使わなけれ
		ばなりません。あるいは、ローカル変数の名前を変える必要があります。
* Method '%s' is inherited in %s, and hides a method of the same name in %s. 
An explicit 'this' qualifier must be used to select the desired instance.
		メソッド%sは、%sで継承されていますが、それは同じ名前の%sで定義されている
		メソッドを隠してしまいます。明示的にthisという修飾子を使わなけれ
		ばなりません。
* Type '%s' is inherited in %s, and hides a type of the same name in an
enclosing scope. An explicit qualifier prefix must be used to name this type.
		型%sは、%sで継承されていますが、それは同じスコープにある同じ名前の型を
		隠してしまいます。明示的な修飾子がこの名前には必要とされます。
* The type %s can't be private. Package members are always accessible 
		within the current package.
        クラスをprivate宣言することはできません. クラスは同一パッケージ中
		からは必ず参照することができます.
* The type %s can't be declared static. It is already top-level, since it is 
a member of a package.
		型 %sは、static宣言することはできません。これはパッケージのメンバなの
		で、すでにトップレベルです。
* The type %s can't be made protected. Package members can either be public 
or local to the current package.
		型%sはprotectedにすることはできません。パッケージのメンバはこの
		パッケージに対してはpublicまたはローカルです。
* Recursive constructor invocation: %s.
        コンストラクタ呼び出しが再帰しています: %s.
* File %s does not contain %s as expected, but %s. Please remove the file.
        ファイル%sは期待される%sを含んでおらず、かわりに%sを含んでいます.
		ファイルを消去してください.
* Class %s not found in %s.
        クラス%sは%s中には見つかりません.
* Package %s not found in %s.
        パッケージ%sは%s中には見つかりません.
* Invalid exception %s in throws clause. The exception must be a subclass 
		of an exception thrown by %s from %s.
        不当な例外%sがthrows節に指定されています.throwされる例外は%s
		(%sより由来)でthrowされる例外のサブクラスでなくてはいけません.
* %s in throws clause must be a subclass of class java.lang.Throwable.
        throws節中の%sはjava.lang.Throwableクラスのサブクラスでなくて
		はいけません.
* Can't throw %s; it must be a subclass of class java.lang.Throwable.
        java.lang.Throwableのサブクラスではないため、%sをthrowできません.
* Can't catch %s; it must be a subclass of class java.lang.Throwable.
        java.lang.Throwableのサブクラスではないため、%sをcatchできません.
* Exception %s can't be thrown in initializer.
        例外を初期化子中でthrowすることはできません: %s
* Can't read: %s
        ファイルから読み込めません: %s
* Can't write: %s
        ファイルに書き込めません: %s
* An error has occurred in the compiler; please file a bug report 
		(java-bugs@java.sun.com).
        コンパイラ内部でエラーが発生しました. バグリポートをおくって下さい
		(java-bugs@java.sun.com).
* An exception has occurred in the compiler; please file a bug report
		(java-bugs@java.sun.com).
        コンパイラ内部でエラーが発生しました. バグリポートをおくって下さい
		(java-bugs@java.sun.com).
* Support for inner classes has been disabled.
		内部クラスはサポートしていません。
* Exception %s must be caught, or it must be declared in the throws clause
		of this method.
        例外%sをcatchするか、あるいは、このメソッドのthrows節で宣言しなくては
		いけません.
* Exception %s is never thrown in the body of the corresponding try statement.
        例外%sは対応するtry節中でthrowされることはありません.
* No enclosing instance of %s is in scope; an explicit one must be provided 
when creating %s, as in "outer. new Inner()" or "outer. super()".
		%sのインスタンスはスコープの中にありません。%sを作る時に明示してく
		ださい。"outer. new Inner()" or "outer. super()"のようにします。
* No enclosing instance of %s is in scope; cannot create a default constructor 
for %s.
		%sのインスタンスはスコープの中にありません。%sのデフォルトの
		コンストラクタを作成することができません。
* No enclosing instance of %s is in scope; an explicit one must be provided 
when accessing %s, as in "outer.member".
		%sのインスタンスはスコープの中にありません。%sにアクセスするときは
		明示することが必要です。"outer.member"のようにします。
* The type %s can't be static.  Static members can only occur in interfaces and
top-level classes.
		型%sは、%sにおいてはstaticにできません。インターフェースのメンバか、
		トップレベルのクラスのメンバのみ、staticにできます。
* Variable %s can't be static in %s.  Only members of interfaces and top-level
classes can be static.
		変数%sは、%sにおいてはstaticにできません。インターフェースのメンバか、
		トップレベルのクラスのメンバのみ、staticにできます。
* Method %s can't be static in %s.  Only members of interfaces and
top-level classes can be static.
		メソッド%sは%sにおいてはstaticにできません。インターフェースのメンバか、
		トップレベルのクラスのメンバのみ、staticにできます。
* Too many errors.  (The limit on reported errors is %s.)
	エラーが多すぎます。エラーの最大は%sです。
----------------------------------------------------------------------------




コンパイル時のエラー対処法



プログラミングしている時には、エラーはつきものです。たくさん のエラーに出会
えば出会うほど、プログラマーの経験は増していきます。 Javaのプログラミングに
おいても、エラーはたくさん出てきます。ここでは エラーメッセージが出たときの
対応のしかたについて説明します。
Javaはアメリカ生まれの言語なので、エラーメッセージは英語です。 特に最新版は
日本語化されていない場合が多いです。これは仕方 ないことです。理想的には英語
を読むことができればいいのですが、難しい という方も多いでしょう。しかしエラ
ーメッセージの読みかたにはコツがあり、 それをマスターすれば、英語が苦手でも
大丈夫です。

コツその1、まずエラーの場所を探せ！

エラーメッセージには、どこでエラーが起こったのかがわかるように、 行番号がつ
いています。次のエラーの例を見てください。

game.java:42: Identifier expected.
        poblic void init()
              ^
1 error

このエラーメッセージの最初の行に、game.java:42: Identifier expected. とあり
ますが、これは
「game.javaというプログラムのファイルの42行目でエラーがあり、その エラーは、
"Identifier expected."という内容です。」という意味です。 その次の2行で、その
行の中の場所をさらに詳しく教えてくれているわけです。 「poblicの後に、
Identifier(識別子)があるはずだけど、ないよ。」、 という意味です。識別子とい
うのは、変数名のことです。 このエラーは、poblicが、publicの綴りまちがい だっ
たために生じました。この場合だと、エラーが生じた原因が、すぐにわかりますね。
エディタを起動して、42行目を直せばいいのですから。
ただ、実際に間違えている部分とエラーメッセージの行数はいつでも一致している
とは限らないので、注意してください。




実行時のエラー対処法



------------------------------------------
public class aho extends java.applet.Applet
{
    public void init(){
        int[] a = new int[10];
        a[11] = 299;
    }
}
------------------------------------------
このようなアプレットを実行させると、標準出力にエラーが出ます。

------------------------------------------
java.lang.ArrayIndexOutOfBoundsException: 11
        at aho.init(aho.java:5)
        at sun.applet.AppletPanel.run(AppletPanel.java:251)
        at java.lang.Thread.run(Thread.java)
------------------------------------------
この表示は、「スタックトレース」と呼ばれます。もとのプログラムの何行目で
エラーが発生したのかということまで、教えてくれるのです。上の例の場合は、
java.lang.Thread.run()というメソッドの中から呼びだされた、AppletPanel.java
というプログラムのrun()というメソッドの中の251行目から呼びだされた、
aho.javaの5行目でエラーが発生しているということになります。5行目は、
a[11]= 299;
という文で、これはあきらかに異常ですね。したがって 
ArrayIndexOutOfBoundsExceptionが発生し、その詳しい情報として、11という
インデクスである、ということを示しています。
例外が発生した時には、スタックトレースを見れば、ほぼ理由がわかります。
自分でスタックトレースを表示させることもできます。それには次のようにし
ます。強引に例外を発生させてみましょう。アプリケーションです。
------------------------------------------
class aho
{
    public static void main(String args[] ){
        try{
            throw new Exception("ringo made it");
        }catch( Throwable t ){
            t.printStackTrace();
        }
    }
}
------------------------------------------
実行結果
------------------------------------------
java.lang.Exception: ringo made it
        at aho.main(aho.java:5)
------------------------------------------
実行はmain()から始まるので、スタックトレースは一段しかありません。
しかし、ちゃんと、行数まで表示されていますね。printStackTrace()を使え
ば、エラーを自分の意志で表示したりできるのです。
printStackTrace(PrintStream)というものもあります。それを使えば、ファイ
ルに保存したりできます。




